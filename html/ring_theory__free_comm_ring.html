<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Kenny Lau. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Kenny Lau, Johan Commelin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import group_theory.free_abelian_group data.equiv.algebra data.equiv.functor data.polynomial</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/functor.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import ring_theory.ideal_operations ring_theory.free_ring</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideal_operations.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  local attribute [instance, priority 100] classical.prop_decidable</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='classical.prop_decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Π (a : Prop), decidable a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  variables (α : Type u)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  def free_comm_ring (α : Type u) : Type u :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  free_abelian_group $ multiplicative $ multiset α</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiplicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/type_tags.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`multiset α` is the quotient of `list α` by list permutation. The result
 is a type of finite sets with duplicates allowed.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  namespace free_comm_ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  instance : comm_ring (free_comm_ring α) := free_abelian_group.comm_ring _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_abelian_group.comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 270, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_1 : comm_monoid.{u} α], comm_ring.{u} (free_abelian_group.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  instance : inhabited (free_comm_ring α) := ⟨0⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  variables {α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  def of (x : α) : free_comm_ring α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  free_abelian_group.of ([x] : multiset α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {T : Type u}, T → list.{u} T → list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u}, T → list.{u} T → list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`multiset α` is the quotient of `list α` by list permutation. The result
 is a type of finite sets with duplicates allowed.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  @[elab_as_eliminator] protected lemma induction_on</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated as f were an eliminator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    {C : free_comm_ring α → Prop} (z : free_comm_ring α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    (hn1 : C (-1)) (hb : ∀ b, C (of b))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    (ha : ∀ x y, C x → C y → C (x + y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    (hm : ∀ x y, C x → C y → C (x * y)) : C z :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  have hn : ∀ x, C x → C (-x), from λ x ih, neg_one_mul x ▸ hm _ _ hn1 ih,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hn1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) (@has_one.one.{u} α (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)))) a) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x y : free_comm_ring.{u} α), C x → C y → C (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='The additive inverse of one multiplied by an element of a ring is the element&#x27;s additive
   inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  have h1 : C 1, from neg_neg (1 : free_comm_ring α) ▸ hn _ hn1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='neg_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hn1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='free_comm_ring.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] (a : α), @eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x : free_comm_ring.{u} α), C x → C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  free_abelian_group.induction_on z</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    (add_left_neg (1 : free_comm_ring α) ▸ ha _ _ hn1 h1)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='add_left_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hn1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] (a : α), @eq.{u+1} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a) a) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {P : α → Prop} {a b : α}, @eq.{u+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x y : free_comm_ring.{u} α), C x → C y → C (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    (λ m, multiset.induction_on m h1 $ λ a m ih, hm _ _ (hb a) ih)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 40}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : multiset.{u} α → Prop} (s : multiset.{u} α), p (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)) → (∀ ⦃a : α⦄ {s : multiset.{u} α}, p s → p (@multiset.cons.{u} α a s)) → p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='multiset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x y : free_comm_ring.{u} α), C x → C y → C (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (b : α), C (@free_comm_ring.of.{u} α b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    (λ m ih, hn _ ih)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x : free_comm_ring.{u} α), C x → C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    ha</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (x y : free_comm_ring.{u} α), C x → C y → C (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  section lift</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  variables {β : Type v} [comm_ring β] (f : α → β)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  def lift : free_comm_ring α → β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  free_abelian_group.lift $ λ s, (s.map f).prod</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='multiset.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='multiset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 599, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 715, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β], (α → β) → free_abelian_group.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → multiset.{u} α → multiset.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [_inst_1 : comm_monoid.{v} α], multiset.{v} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`map f s` is the lift of the list `map` operation. The multiplicity
 of `b` in `map f s` is the number of `a ∈ s` (counting multiplicity)
 such that `f a = b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Product of a multiset given a commutative monoid structure on `α`.
 `prod {a, b, c} = a * b * c`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  @[simp] lemma lift_zero : lift f 0 = 0 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  @[simp] lemma lift_one : lift f 1 = 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  free_abelian_group.lift.of _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x : α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  @[simp] lemma lift_of (x : α) : lift f (of x) = f x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  (free_abelian_group.lift.of _ _).trans $ mul_one _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x : α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v} {a b c : α}, @eq.{v+1} α a b → @eq.{v+1} α b c → @eq.{v+1} α a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : monoid.{v} α] (a : α), @eq.{v+1} α (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α (@monoid.to_semigroup.{v} α _inst_1)) a (@has_one.one.{v} α (@monoid.to_has_one.{v} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  @[simp] lemma lift_add (x y) : lift f (x + y) = lift f x + lift f y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  free_abelian_group.lift.add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β _inst_1)))) (@free_abelian_group.lift.{u v} α β _inst_1 f x) (@free_abelian_group.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  @[simp] lemma lift_neg (x) : lift f (-x) = -lift f x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  free_abelian_group.lift.neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β _inst_1)) (@free_abelian_group.lift.{u v} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  @[simp] lemma lift_sub (x y) : lift f (x - y) = lift f x - lift f y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  free_abelian_group.lift.sub _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_abelian_group.lift.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@has_sub.sub.{u} (free_abelian_group.{u} α) (@add_group_has_sub.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x y)) (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β _inst_1)) (@free_abelian_group.lift.{u v} α β _inst_1 f x) (@free_abelian_group.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  @[simp] lemma lift_mul (x y) : lift f (x * y) = lift f x * lift f y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    refine free_abelian_group.induction_on y (mul_zero _).symm _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : mul_zero_class.{v} α] (a : α), @eq.{v+1} α (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α _inst_1) a (@has_zero.zero.{v} α (@mul_zero_class.to_has_zero.{v} α _inst_1))) (@has_zero.zero.{v} α (@mul_zero_class.to_has_zero.{v} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            x_1))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f x_1)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f y)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    { intros s2, conv { to_lhs, dsimp only [(*), mul_zero_class.mul, semiring.mul, ring.mul, semigroup.mul, comm_ring.mul] },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            x_1))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f x_1)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f y)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
| @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
| @free_comm_ring.lift.{u v} α β _inst_1 f
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       x
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
| @free_comm_ring.lift.{u v} α β _inst_1 f
    (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
       (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (λ (x₂ : multiplicative.{u} (multiset.{u} α)),
          @free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    x₂))
            x)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₂ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
               (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                  @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                    (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                       (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                          (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                             (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                   (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                       x₁
                       x₂))
               x)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      rw [free_abelian_group.lift.of, lift, free_abelian_group.lift.of],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : comm_ring.{?l_2} β], (α → β) → free_comm_ring.{?l_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_group.{v} β] (f : α → β) (x : α), @eq.{v+1} β (@free_abelian_group.lift.{u v} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₂ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
               (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                  @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                    (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                       (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                          (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                             (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                   (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                       x₁
                       x₂))
               x)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x)
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      refine free_abelian_group.induction_on x (zero_mul _).symm _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : mul_zero_class.{v} α] (a : α), @eq.{v+1} α (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α _inst_1) (@has_zero.zero.{v} α (@mul_zero_class.to_has_zero.{v} α _inst_1)) a) (@has_zero.zero.{v} α (@mul_zero_class.to_has_zero.{v} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            x))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            x)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            y)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72      { intros s1, iterate 3 { rw free_abelian_group.lift.of },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            x))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            x)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            y)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
          (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
             (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                   (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                      (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                         (@multiset.ordered_cancel_comm_monoid.{u} α)))))
             s1
             s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
       (@multiset.map.{u v} α β f
          (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
             (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                   (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                      (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                         (@multiset.ordered_cancel_comm_monoid.{u} α)))))
             s1
             s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73        calc _ = multiset.prod ((multiset.map f s1) + (multiset.map f s2)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='multiset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='s1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 715, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 599, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type v} [_inst_1 : comm_monoid.{v} α], multiset.{v} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → multiset.{u} α → multiset.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Product of a multiset given a commutative monoid structure on `α`.
 `prod {a, b, c} = a * b * c`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`map f s` is the lift of the list `map` operation. The multiplicity
 of `b` in `map f s` is the number of `a ∈ s` (counting multiplicity)
 such that `f a = b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
       (@multiset.map.{u v} α β f
          (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
             (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                   (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                      (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                         (@multiset.ordered_cancel_comm_monoid.{u} α)))))
             s1
             s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74            by {congr&#x27; 1, exact multiset.map_add _ _ _}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='multiset.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 612, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : α → β) (s t : multiset.{u} α), @eq.{v+1} (multiset.{v} β) (@multiset.map.{u v} α β f (@has_add.add.{u} (multiset.{u} α) (@multiset.has_add.{u} α) s t)) (@has_add.add.{v} (multiset.{v} β) (@multiset.has_add.{v} β) (@multiset.map.{u v} α β f s) (@multiset.map.{u v} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
       (@multiset.map.{u v} α β f
          (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
             (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                   (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                      (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                         (@multiset.ordered_cancel_comm_monoid.{u} α)))))
             s1
             s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
       (@multiset.map.{u v} α β f
          (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
             (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                   (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                      (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                         (@multiset.ordered_cancel_comm_monoid.{u} α)))))
             s1
             s2)))
    (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
       (@has_add.add.{v} (multiset.{v} β) (@multiset.has_add.{v} β) (@multiset.map.{u v} α β f s1)
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} (multiset.{v} β)
    (@multiset.map.{u v} α β f
       (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
          (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
             (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                   (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                      (@multiset.ordered_cancel_comm_monoid.{u} α)))))
          s1
          s2))
    (@has_add.add.{v} (multiset.{v} β) (@multiset.has_add.{v} β) (@multiset.map.{u v} α β f s1)
       (@multiset.map.{u v} α β f s2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75           ... = _ : multiset.prod_add _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='multiset.prod_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 742, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : comm_monoid.{v} α] (s t : multiset.{v} α), @eq.{v+1} α (@multiset.prod.{v} α _inst_1 (@has_add.add.{v} (multiset.{v} α) (@multiset.has_add.{v} α) s t)) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α (@monoid.to_semigroup.{v} α (@comm_monoid.to_monoid.{v} α _inst_1))) (@multiset.prod.{v} α _inst_1 s) (@multiset.prod.{v} α _inst_1 t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} β
    (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
       (@multiset.map.{u v} α β f
          (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
             (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                   (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                      (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                         (@multiset.ordered_cancel_comm_monoid.{u} α)))))
             s1
             s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            x))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            x)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            y)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76      { intros s1 ih, iterate 3 { rw free_abelian_group.lift.neg }, rw [ih, neg_mul_eq_neg_mul] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_abelian_group.lift.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_mul_eq_neg_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)) (@free_abelian_group.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)) (λ (s : multiplicative.{u} (multiset.{u} α)), @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s)) (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α)) (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))) (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α))) (λ (x₁ : multiplicative.{u} (multiset.{u} α)), @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α)) (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α)) (@multiplicative.comm_monoid.{u} (multiset.{u} α) (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α) (@multiset.ordered_cancel_comm_monoid.{u} α))))) x₁ s2)) (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)) (λ (s : multiplicative.{u} (multiset.{u} α)), @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s)) (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)) (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [s : ring.{v} α] (a b : α), @eq.{v+1} α (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α s))) (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α s))) a b)) (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α s))) (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α s))) a) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            x))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            x)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            y)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_neg.neg.{v} β
          (@add_group.to_has_neg.{v} β
             (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_mul.mul.{v} β
          (@mul_zero_class.to_has_mul.{v} β
             (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
          (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
             (@multiset.map.{u v} α β f s2))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_neg.neg.{v} β
          (@add_group.to_has_neg.{v} β
             (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_neg.neg.{v} β
          (@add_group.to_has_neg.{v} β
             (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s1)))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            x))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            x)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            y)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77      { intros x1 x2 ih1 ih2, iterate 3 { rw free_abelian_group.lift.add }, rw [ih1, ih2, add_mul] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='free_abelian_group.lift.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 833, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x y : free_abelian_group.{u} α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β (@add_group.to_add_monoid.{u} β (@add_comm_group.to_add_group.{u} β _inst_1)))) (@free_abelian_group.lift.{u u} α β _inst_1 f x) (@free_abelian_group.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat lean.parser.small_nat) → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)) (λ (s : multiplicative.{u} (multiset.{u} α)), @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s)) (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α)) (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))) (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α))) (λ (x₁ : multiplicative.{u} (multiset.{u} α)), @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α)) (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α)) (@multiplicative.comm_monoid.{u} (multiset.{u} α) (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α) (@multiset.ordered_cancel_comm_monoid.{u} α))))) x₁ s2)) x1)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)) (λ (s : multiplicative.{u} (multiset.{u} α)), @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s)) x1) (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)) (λ (s : multiplicative.{u} (multiset.{u} α)), @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s)) (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α)) (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))) (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α))) (λ (x₁ : multiplicative.{u} (multiset.{u} α)), @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α)) (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α)) (@multiplicative.comm_monoid.{u} (multiset.{u} α) (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α) (@multiset.ordered_cancel_comm_monoid.{u} α))))) x₁ s2)) x2)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)) (λ (s : multiplicative.{u} (multiset.{u} α)), @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s)) x2) (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1)) (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : distrib.{v} α] (a b c : α), @eq.{v+1} α (@has_mul.mul.{v} α (@distrib.to_has_mul.{v} α _inst_1) (@has_add.add.{v} α (@distrib.to_has_add.{v} α _inst_1) a b) c) (@has_add.add.{v} α (@distrib.to_has_add.{v} α _inst_1) (@has_mul.mul.{v} α (@distrib.to_has_mul.{v} α _inst_1) a c) (@has_mul.mul.{v} α (@distrib.to_has_mul.{v} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.

`iterate n { t }` applies `t` `n` times.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='iterate'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α)
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            x))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            x)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            y)
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2))) →
    @eq.{v+1} β
      (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
         (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
         (λ (s : multiplicative.{u} (multiset.{u} α)),
            @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
              (@multiset.map.{u v} α β f s))
         (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
            (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
               @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                 (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                    (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                       (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                          (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                    x₁
                    s2))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
            (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
            (λ (s : multiplicative.{u} (multiset.{u} α)),
               @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                 (@multiset.map.{u v} α β f s))
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y))
         (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
x1 x2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x1)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2))),
ih2 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x2)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             x1
             x2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             x1
             x2))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
x1 x2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x1)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2))),
ih2 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x2)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             x1)
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             x2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             x1
             x2))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
x1 x2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x1)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2))),
ih2 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x2)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β
                   (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             x1))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             x2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_add.add.{v} β
          (@add_semigroup.to_has_add.{v} β
             (@add_monoid.to_add_semigroup.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β
                      (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x1)
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x2))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
x1 x2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x1)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2))),
ih2 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x2)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β
                   (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
       (@has_mul.mul.{v} β
          (@mul_zero_class.to_has_mul.{v} β
             (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x1)
          (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
             (@multiset.map.{u v} α β f s2)))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             x2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_add.add.{v} β
          (@add_semigroup.to_has_add.{v} β
             (@add_monoid.to_add_semigroup.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β
                      (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x1)
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x2))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
x1 x2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x1)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2))),
ih2 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x2)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β
                   (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
       (@has_mul.mul.{v} β
          (@mul_zero_class.to_has_mul.{v} β
             (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x1)
          (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
             (@multiset.map.{u v} α β f s2)))
       (@has_mul.mul.{v} β
          (@mul_zero_class.to_has_mul.{v} β
             (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x2)
          (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
             (@multiset.map.{u v} α β f s2))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_add.add.{v} β
          (@add_semigroup.to_has_add.{v} β
             (@add_monoid.to_add_semigroup.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β
                      (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x1)
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x2))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
x1 x2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x1)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2))),
ih2 :
  @eq.{v+1} β
    (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
       (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
       (λ (s : multiplicative.{u} (multiset.{u} α)),
          @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
            (@multiset.map.{u v} α β f s))
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
             @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
               (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                  (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                     (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                        (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                           (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                              (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                  x₁
                  s2))
          x2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          x2)
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β
                   (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             x1))
       (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
          (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
               (@multiset.map.{u v} α β f s))
          (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
             (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (λ (x₁ : multiplicative.{u} (multiset.{u} α)),
                @free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
                  (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
                     (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
                        (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                           (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                              (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                                 (@multiset.ordered_cancel_comm_monoid.{u} α)))))
                     x₁
                     s2))
             x2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_add.add.{v} β
          (@add_semigroup.to_has_add.{v} β
             (@add_monoid.to_add_semigroup.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β
                      (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))))
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x1)
          (@free_abelian_group.lift.{u v} (multiplicative.{u} (multiset.{u} α)) β
             (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))
             (λ (s : multiplicative.{u} (multiset.{u} α)),
                @multiset.prod.{v} β
                  (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
                  (@multiset.map.{u v} α β f s))
             x2))
       (@multiset.prod.{v} β (@comm_semiring.to_comm_monoid.{v} β (@comm_ring.to_comm_semiring.{v} β _inst_1))
          (@multiset.map.{u v} α β f s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            x_1))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f x_1)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f y)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    { intros s2 ih, rw [mul_neg_eq_neg_mul_symm, lift_neg, lift_neg, mul_neg_eq_neg_mul_symm, ih] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='mul_neg_eq_neg_mul_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_neg_eq_neg_mul_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [s : ring.{u} α] (a b : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) b)) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α s))) (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α s))) a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [s : ring.{v} α] (a b : α), @eq.{v+1} α (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α s))) a (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α s))) b)) (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α s))) (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α s))) a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))

α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            x_1))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f x_1)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f y)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 : multiplicative.{u} (multiset.{u} α)),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             x
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             x
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             x
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@has_neg.neg.{v} β
          (@add_group.to_has_neg.{v} β
             (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_comm_ring.lift.{u v} α β _inst_1 f
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             x
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_mul.mul.{v} β
          (@mul_zero_class.to_has_mul.{v} β
             (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_comm_ring.lift.{u v} α β _inst_1 f x)
          (@free_comm_ring.lift.{u v} α β _inst_1 f
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2)))
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            x_1))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f x_1)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f y)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    { intros y1 y2 ih1 ih2, rw [mul_add, lift_add, lift_add, mul_add, ih1, ih2] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : distrib.{u} α] (a b c : α), @eq.{u+1} α (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) b c)) (@has_add.add.{u} α (@distrib.to_has_add.{u} α _inst_1) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a b) (@has_mul.mul.{u} α (@distrib.to_has_mul.{u} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : distrib.{v} α] (a b c : α), @eq.{v+1} α (@has_mul.mul.{v} α (@distrib.to_has_mul.{v} α _inst_1) a (@has_add.add.{v} α (@distrib.to_has_add.{v} α _inst_1) b c)) (@has_add.add.{v} α (@distrib.to_has_add.{v} α _inst_1) (@has_mul.mul.{v} α (@distrib.to_has_mul.{v} α _inst_1) a b) (@has_mul.mul.{v} α (@distrib.to_has_mul.{v} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y1)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y2)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α
⊢ ∀ (x_1 y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            x_1))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f x_1)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            y))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f y)) →
    @eq.{v+1} β
      (@free_comm_ring.lift.{u v} α β _inst_1 f
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            x
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))
      (@has_mul.mul.{v} β
         (@mul_zero_class.to_has_mul.{v} β
            (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
         (@free_comm_ring.lift.{u v} α β _inst_1 f x)
         (@free_comm_ring.lift.{u v} α β _inst_1 f
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x_1
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
y1 y2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y1)),
ih2 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y2))
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             y1
             y2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             y1
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
y1 y2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y1)),
ih2 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y2))
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y1)
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             y1
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
y1 y2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y1)),
ih2 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y2))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y1))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             y1
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
y1 y2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y1)),
ih2 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y2))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y1))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
          (@free_comm_ring.lift.{u v} α β _inst_1 f y1)
          (@free_comm_ring.lift.{u v} α β _inst_1 f y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
y1 y2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y1)),
ih2 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y2))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y1))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y2)))
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@has_mul.mul.{v} β (@distrib.to_has_mul.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
          (@free_comm_ring.lift.{u v} α β _inst_1 f x)
          (@free_comm_ring.lift.{u v} α β _inst_1 f y1))
       (@has_mul.mul.{v} β (@distrib.to_has_mul.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
          (@free_comm_ring.lift.{u v} α β _inst_1 f x)
          (@free_comm_ring.lift.{u v} α β _inst_1 f y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
y1 y2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y1)),
ih2 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y2))
⊢ @eq.{v+1} β
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@has_mul.mul.{v} β
          (@mul_zero_class.to_has_mul.{v} β
             (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
          (@free_comm_ring.lift.{u v} α β _inst_1 f x)
          (@free_comm_ring.lift.{u v} α β _inst_1 f y1))
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_mul.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y2)))
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@has_mul.mul.{v} β (@distrib.to_has_mul.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
          (@free_comm_ring.lift.{u v} α β _inst_1 f x)
          (@free_comm_ring.lift.{u v} α β _inst_1 f y1))
       (@has_mul.mul.{v} β (@distrib.to_has_mul.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
          (@free_comm_ring.lift.{u v} α β _inst_1 f x)
          (@free_comm_ring.lift.{u v} α β _inst_1 f y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
y1 y2 : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih1 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y1))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y1)),
ih2 :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y2))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f y2))
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1 f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             y1
             y2)))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1 f x)
       (@free_comm_ring.lift.{u v} α β _inst_1 f
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             y1
             y2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  instance : is_ring_hom (lift f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  { map_one := lift_one f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_comm_ring.lift_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{v} β (@monoid.to_has_one.{v} β (@ring.to_monoid.{v} β (@comm_ring.to_ring.{v} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    map_mul := lift_mul f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_comm_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 66, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    map_add := lift_add f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  @[simp] lemma lift_pow (x) (n : ℕ) : lift f (x ^ n) = lift f x ^ n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type} [c : has_pow.{u 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type} [c : has_pow.{v 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  is_semiring_hom.map_pow _ x n</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_semiring_hom.map_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : semiring.{u} α] [_inst_2 : semiring.{v} β] (f : α → β) [_inst_3 : @is_semiring_hom.{u v} α β _inst_1 _inst_2 f] (x : α) (n : nat), @eq.{v+1} β (f (@has_pow.pow.{u 0} α nat (@monoid.has_pow.{u} α (@semiring.to_monoid.{u} α _inst_1)) x n)) (@has_pow.pow.{v 0} β nat (@monoid.has_pow.{v} β (@semiring.to_monoid.{v} β _inst_2)) (f x) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  @[simp] lemma lift_comp_of (f : free_comm_ring α → β) [is_ring_hom f] : lift (f ∘ of) = f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} {φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  funext $ λ x, free_comm_ring.induction_on x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 30, &#x27;column&#x27;: 38}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : α → Type v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v+1} (β x) (f₁ x) (f₂ x)) → @eq.{(max (u+1) (v+1))} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {C : free_comm_ring.{u} α → Prop} (z : free_comm_ring.{u} α), C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) → (∀ (b : α), C (@free_comm_ring.of.{u} α b)) → (∀ (x y : free_comm_ring.{u} α), C x → C y → C (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) → (∀ (x y : free_comm_ring.{u} α), C x → C y → C (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    (by rw [lift_neg, lift_one, is_ring_hom.map_neg f, is_ring_hom.map_one f])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_ring_hom.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_ring_hom.map_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{v} β (@monoid.to_has_one.{v} β (@ring.to_monoid.{v} β (@comm_ring.to_ring.{v} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (f : α → β) [_inst_3 : @is_ring_hom.{u v} α β _inst_1 _inst_2 f] {x : α}, @eq.{v+1} β (f (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) x)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β _inst_2))) (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (f : α → β) [c : @is_ring_hom.{u v} α β _inst_1 _inst_2 f], @eq.{v+1} β (f (@has_one.one.{u} α (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)))) (@has_one.one.{v} β (@monoid.to_has_one.{v} β (@ring.to_monoid.{v} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Ring homomorphisms preserve additive inverses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x : free_comm_ring.{u} α
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (f
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x : free_comm_ring.{u} α
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (f
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x : free_comm_ring.{u} α
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_one.one.{v} β (@monoid.to_has_one.{v} β (@ring.to_monoid.{v} β (@comm_ring.to_ring.{v} β _inst_1)))))
    (f
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x : free_comm_ring.{u} α
⊢ @eq.{v+1} β
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@has_one.one.{v} β (@monoid.to_has_one.{v} β (@ring.to_monoid.{v} β (@comm_ring.to_ring.{v} β _inst_1)))))
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (f
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    (lift_of _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x : α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@free_comm_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    (λ x y ihx ihy, by rw [lift_add, is_ring_hom.map_add f, ihx, ihy])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_ring_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) x) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) y) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (f : α → β) [c : @is_ring_hom.{u v} α β _inst_1 _inst_2 f] {x y : α}, @eq.{v+1} β (f (@has_add.add.{u} α (@distrib.to_has_add.{u} α (@ring.to_distrib.{u} α _inst_1)) x y)) (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β _inst_2)) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) x) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) y) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          x
          y))
    (f
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          x)
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          y))
    (f
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          x)
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          y))
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (f x)
       (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (f x)
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          y))
    (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1)))
       (f x)
       (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    (λ x y ihx ihy, by rw [lift_mul, is_ring_hom.map_mul f, ihx, ihy])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_ring_hom.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 66, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) x) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) y) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (f : α → β) [c : @is_ring_hom.{u v} α β _inst_1 _inst_2 f] {x y : α}, @eq.{v+1} β (f (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) x y)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β _inst_2))) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) x) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α)) y) (f y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y))
    (f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          x)
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          y))
    (f
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          x
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          x)
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          y))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (f x)
       (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : free_comm_ring.{u} α → β,
_inst_2 :
  @is_ring_hom.{u v} (free_comm_ring.{u} α) β
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@comm_ring.to_ring.{v} β _inst_1)
    f,
x x y : free_comm_ring.{u} α,
ihx :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       x)
    (f x),
ihy :
  @eq.{v+1} β
    (@free_comm_ring.lift.{u v} α β _inst_1
       (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
       y)
    (f y)
⊢ @eq.{v+1} β
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (f x)
       (@free_comm_ring.lift.{u v} α β _inst_1
          (@function.comp.{u+1 u+1 v+1} α (free_comm_ring.{u} α) β f (@free_comm_ring.of.{u} α))
          y))
    (@has_mul.mul.{v} β
       (@mul_zero_class.to_has_mul.{v} β
          (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1))))
       (f x)
       (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  end lift</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  variables {β : Type v} (f : α → β)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  def map : free_comm_ring α → free_comm_ring β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  lift $ of ∘ f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β φ : Type v}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  @[simp] lemma map_zero : map f 0 = 0 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : comm_ring.{v} β,
f : α → β,
x y : free_comm_ring.{u} α,
s2 s1 : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{v+1} (multiset.{v} β)
    (@multiset.map.{u v} α β f
       (@monoid.mul.{u} (multiplicative.{u} (multiset.{u} α))
          (@comm_monoid.to_monoid.{u} (multiplicative.{u} (multiset.{u} α))
             (@multiplicative.comm_monoid.{u} (multiset.{u} α)
                (@ordered_comm_monoid.to_add_comm_monoid.{u} (multiset.{u} α)
                   (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u} (multiset.{u} α)
                      (@multiset.ordered_cancel_comm_monoid.{u} α)))))
          s1
          s2))
    (@has_add.add.{v} (multiset.{v} β) (@multiset.has_add.{v} β) (@multiset.map.{u v} α β f s1)
       (@multiset.map.{u v} α β f s2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  @[simp] lemma map_one : map f 1 = 1 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  @[simp] lemma map_of (x : α) : map f (of x) = of (f x) := lift_of _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_comm_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x : α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@free_comm_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  @[simp] lemma map_add (x y) : map f (x + y) = map f x + map f y := lift_add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β (@comm_ring.to_ring.{v} β _inst_1))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  @[simp] lemma map_neg (x) : map f (-x) = -map f x := lift_neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  @[simp] lemma map_sub (x y) : map f (x - y) = map f x - map f y := lift_sub _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_sub.sub.{u} (free_comm_ring.{u} α) (@add_group_has_sub.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  @[simp] lemma map_mul (x y) : map f (x * y) = map f x * map f y := lift_mul _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 66, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β (@comm_ring.to_ring.{v} β _inst_1)))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) (@free_comm_ring.lift.{u v} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  @[simp] lemma map_pow (x) (n : ℕ) : map f (x ^ n) = (map f x) ^ n := lift_pow _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type} [c : has_pow.{u 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} {β : Type} [c : has_pow.{v 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β] (f : α → β) (x : free_comm_ring.{u} α) (n : nat), @eq.{v+1} β (@free_comm_ring.lift.{u v} α β _inst_1 f (@has_pow.pow.{u 0} (free_comm_ring.{u} α) nat (@monoid.has_pow.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x n)) (@has_pow.pow.{v 0} β nat (@monoid.has_pow.{v} β (@ring.to_monoid.{v} β (@comm_ring.to_ring.{v} β _inst_1))) (@free_comm_ring.lift.{u v} α β _inst_1 f x) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  def is_supported (x : free_comm_ring α) (s : set α) : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  x ∈ ring.closure (of &#x27;&#x27; s)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring.closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/subring.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R : Type u} [_inst_1 : ring.{u} R], set.{u} R → set.{u} R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, (α → β) → set.{u} α → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  section is_supported</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  variables {x y : free_comm_ring α} {s t : set α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  theorem is_supported_upwards (hs : is_supported x s) (hst : s ⊆ t) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    is_supported x t :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  ring.closure_mono (set.mono_image hst) hs</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring.closure_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mono_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/subring.lean&#x27;, &#x27;line&#x27;: 173, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 918, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s t : set.{u} R}, @has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) s t → @has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) (@ring.closure.{u} R _inst_1 s) (@ring.closure.{u} R _inst_1 t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} {f : α → β} {s t : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (@set.image.{u u} α β f s) (@set.image.{u u} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  theorem is_supported_add (hxs : is_supported x s) (hys : is_supported y s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    is_supported (x + y) s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  is_add_submonoid.add_mem hxs hys</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_submonoid.add_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hys'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u} [_inst_2 : add_monoid.{u} β] {s : set.{u} β} [c : @is_add_submonoid.{u} β _inst_2 s] {a b : β}, @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) a s → @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) b s → @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) (@has_add.add.{u} β (@add_semigroup.to_has_add.{u} β (@add_monoid.to_add_semigroup.{u} β _inst_2)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  theorem is_supported_neg (hxs : is_supported x s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    is_supported (-x) s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  is_add_subgroup.neg_mem hxs</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_subgroup.neg_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u} [_inst_2 : add_group.{u} β] {s : set.{u} β} [c : @is_add_subgroup.{u} β _inst_2 s] {a : β}, @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) a s → @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β _inst_2) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  theorem is_supported_sub (hxs : is_supported x s) (hys : is_supported y s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    is_supported (x - y) s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  is_add_subgroup.sub_mem _ _ _ hxs hys</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_subgroup.sub_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hys'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/subgroup.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] (s : set.{u} α) [_inst_2 : @is_add_subgroup.{u} α _inst_1 s] (a b : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) b s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@has_sub.sub.{u} α (@add_group_has_sub.{u} α _inst_1) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  theorem is_supported_mul (hxs : is_supported x s) (hys : is_supported y s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    is_supported (x * y) s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  is_submonoid.mul_mem hxs hys</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_submonoid.mul_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hys'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] {s : set.{u} α} [c : @is_submonoid.{u} α _inst_1 s] {a b : α}, @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) b s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  theorem is_supported_zero : is_supported 0 s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  is_add_submonoid.zero_mem _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_add_submonoid.zero_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u} [_inst_2 : add_monoid.{u} β] (s : set.{u} β) [c : @is_add_submonoid.{u} β _inst_2 s], @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) (@has_zero.zero.{u} β (@add_monoid.to_has_zero.{u} β _inst_2)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  theorem is_supported_one : is_supported 1 s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  is_submonoid.one_mem _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_submonoid.one_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/submonoid.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : monoid.{u} α] (s : set.{u} α) [c : @is_submonoid.{u} α _inst_1 s], @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) (@has_one.one.{u} α (@monoid.to_has_one.{u} α _inst_1)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  theorem is_supported_int {i : ℤ} {s : set α} : is_supported ↑i s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type} {b : Type u} [_inst_1 : has_lift_t.{1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  int.induction_on i is_supported_zero</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='int.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.is_supported_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 38}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 139, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : int → Prop} (i : int), p (@has_zero.zero.{0} int int.has_zero) → (∀ (i : nat), p (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i) → p (@has_add.add.{0} int int.has_add (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i) (@has_one.one.{0} int int.has_one))) → (∀ (i : nat), p (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)) → p (@has_sub.sub.{0} int int.has_sub (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)) (@has_one.one.{0} int int.has_one))) → p i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α (@has_zero.zero.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    (λ i hi, by rw [int.cast_add, int.cast_one]; exact is_supported_add hi is_supported_one)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='int.cast_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.cast_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.is_supported_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.is_supported_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1094, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1080, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : has_one.{u} α] (m n : int), @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) (@has_add.add.{0} int int.has_add m n)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1))) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) m) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] [_inst_2 : has_one.{u} α] [_inst_3 : has_neg.{u} α], @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α _inst_3 (@add_monoid.to_has_zero.{u} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1))))) (@has_one.one.{0} int int.has_one)) (@has_one.one.{u} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {x y : free_comm_ring.{u} α} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @free_comm_ring.is_supported.{u} α y s → @free_comm_ring.is_supported.{u} α (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@free_comm_ring.is_supported.{u} α (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
             (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                   (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                      (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                     (free_comm_ring.comm_ring.{u} α))))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                      (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                     (free_comm_ring.comm_ring.{u} α))))))))))
          (@has_one.one.{0} int int.has_one)))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
          (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
             (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                   (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                      (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                     (free_comm_ring.comm_ring.{u} α))))))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    (λ i hi, by rw [int.cast_sub, int.cast_one]; exact is_supported_sub hi is_supported_one)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='int.cast_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.cast_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.is_supported_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.is_supported_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1109, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1080, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 131, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : has_one.{u} α] (m n : int), @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) (@has_sub.sub.{0} int int.has_sub m n)) (@has_sub.sub.{u} α (@add_group_has_sub.{u} α _inst_1) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) m) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] [_inst_2 : has_one.{u} α] [_inst_3 : has_neg.{u} α], @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α _inst_3 (@add_monoid.to_has_zero.{u} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1))))) (@has_one.one.{0} int int.has_one)) (@has_one.one.{u} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {x y : free_comm_ring.{u} α} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @free_comm_ring.is_supported.{u} α y s → @free_comm_ring.is_supported.{u} α (@has_sub.sub.{u} (free_comm_ring.{u} α) (@add_group_has_sub.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@free_comm_ring.is_supported.{u} α (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@has_sub.sub.{u} (free_comm_ring.{u} α)
       (@add_group_has_sub.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                      (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                     (free_comm_ring.comm_ring.{u} α))))))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                      (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                     (free_comm_ring.comm_ring.{u} α))))))))))
          (@has_one.one.{0} int int.has_one)))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@has_sub.sub.{u} (free_comm_ring.{u} α)
       (@add_group_has_sub.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                      (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                     (free_comm_ring.comm_ring.{u} α))))))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
i : int,
s : set.{u} α,
i : nat,
hi :
  @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    s
⊢ @free_comm_ring.is_supported.{u} α
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  end is_supported</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  def restriction (s : set α) [decidable_pred s] (x : free_comm_ring α) : free_comm_ring s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  lift (λ p, if H : p ∈ s then of ⟨p, H⟩ else 0) x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (c : Prop) [h : decidable c] {α : Type u}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  section restriction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  variables (s : set α) [decidable_pred s] (x y : free_comm_ring α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  @[simp] lemma restriction_of (p) : restriction s (of p) = if H : p ∈ s then of ⟨p, H⟩ else 0 := lift_of _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (c : Prop) [h : decidable c] {α : Type u}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@free_comm_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  @[simp] lemma restriction_zero : restriction s 0 = 0 := lift_zero _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring.lift_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_zero.zero.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@has_zero.zero.{u} β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β (@comm_ring.to_ring.{u} β _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  @[simp] lemma restriction_one : restriction s 1 = 1 := lift_one _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring.lift_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{u} β (@monoid.to_has_one.{u} β (@ring.to_monoid.{u} β (@comm_ring.to_ring.{u} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  @[simp] lemma restriction_add : restriction s (x + y) = restriction s x + restriction s y := lift_add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@ring.to_distrib.{u} β (@comm_ring.to_ring.{u} β _inst_1))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  @[simp] lemma restriction_neg : restriction s (-x) = -restriction s x := lift_neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β (@ring.to_add_comm_group.{u} β (@comm_ring.to_ring.{u} β _inst_1)))) (@free_comm_ring.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  @[simp] lemma restriction_sub : restriction s (x - y) = restriction s x - restriction s y := lift_sub _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_sub.sub.{u} (free_comm_ring.{u} α) (@add_group_has_sub.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_sub.sub.{u} β (@add_group_has_sub.{u} β (@add_comm_group.to_add_group.{u} β (@ring.to_add_comm_group.{u} β (@comm_ring.to_ring.{u} β _inst_1)))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  @[simp] lemma restriction_mul : restriction s (x * y) = restriction s x * restriction s y := lift_mul _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 66, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β (@comm_ring.to_ring.{u} β _inst_1)))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  end restriction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  theorem is_supported_of {p} {s : set α} : is_supported (of p) s ↔ p ∈ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  suffices is_supported (of p) s → p ∈ s, from ⟨this, λ hps, ring.subset_closure ⟨p, hps, rfl⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hps'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ring.subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hps'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/subring.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s → @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R}, @has_subset.subset.{u} (set.{u} R) (@set.has_subset.{u} R) s (@ring.closure.{u} R _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  assume hps : is_supported (of p) s, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    classical,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    have : ∀ x, is_supported x s →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171      ∃ (n : ℤ), lift (λ a, if a ∈ s then (0 : polynomial ℤ) else polynomial.X) x = n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='polynomial.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type) [_inst_1 : comm_semiring.{0} α], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : comm_semiring.{0} α], @polynomial.{0} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `polynomial α` is the type of univariate polynomials over `α`.

Polynomials should be seen as (semi-)rings with the additional constructor `X`.
The embedding from α is called `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`X` is the polynomial variable (aka indeterminant).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a
⊢ ∀ (x : free_comm_ring.{u} α),
    @free_comm_ring.is_supported.{u} α x s →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  ∀ (x : free_comm_ring.{u} α),
    @free_comm_ring.is_supported.{u} α x s →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    { intros x hx, refine ring.in_closure.rec_on hx _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='ring.in_closure.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/subring.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R} {C : R → Prop} {x : R}, @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s) → C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) → C (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))) → (∀ (z : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s → ∀ (n : R), C n → C (@has_mul.mul.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) z n)) → (∀ {x y : R}, C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y)) → C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a
⊢ ∀ (x : free_comm_ring.{u} α),
    @free_comm_ring.is_supported.{u} α x s →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  ∀ (x : free_comm_ring.{u} α),
    @free_comm_ring.is_supported.{u} α x s →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a
⊢ ∀ (x : free_comm_ring.{u} α),
    @free_comm_ring.is_supported.{u} α x s →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            x)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_one.one.{u} (free_comm_ring.{u} α)
               (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                  (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_neg.neg.{u} (free_comm_ring.{u} α)
               (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                     (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
               (@has_one.one.{u} (free_comm_ring.{u} α)
                  (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                     (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                n)
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1)) →
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                (@has_mul.mul.{u} (free_comm_ring.{u} α)
                   (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   z
                   n))
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173      { use 1, rw [lift_one], norm_cast },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='free_comm_ring.lift_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β] (f : α → β), @eq.{1} β (@free_comm_ring.lift.{u 0} α β _inst_1 f (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{0} β (@monoid.to_has_one.{0} β (@ring.to_monoid.{0} β (@comm_ring.to_ring.{0} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize casts at the given locations by moving them &quot;upwards&quot;.
As opposed to simp, norm_cast can be used without necessarily
closing the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_one.one.{u} (free_comm_ring.{u} α)
               (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                  (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_neg.neg.{u} (free_comm_ring.{u} α)
               (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                     (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
               (@has_one.one.{u} (free_comm_ring.{u} α)
                  (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                     (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                n)
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1)) →
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                (@has_mul.mul.{u} (free_comm_ring.{u} α)
                   (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   z
                   n))
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_one.one.{u} (free_comm_ring.{u} α)
               (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                  (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_one.one.{0} int int.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_one.one.{0} (@polynomial.{0} int int.comm_semiring)
       (@monoid.to_has_one.{0} (@polynomial.{0} int int.comm_semiring)
          (@ring.to_monoid.{0} (@polynomial.{0} int int.comm_semiring)
             (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)))))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_one.one.{0} int int.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_neg.neg.{u} (free_comm_ring.{u} α)
               (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                     (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
               (@has_one.one.{u} (free_comm_ring.{u} α)
                  (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                     (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                n)
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1)) →
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                (@has_mul.mul.{u} (free_comm_ring.{u} α)
                   (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   z
                   n))
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174      { use -1, rw [lift_neg, lift_one], norm_cast },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_comm_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [c : has_neg.{?l_1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β] (f : α → β) (x : free_comm_ring.{u} α), @eq.{1} β (@free_comm_ring.lift.{u 0} α β _inst_1 f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{0} β (@add_group.to_has_neg.{0} β (@add_comm_group.to_add_group.{0} β (@ring.to_add_comm_group.{0} β (@comm_ring.to_ring.{0} β _inst_1)))) (@free_comm_ring.lift.{u 0} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β] (f : α → β), @eq.{1} β (@free_comm_ring.lift.{u 0} α β _inst_1 f (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{0} β (@monoid.to_has_one.{0} β (@ring.to_monoid.{0} β (@comm_ring.to_ring.{0} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize casts at the given locations by moving them &quot;upwards&quot;.
As opposed to simp, norm_cast can be used without necessarily
closing the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_neg.neg.{u} (free_comm_ring.{u} α)
               (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                     (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
               (@has_one.one.{u} (free_comm_ring.{u} α)
                  (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                     (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                n)
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1)) →
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                (@has_mul.mul.{u} (free_comm_ring.{u} α)
                   (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   z
                   n))
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_neg.neg.{u} (free_comm_ring.{u} α)
               (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                  (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                     (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
               (@has_one.one.{u} (free_comm_ring.{u} α)
                  (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                     (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_neg.neg.{0} (@polynomial.{0} int int.comm_semiring)
       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                   (@polynomial.comm_ring.{0} int int.comm_ring)))))
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_neg.neg.{0} (@polynomial.{0} int int.comm_semiring)
       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                   (@polynomial.comm_ring.{0} int int.comm_ring)))))
       (@has_one.one.{0} (@polynomial.{0} int int.comm_semiring)
          (@monoid.to_has_one.{0} (@polynomial.{0} int int.comm_semiring)
             (@ring.to_monoid.{0} (@polynomial.{0} int int.comm_semiring)
                (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                   (@polynomial.comm_ring.{0} int int.comm_ring))))))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_neg.neg.{0} int int.has_neg (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                n)
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1)) →
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                (@has_mul.mul.{u} (free_comm_ring.{u} α)
                   (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   z
                   n))
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      { rintros _ ⟨z, hzs, rfl⟩ _ _, use 0, rw [lift_mul, lift_of, if_pos hzs, zero_mul], norm_cast },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='free_comm_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hzs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 66, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{1} β (@free_comm_ring.lift.{u 0} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{0} β (@mul_zero_class.to_has_mul.{0} β (@semiring.to_mul_zero_class.{0} β (@ring.to_semiring.{0} β (@comm_ring.to_ring.{0} β _inst_1)))) (@free_comm_ring.lift.{u 0} α β _inst_1 f x) (@free_comm_ring.lift.{u 0} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β] (f : α → β) (x : α), @eq.{1} β (@free_comm_ring.lift.{u 0} α β _inst_1 f (@free_comm_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type} {t e : α}, @eq.{1} α (@ite.{1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : mul_zero_class.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α _inst_1) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α _inst_1)) a) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize casts at the given locations by moving them &quot;upwards&quot;.
As opposed to simp, norm_cast can be used without necessarily
closing the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                n)
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1)) →
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                (@has_mul.mul.{u} (free_comm_ring.{u} α)
                   (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   z
                   n))
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1))

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                n)
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1)) →
      @Exists.{1} int
        (λ (n_1 : int),
           @eq.{1} (@polynomial.{0} int int.comm_semiring)
             (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring)
                (λ (a : α),
                   @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                     (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                     (@polynomial.{0} int int.comm_semiring)
                     (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                        (@polynomial.has_zero.{0} int int.comm_semiring))
                     (@polynomial.X.{0} int int.comm_semiring))
                (@has_mul.mul.{u} (free_comm_ring.{u} α)
                   (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   z
                   n))
             (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                   (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                      (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                         (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                            (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                               (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                     (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                        (@polynomial.integral_domain.{0} int
                                           (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                         (@polynomial.has_zero.{0} int int.comm_semiring)
                         (@polynomial.has_one.{0} int int.comm_semiring)
                         (@polynomial.has_add.{0} int int.comm_semiring))))
                n_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
a :
  @Exists.{1} int
    (λ (n_1 : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            n)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n_1)),
z : α,
hzs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s
⊢ @Exists.{1} int
    (λ (n_1 : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_mul.mul.{u} (free_comm_ring.{u} α)
               (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                  (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                     (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                        (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
               (@free_comm_ring.of.{u} α z)
               n))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
a :
  @Exists.{1} int
    (λ (n_1 : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            n)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n_1)),
z : α,
hzs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@free_comm_ring.of.{u} α z)
          n))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
a :
  @Exists.{1} int
    (λ (n_1 : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            n)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n_1)),
z : α,
hzs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_mul.mul.{0} (@polynomial.{0} int int.comm_semiring)
       (@mul_zero_class.to_has_mul.{0} (@polynomial.{0} int int.comm_semiring)
          (@semiring.to_mul_zero_class.{0} (@polynomial.{0} int int.comm_semiring)
             (@ring.to_semiring.{0} (@polynomial.{0} int int.comm_semiring)
                (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                   (@polynomial.comm_ring.{0} int int.comm_ring)))))
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          (@free_comm_ring.of.{u} α z))
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          n))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
a :
  @Exists.{1} int
    (λ (n_1 : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            n)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n_1)),
z : α,
hzs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_mul.mul.{0} (@polynomial.{0} int int.comm_semiring)
       (@mul_zero_class.to_has_mul.{0} (@polynomial.{0} int int.comm_semiring)
          (@semiring.to_mul_zero_class.{0} (@polynomial.{0} int int.comm_semiring)
             (@ring.to_semiring.{0} (@polynomial.{0} int int.comm_semiring)
                (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                   (@polynomial.comm_ring.{0} int int.comm_ring)))))
       (@ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s)
          (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s))
          (@polynomial.{0} int int.comm_semiring)
          (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.has_zero.{0} int int.comm_semiring))
          (@polynomial.X.{0} int int.comm_semiring))
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          n))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
a :
  @Exists.{1} int
    (λ (n_1 : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            n)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n_1)),
z : α,
hzs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_mul.mul.{0} (@polynomial.{0} int int.comm_semiring)
       (@mul_zero_class.to_has_mul.{0} (@polynomial.{0} int int.comm_semiring)
          (@semiring.to_mul_zero_class.{0} (@polynomial.{0} int int.comm_semiring)
             (@ring.to_semiring.{0} (@polynomial.{0} int int.comm_semiring)
                (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                   (@polynomial.comm_ring.{0} int int.comm_ring)))))
       (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.has_zero.{0} int int.comm_semiring))
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          n))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
a :
  @Exists.{1} int
    (λ (n_1 : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            n)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n_1)),
z : α,
hzs : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) z s
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
       (@mul_zero_class.to_has_zero.{0} (@polynomial.{0} int int.comm_semiring)
          (@semiring.to_mul_zero_class.{0} (@polynomial.{0} int int.comm_semiring)
             (@ring.to_semiring.{0} (@polynomial.{0} int int.comm_semiring)
                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.integral_domain.{0} int
                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain))))))))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176      { rintros x y ⟨q, hq⟩ ⟨r, hr⟩, refine ⟨q+r, _⟩, rw [lift_add, hq, hr], norm_cast } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_cast.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{1} β (@free_comm_ring.lift.{u 0} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{0} β (@distrib.to_has_add.{0} β (@ring.to_distrib.{0} β (@comm_ring.to_ring.{0} β _inst_1))) (@free_comm_ring.lift.{u 0} α β _inst_1 f x) (@free_comm_ring.lift.{u 0} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (@polynomial.{0} int int.comm_semiring) (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring) (λ (a : α), @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)) (@polynomial.{0} int int.comm_semiring) (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.has_zero.{0} int int.comm_semiring)) (@polynomial.X.{0} int int.comm_semiring)) x) (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring) (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring) (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring) (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring) (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring) (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring) (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.integral_domain.{0} int (@euclidean_domain.integral_domain.{0} int int.euclidean_domain))))))) (@polynomial.has_zero.{0} int int.comm_semiring) (@polynomial.has_one.{0} int int.comm_semiring) (@polynomial.has_add.{0} int int.comm_semiring)))) q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (@polynomial.{0} int int.comm_semiring) (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring) (λ (a : α), @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)) (@polynomial.{0} int int.comm_semiring) (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.has_zero.{0} int int.comm_semiring)) (@polynomial.X.{0} int int.comm_semiring)) y) (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring) (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring) (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring) (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring) (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring) (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring) (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.integral_domain.{0} int (@euclidean_domain.integral_domain.{0} int int.euclidean_domain))))))) (@polynomial.has_zero.{0} int int.comm_semiring) (@polynomial.has_one.{0} int int.comm_semiring) (@polynomial.has_add.{0} int int.comm_semiring)))) r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Normalize casts at the given locations by moving them &quot;upwards&quot;.
As opposed to simp, norm_cast can be used without necessarily
closing the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              y)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n)) →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              (@has_add.add.{u} (free_comm_ring.{u} α)
                 (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                    (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                 x
                 y))
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
q : int,
hq :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       x)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       q),
r : int,
hr :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       y)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       r)
⊢ @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
q : int,
hq :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       x)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       q),
r : int,
hr :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       y)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       r)
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          x
          y))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_add.add.{0} int int.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
q : int,
hq :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       x)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       q),
r : int,
hr :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       y)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       r)
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_add.add.{0} (@polynomial.{0} int int.comm_semiring)
       (@distrib.to_has_add.{0} (@polynomial.{0} int int.comm_semiring)
          (@ring.to_distrib.{0} (@polynomial.{0} int int.comm_semiring)
             (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring))))
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          x)
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          y))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_add.add.{0} int int.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
q : int,
hq :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       x)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       q),
r : int,
hr :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       y)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       r)
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_add.add.{0} (@polynomial.{0} int int.comm_semiring)
       (@distrib.to_has_add.{0} (@polynomial.{0} int int.comm_semiring)
          (@ring.to_distrib.{0} (@polynomial.{0} int int.comm_semiring)
             (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring))))
       (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                      (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                            (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                               (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@polynomial.integral_domain.{0} int
                                     (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                   (@polynomial.has_zero.{0} int int.comm_semiring)
                   (@polynomial.has_one.{0} int int.comm_semiring)
                   (@polynomial.has_add.{0} int int.comm_semiring))))
          q)
       (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
          (@polynomial.comm_ring.{0} int int.comm_ring)
          (λ (a : α),
             @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
               (@polynomial.{0} int int.comm_semiring)
               (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                  (@polynomial.has_zero.{0} int int.comm_semiring))
               (@polynomial.X.{0} int int.comm_semiring))
          y))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_add.add.{0} int int.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
x : free_comm_ring.{u} α,
hx : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
q : int,
hq :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       x)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       q),
r : int,
hr :
  @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring)
       (λ (a : α),
          @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
       y)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       r)
⊢ @eq.{1} (@polynomial.{0} int int.comm_semiring)
    (@has_add.add.{0} (@polynomial.{0} int int.comm_semiring)
       (@distrib.to_has_add.{0} (@polynomial.{0} int int.comm_semiring)
          (@ring.to_distrib.{0} (@polynomial.{0} int int.comm_semiring)
             (@comm_ring.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                (@polynomial.comm_ring.{0} int int.comm_ring))))
       (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                      (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                            (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                               (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@polynomial.integral_domain.{0} int
                                     (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                   (@polynomial.has_zero.{0} int int.comm_semiring)
                   (@polynomial.has_one.{0} int int.comm_semiring)
                   (@polynomial.has_add.{0} int int.comm_semiring))))
          q)
       (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                      (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                            (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                               (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                  (@polynomial.integral_domain.{0} int
                                     (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                   (@polynomial.has_zero.{0} int int.comm_semiring)
                   (@polynomial.has_one.{0} int int.comm_semiring)
                   (@polynomial.has_add.{0} int int.comm_semiring))))
          r))
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       (@has_add.add.{0} int int.has_add q r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  ∀ (x : free_comm_ring.{u} α),
    @free_comm_ring.is_supported.{u} α x s →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    specialize this (of p) hps, rw [lift_of] at this, split_ifs at this, { exact h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hps'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1536, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : free_comm_ring.{u} α), @free_comm_ring.is_supported.{u} α x s → @Exists.{1} int (λ (n : int), @eq.{1} (@polynomial.{0} int int.comm_semiring) (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring) (@polynomial.comm_ring.{0} int int.comm_ring) (λ (a : α), @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)) (@polynomial.{0} int int.comm_semiring) (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.has_zero.{0} int int.comm_semiring)) (@polynomial.X.{0} int int.comm_semiring)) x) (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring) (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring) (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring) (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring) (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring) (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring) (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.integral_domain.{0} int (@euclidean_domain.integral_domain.{0} int int.euclidean_domain))))))) (@polynomial.has_zero.{0} int int.comm_semiring) (@polynomial.has_one.{0} int int.comm_semiring) (@polynomial.has_add.{0} int int.comm_semiring)))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : comm_ring.{0} β] (f : α → β) (x : α), @eq.{1} β (@free_comm_ring.lift.{u 0} α β _inst_1 f (@free_comm_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`. The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='specialize'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  ∀ (x : free_comm_ring.{u} α),
    @free_comm_ring.is_supported.{u} α x s →
    @Exists.{1} int
      (λ (n : int),
         @eq.{1} (@polynomial.{0} int int.comm_semiring)
           (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
              (@polynomial.comm_ring.{0} int int.comm_ring)
              (λ (a : α),
                 @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                   (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                   (@polynomial.{0} int int.comm_semiring)
                   (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                      (@polynomial.has_zero.{0} int int.comm_semiring))
                   (@polynomial.X.{0} int int.comm_semiring))
              x)
           (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
              (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
                 (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                    (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                       (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                          (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                             (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                                (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                   (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                      (@polynomial.integral_domain.{0} int
                                         (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                       (@polynomial.has_zero.{0} int int.comm_semiring)
                       (@polynomial.has_one.{0} int int.comm_semiring)
                       (@polynomial.has_add.{0} int int.comm_semiring))))
              n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@free_comm_ring.of.{u} α p))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@free_comm_ring.lift.{u 0} α (@polynomial.{0} int int.comm_semiring)
            (@polynomial.comm_ring.{0} int int.comm_ring)
            (λ (a : α),
               @ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
                 (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))
                 (@polynomial.{0} int int.comm_semiring)
                 (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
                    (@polynomial.has_zero.{0} int int.comm_semiring))
                 (@polynomial.X.{0} int int.comm_semiring))
            (@free_comm_ring.of.{u} α p))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@ite.{1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s)
            (_inst (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s))
            (@polynomial.{0} int int.comm_semiring)
            (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring)
               (@polynomial.has_zero.{0} int int.comm_semiring))
            (@polynomial.X.{0} int int.comm_semiring))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s,
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.has_zero.{0} int int.comm_semiring))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s,
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring)
         (@has_zero.zero.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.has_zero.{0} int int.comm_semiring))
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    exfalso, apply ne.symm int.zero_ne_one,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int.zero_ne_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1026, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 561, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a b : α}, @ne.{1} α a b → @ne.{1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} int (@has_zero.zero.{0} int int.has_zero) (@has_one.one.{0} int int.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Replaces the target of the main goal by `false`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exfalso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    rcases this with ⟨w, H⟩, rw polynomial.int_cast_eq_C at H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='polynomial.int_cast_eq_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 1293, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} int (λ (n : int), @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring) (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring) (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring) (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring) (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring) (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring) (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring) (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring) (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring) (@polynomial.integral_domain.{0} int (@euclidean_domain.integral_domain.{0} int int.euclidean_domain))))))) (@polynomial.has_zero.{0} int int.comm_semiring) (@polynomial.has_one.{0} int int.comm_semiring) (@polynomial.has_add.{0} int int.comm_semiring)))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : comm_ring.{0} α] (n : int), @eq.{1} (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@coe.{1 1} int (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@coe_to_lift.{1 1} int (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@coe_base.{1 1} int (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@int.cast_coe.{0} (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@add_group.to_has_neg.{0} (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@add_comm_group.to_add_group.{0} (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@ring.to_add_comm_group.{0} (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@comm_ring.to_ring.{0} (@polynomial.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@polynomial.comm_ring.{0} α _inst_1))))) (@polynomial.has_zero.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@polynomial.has_one.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@polynomial.has_add.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1))))) n) (@polynomial.C.{0} α (@comm_ring.to_comm_semiring.{0} α _inst_1) (@coe.{1 1} int α (@coe_to_lift.{1 1} int α (@coe_base.{1 1} int α (@int.cast_coe.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@comm_ring.to_ring.{0} α _inst_1)))) (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α (@comm_ring.to_ring.{0} α _inst_1)))) (@monoid.to_has_one.{0} α (@ring.to_monoid.{0} α (@comm_ring.to_ring.{0} α _inst_1))) (@distrib.to_has_add.{0} α (@ring.to_distrib.{0} α (@comm_ring.to_ring.{0} α _inst_1)))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
this :
  @Exists.{1} int
    (λ (n : int),
       @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
         (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
            (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
               (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
                  (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                     (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                        (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                           (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                              (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                                 (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                                    (@polynomial.integral_domain.{0} int
                                       (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                     (@polynomial.has_zero.{0} int int.comm_semiring)
                     (@polynomial.has_one.{0} int int.comm_semiring)
                     (@polynomial.has_add.{0} int int.comm_semiring))))
            n))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@coe.{1 1} int (@polynomial.{0} int int.comm_semiring)
       (@coe_to_lift.{1 1} int (@polynomial.{0} int int.comm_semiring)
          (@coe_base.{1 1} int (@polynomial.{0} int int.comm_semiring)
             (@int.cast_coe.{0} (@polynomial.{0} int int.comm_semiring)
                (@add_group.to_has_neg.{0} (@polynomial.{0} int int.comm_semiring)
                   (@add_comm_group.to_add_group.{0} (@polynomial.{0} int int.comm_semiring)
                      (@ring.to_add_comm_group.{0} (@polynomial.{0} int int.comm_semiring)
                         (@domain.to_ring.{0} (@polynomial.{0} int int.comm_semiring)
                            (@integral_domain.to_domain.{0} (@polynomial.{0} int int.comm_semiring)
                               (@polynomial.integral_domain.{0} int
                                  (@euclidean_domain.integral_domain.{0} int int.euclidean_domain)))))))
                (@polynomial.has_zero.{0} int int.comm_semiring)
                (@polynomial.has_one.{0} int int.comm_semiring)
                (@polynomial.has_add.{0} int int.comm_semiring))))
       w)
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    have : polynomial.X.coeff 1 = (polynomial.C ↑w).coeff 1, by rw H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='polynomial.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='polynomial.C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : comm_semiring.{0} α], @polynomial.{0} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : comm_semiring.{0} α], α → @polynomial.{0} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring) (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring) (@coe.{1 1} int int (@coe_to_lift.{1 1} int int (@coe_base.{1 1} int int (@int.cast_coe.{0} int (@add_group.to_has_neg.{0} int (@add_comm_group.to_add_group.{0} int (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))) (@mul_zero_class.to_has_zero.{0} int (@semiring.to_mul_zero_class.{0} int (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))) (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))) (@distrib.to_has_add.{0} int (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))))) w))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`X` is the polynomial variable (aka indeterminant).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`C a` is the constant polynomial `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w))
⊢ @eq.{?l_1+1} ?m_2
    (@polynomial.coeff.{?l_1} ?m_2 ?m_3 (@polynomial.X.{?l_1} ?m_2 ?m_3) (@has_one.one.{0} nat nat.has_one))
    (@polynomial.coeff.{?l_1} ?m_2 ?m_4 (@polynomial.C.{?l_1} ?m_2 ?m_4 (@coe.{1 ?l_1+1} int ?m_2 ?m_5 w))
       (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@polynomial.coeff.{0} int int.comm_semiring
       (@polynomial.C.{0} int int.comm_semiring
          (@coe.{1 1} int int
             (@coe_to_lift.{1 1} int int
                (@coe_base.{1 1} int int
                   (@int.cast_coe.{0} int
                      (@add_group.to_has_neg.{0} int
                         (@add_comm_group.to_add_group.{0} int
                            (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                      (@mul_zero_class.to_has_zero.{0} int
                         (@semiring.to_mul_zero_class.{0} int
                            (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                      (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                      (@distrib.to_has_add.{0} int
                         (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
             w))
       (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181    rwa [polynomial.coeff_C, if_neg one_ne_zero, polynomial.coeff_X, if_pos rfl] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='polynomial.coeff_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='one_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='polynomial.coeff_X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 146, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α} {n : nat} [_inst_1 : comm_semiring.{0} α], @eq.{1} α (@polynomial.coeff.{0} α _inst_1 (@polynomial.C.{0} α _inst_1 a) n) (@ite.{1} (@eq.{1} nat n (@has_zero.zero.{0} nat nat.has_zero)) (nat.decidable_eq n (@has_zero.zero.{0} nat nat.has_zero)) α a (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@comm_semiring.to_semiring.{0} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type} {t e : α}, @eq.{1} α (@ite.{1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [s : zero_ne_one_class.{0} α], @ne.{1} α (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α s)) (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {n : nat} [_inst_1 : comm_semiring.{0} α], @eq.{1} α (@polynomial.coeff.{0} α _inst_1 (@polynomial.X.{0} α _inst_1) n) (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) n) (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) n) α (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1)))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@comm_semiring.to_semiring.{0} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type} {t e : α}, @eq.{1} α (@ite.{1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@polynomial.coeff.{0} int int.comm_semiring
       (@polynomial.C.{0} int int.comm_semiring
          (@coe.{1 1} int int
             (@coe_to_lift.{1 1} int int
                (@coe_base.{1 1} int int
                   (@int.cast_coe.{0} int
                      (@add_group.to_has_neg.{0} int
                         (@add_comm_group.to_add_group.{0} int
                            (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                      (@mul_zero_class.to_has_zero.{0} int
                         (@semiring.to_mul_zero_class.{0} int
                            (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                      (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                      (@distrib.to_has_add.{0} int
                         (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
             w))
       (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       int
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)
       (@has_zero.zero.{0} int
          (@mul_zero_class.to_has_zero.{0} int
             (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@has_zero.zero.{0} int
       (@mul_zero_class.to_has_zero.{0} int
          (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       int
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)
       (@has_zero.zero.{0} int
          (@mul_zero_class.to_has_zero.{0} int
             (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))
⊢ zero_ne_one_class.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) (@has_one.one.{0} nat nat.has_one))
       (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) (@has_one.one.{0} nat nat.has_one))
       int
       (@has_one.one.{0} int
          (@monoid.to_has_one.{0} int
             (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))
       (@has_zero.zero.{0} int
          (@mul_zero_class.to_has_zero.{0} int
             (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))
    (@has_zero.zero.{0} int
       (@mul_zero_class.to_has_zero.{0} int
          (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       int
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)
       (@has_zero.zero.{0} int
          (@mul_zero_class.to_has_zero.{0} int
             (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))
⊢ zero_ne_one_class.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@has_one.one.{0} int
       (@monoid.to_has_one.{0} int
          (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))
    (@has_zero.zero.{0} int
       (@mul_zero_class.to_has_zero.{0} int
          (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)

α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       int
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)
       (@has_zero.zero.{0} int
          (@mul_zero_class.to_has_zero.{0} int
             (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))
⊢ zero_ne_one_class.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@polynomial.coeff.{0} int int.comm_semiring
       (@polynomial.C.{0} int int.comm_semiring
          (@coe.{1 1} int int
             (@coe_to_lift.{1 1} int int
                (@coe_base.{1 1} int int
                   (@int.cast_coe.{0} int
                      (@add_group.to_has_neg.{0} int
                         (@add_comm_group.to_add_group.{0} int
                            (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                      (@mul_zero_class.to_has_zero.{0} int
                         (@semiring.to_mul_zero_class.{0} int
                            (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                      (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                      (@distrib.to_has_add.{0} int
                         (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
             w))
       (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{1} int (@has_one.one.{0} int int.has_one) (@has_zero.zero.{0} int int.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       int
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)
       (@has_zero.zero.{0} int
          (@mul_zero_class.to_has_zero.{0} int
             (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))
⊢ zero_ne_one_class.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    apply_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
p : α,
s : set.{u} α,
hps : @free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s,
_inst : Π (a : Prop), decidable a,
h : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
w : int,
H :
  @eq.{1} (@polynomial.{0} int int.comm_semiring) (@polynomial.X.{0} int int.comm_semiring)
    (@polynomial.C.{0} int (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)),
this :
  @eq.{1} int
    (@polynomial.coeff.{0} int int.comm_semiring (@polynomial.X.{0} int int.comm_semiring)
       (@has_one.one.{0} nat nat.has_one))
    (@ite.{1} (@eq.{1} nat (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       (nat.decidable_eq (@has_one.one.{0} nat nat.has_one) (@has_zero.zero.{0} nat nat.has_zero))
       int
       (@coe.{1 1} int int
          (@coe_to_lift.{1 1} int int
             (@coe_base.{1 1} int int
                (@int.cast_coe.{0} int
                   (@add_group.to_has_neg.{0} int
                      (@add_comm_group.to_add_group.{0} int
                         (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@mul_zero_class.to_has_zero.{0} int
                      (@semiring.to_mul_zero_class.{0} int
                         (@ring.to_semiring.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                   (@monoid.to_has_one.{0} int (@ring.to_monoid.{0} int (@comm_ring.to_ring.{0} int int.comm_ring)))
                   (@distrib.to_has_add.{0} int
                      (@ring.to_distrib.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))))
          w)
       (@has_zero.zero.{0} int
          (@mul_zero_class.to_has_zero.{0} int
             (@semiring.to_mul_zero_class.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))
⊢ zero_ne_one_class.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  theorem map_subtype_val_restriction {x} (s : set α) [decidable_pred s] (hxs : is_supported x s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186    map subtype.val (restriction s x) = x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.restriction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → free_comm_ring.{u} α → free_comm_ring.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u} {p : α → Prop}, @subtype.{u} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], free_comm_ring.{u} α → free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    refine ring.in_closure.rec_on hxs _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ring.in_closure.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/subring.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u} [_inst_1 : ring.{u} R] {s : set.{u} R} {C : R → Prop} {x : R}, @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) x (@ring.closure.{u} R _inst_1 s) → C (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1))) → C (@has_neg.neg.{u} R (@add_group.to_has_neg.{u} R (@add_comm_group.to_add_group.{u} R (@ring.to_add_comm_group.{u} R _inst_1))) (@has_one.one.{u} R (@monoid.to_has_one.{u} R (@ring.to_monoid.{u} R _inst_1)))) → (∀ (z : R), @has_mem.mem.{u u} R (set.{u} R) (@set.has_mem.{u} R) z s → ∀ (n : R), C n → C (@has_mul.mul.{u} R (@mul_zero_class.to_has_mul.{u} R (@semiring.to_mul_zero_class.{u} R (@ring.to_semiring.{u} R _inst_1))) z n)) → (∀ {x y : R}, C x → C y → C (@has_add.add.{u} R (@distrib.to_has_add.{u} R (@ring.to_distrib.{u} R _inst_1)) x y)) → C x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@has_one.one.{u} (free_comm_ring.{u} α)
       (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
          (@ring.to_monoid.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_neg.neg.{u} (free_comm_ring.{u} α)
             (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                   (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@has_one.one.{u} (free_comm_ring.{u} α)
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
        n →
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
              (@has_mul.mul.{u} (free_comm_ring.{u} α)
                 (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                    (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                       (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                 z
                 n)))
        (@has_mul.mul.{u} (free_comm_ring.{u} α)
           (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
              (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                 (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
           z
           n)

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    { rw restriction_one, refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_comm_ring.restriction_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 159, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], @eq.{u+1} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@monoid.to_has_one.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@ring.to_monoid.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@comm_ring.to_ring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (free_comm_ring.comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@has_one.one.{u} (free_comm_ring.{u} α)
       (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
          (@ring.to_monoid.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_neg.neg.{u} (free_comm_ring.{u} α)
             (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                   (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@has_one.one.{u} (free_comm_ring.{u} α)
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
        n →
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
              (@has_mul.mul.{u} (free_comm_ring.{u} α)
                 (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                    (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                       (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                 z
                 n)))
        (@has_mul.mul.{u} (free_comm_ring.{u} α)
           (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
              (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                 (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
           z
           n)

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@has_one.one.{u} (free_comm_ring.{u} α)
       (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
          (@ring.to_monoid.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@has_one.one.{u}
          (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
          (@monoid.to_has_one.{u}
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (@ring.to_monoid.{u}
                (free_comm_ring.{u}
                   (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                (@comm_ring.to_ring.{u}
                   (free_comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                   (free_comm_ring.comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)))))))
    (@has_one.one.{u} (free_comm_ring.{u} α)
       (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
          (@ring.to_monoid.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_neg.neg.{u} (free_comm_ring.{u} α)
             (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                   (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@has_one.one.{u} (free_comm_ring.{u} α)
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
        n →
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
              (@has_mul.mul.{u} (free_comm_ring.{u} α)
                 (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                    (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                       (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                 z
                 n)))
        (@has_mul.mul.{u} (free_comm_ring.{u} α)
           (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
              (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                 (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
           z
           n)

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    { rw [restriction_neg, map_neg, restriction_one], refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_comm_ring.restriction_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.map_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.restriction_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 161, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 108, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 159, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s] (x : free_comm_ring.{u} α), @eq.{u+1} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@add_group.to_has_neg.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@comm_ring.to_ring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (free_comm_ring.comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)))))) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : free_comm_ring.{u} α), @eq.{u+1} (free_comm_ring.{u} β) (@free_comm_ring.map.{u u} α β f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{u} (free_comm_ring.{u} β) (@add_group.to_has_neg.{u} (free_comm_ring.{u} β) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} β) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} β) (@comm_ring.to_ring.{u} (free_comm_ring.{u} β) (free_comm_ring.comm_ring.{u} β))))) (@free_comm_ring.map.{u u} α β f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s], @eq.{u+1} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@monoid.to_has_one.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@ring.to_monoid.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@comm_ring.to_ring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (free_comm_ring.comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_neg.neg.{u} (free_comm_ring.{u} α)
             (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                   (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@has_one.one.{u} (free_comm_ring.{u} α)
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
        n →
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
              (@has_mul.mul.{u} (free_comm_ring.{u} α)
                 (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                    (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                       (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                 z
                 n)))
        (@has_mul.mul.{u} (free_comm_ring.{u} α)
           (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
              (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                 (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
           z
           n)

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_neg.neg.{u} (free_comm_ring.{u} α)
             (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                   (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@has_one.one.{u} (free_comm_ring.{u} α)
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@has_neg.neg.{u}
          (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
          (@add_group.to_has_neg.{u}
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (@add_comm_group.to_add_group.{u}
                (free_comm_ring.{u}
                   (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                (@ring.to_add_comm_group.{u}
                   (free_comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                   (@comm_ring.to_ring.{u}
                      (free_comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                      (free_comm_ring.comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
             (@has_one.one.{u} (free_comm_ring.{u} α)
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
             (@has_one.one.{u} (free_comm_ring.{u} α)
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@has_one.one.{u}
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (@monoid.to_has_one.{u}
                (free_comm_ring.{u}
                   (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                (@ring.to_monoid.{u}
                   (free_comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                   (@comm_ring.to_ring.{u}
                      (free_comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                      (free_comm_ring.comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
        n →
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
              (@has_mul.mul.{u} (free_comm_ring.{u} α)
                 (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                    (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                       (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                 z
                 n)))
        (@has_mul.mul.{u} (free_comm_ring.{u} α)
           (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
              (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                 (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
           z
           n)

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    { rintros _ ⟨p, hps, rfl⟩ n ih, rw [restriction_mul, restriction_of, dif_pos hps, map_mul, map_of, ih] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='free_comm_ring.restriction_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.restriction_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dif_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hps'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.map_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 157, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 928, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s] (x y : free_comm_ring.{u} α), @eq.{u+1} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@ring.to_semiring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@comm_ring.to_ring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (free_comm_ring.comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)))))) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s] (p : α), @eq.{u+1} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) (@free_comm_ring.of.{u} α p)) (@dite.{u+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s) (@set.decidable_mem.{u} α s (λ (a : α), _inst_1 a) p) (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (λ (H : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s), @free_comm_ring.of.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s) (@subtype.mk.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) p H)) (λ (H : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s)), @has_zero.zero.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@ring.to_semiring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@comm_ring.to_ring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (free_comm_ring.comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hc : c) {α : Type u} {t : c → α} {e : not c → α}, @eq.{u+1} α (@dite.{u+1} c h α t e) (t hc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} (free_comm_ring.{u} β) (@free_comm_ring.map.{u u} α β f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{u} (free_comm_ring.{u} β) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} β) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} β) (@ring.to_semiring.{u} (free_comm_ring.{u} β) (@comm_ring.to_ring.{u} (free_comm_ring.{u} β) (free_comm_ring.comm_ring.{u} β))))) (@free_comm_ring.map.{u u} α β f x) (@free_comm_ring.map.{u u} α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x : α), @eq.{u+1} (free_comm_ring.{u} β) (@free_comm_ring.map.{u u} α β f (@free_comm_ring.of.{u} α x)) (@free_comm_ring.of.{u} β (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_comm_ring.{u} α) (@free_comm_ring.map.{u u} (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)) α (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
        n →
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
              (@has_mul.mul.{u} (free_comm_ring.{u} α)
                 (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                    (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                       (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                 z
                 n)))
        (@has_mul.mul.{u} (free_comm_ring.{u} α)
           (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
              (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                 (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
           z
           n)

α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ (z : free_comm_ring.{u} α),
    @has_mem.mem.{u u} (free_comm_ring.{u} α) (set.{u} (free_comm_ring.{u} α))
      (@set.has_mem.{u} (free_comm_ring.{u} α))
      z
      (@set.image.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) s) →
    ∀ (n : free_comm_ring.{u} α),
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
        n →
      @eq.{u+1} (free_comm_ring.{u} α)
        (@free_comm_ring.map.{u u}
           (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           α
           (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
           (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
              (@has_mul.mul.{u} (free_comm_ring.{u} α)
                 (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                    (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                       (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                 z
                 n)))
        (@has_mul.mul.{u} (free_comm_ring.{u} α)
           (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
              (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                 (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
           z
           n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
    n,
p : α,
hps : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@free_comm_ring.of.{u} α p)
             n)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α p)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
    n,
p : α,
hps : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@has_mul.mul.{u}
          (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
          (@mul_zero_class.to_has_mul.{u}
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (@semiring.to_mul_zero_class.{u}
                (free_comm_ring.{u}
                   (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                (@ring.to_semiring.{u}
                   (free_comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                   (@comm_ring.to_ring.{u}
                      (free_comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                      (free_comm_ring.comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) (@free_comm_ring.of.{u} α p))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α p)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
    n,
p : α,
hps : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@has_mul.mul.{u}
          (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
          (@mul_zero_class.to_has_mul.{u}
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (@semiring.to_mul_zero_class.{u}
                (free_comm_ring.{u}
                   (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                (@ring.to_semiring.{u}
                   (free_comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                   (@comm_ring.to_ring.{u}
                      (free_comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                      (free_comm_ring.comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))
          (@dite.{u+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s)
             (@set.decidable_mem.{u} α s (λ (a : α), _inst_1 a) p)
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (λ (H : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s),
                @free_comm_ring.of.{u}
                  (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)
                  (@subtype.mk.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) p
                     H))
             (λ (H : not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s)),
                @has_zero.zero.{u}
                  (free_comm_ring.{u}
                     (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                  (@mul_zero_class.to_has_zero.{u}
                     (free_comm_ring.{u}
                        (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                     (@semiring.to_mul_zero_class.{u}
                        (free_comm_ring.{u}
                           (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                        (@ring.to_semiring.{u}
                           (free_comm_ring.{u}
                              (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                           (@comm_ring.to_ring.{u}
                              (free_comm_ring.{u}
                                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α)
                                    s))
                              (free_comm_ring.comm_ring.{u}
                                 (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α)
                                    s))))))))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α p)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
    n,
p : α,
hps : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@has_mul.mul.{u}
          (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
          (@mul_zero_class.to_has_mul.{u}
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (@semiring.to_mul_zero_class.{u}
                (free_comm_ring.{u}
                   (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                (@ring.to_semiring.{u}
                   (free_comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                   (@comm_ring.to_ring.{u}
                      (free_comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                      (free_comm_ring.comm_ring.{u}
                         (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))))
          (@free_comm_ring.of.{u}
             (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)
             (@subtype.mk.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) p hps))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α p)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
    n,
p : α,
hps : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@free_comm_ring.of.{u}
             (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)
             (@subtype.mk.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) p hps)))
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α p)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
    n,
p : α,
hps : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)
             (@subtype.mk.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) p hps)))
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α p)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
n : free_comm_ring.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) n))
    n,
p : α,
hps : @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@free_comm_ring.of.{u} α p)
             n)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α p)
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192    { intros x y ihx ihy, rw [restriction_add, map_add, ihx, ihy] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='free_comm_ring.restriction_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 160, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 107, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α) [_inst_1 : @decidable_pred.{u+1} α s] (x y : free_comm_ring.{u} α), @eq.{u+1} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@distrib.to_has_add.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@ring.to_distrib.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (@comm_ring.to_ring.{u} (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)) (free_comm_ring.comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))))) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} (free_comm_ring.{u} β) (@free_comm_ring.map.{u u} α β f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{u} (free_comm_ring.{u} β) (@distrib.to_has_add.{u} (free_comm_ring.{u} β) (@ring.to_distrib.{u} (free_comm_ring.{u} β) (@comm_ring.to_ring.{u} (free_comm_ring.{u} β) (free_comm_ring.comm_ring.{u} β)))) (@free_comm_ring.map.{u u} α β f x) (@free_comm_ring.map.{u u} α β f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_comm_ring.{u} α) (@free_comm_ring.map.{u u} (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)) α (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_comm_ring.{u} α) (@free_comm_ring.map.{u u} (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)) α (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)) (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y)) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ ∀ {x y : free_comm_ring.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@free_comm_ring.map.{u u}
         (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         α
         (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
         (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
            (@has_add.add.{u} (free_comm_ring.{u} α)
               (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                  (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
               x
               y)))
      (@has_add.add.{u} (free_comm_ring.{u} α)
         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
ihx :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
    x,
ihy :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
    y
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_add.add.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y)))
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
ihx :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
    x,
ihy :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
    y
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@has_add.add.{u}
          (free_comm_ring.{u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
          (@distrib.to_has_add.{u}
             (free_comm_ring.{u}
                (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
             (@ring.to_distrib.{u}
                (free_comm_ring.{u}
                   (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                (@comm_ring.to_ring.{u}
                   (free_comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s))
                   (free_comm_ring.comm_ring.{u}
                      (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s)))))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x)
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y)))
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
ihx :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
    x,
ihy :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
    y
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y)))
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
ihx :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
    x,
ihy :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
    y
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       x
       (@free_comm_ring.map.{u u}
          (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          α
          (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
          (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y)))
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
s : set.{u} α,
_inst_1 : @decidable_pred.{u+1} α s,
hxs : @free_comm_ring.is_supported.{u} α x s,
x y : free_comm_ring.{u} α,
ihx :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) x))
    x,
ihy :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a) y))
    y
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_comm_ring.map.{u u}
       (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       α
       (@subtype.val.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s))
       (@free_comm_ring.restriction.{u} α s (λ (a : α), _inst_1 a)
          (@has_add.add.{u} (free_comm_ring.{u} α)
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             x
             y)))
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  theorem exists_finite_support (x : free_comm_ring α) : ∃ s : set α, set.finite s ∧ is_supported x s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='A set is finite if the subtype is a fintype, i.e. there is a
 list that enumerates its members.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  free_comm_ring.induction_on x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_comm_ring.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 30, &#x27;column&#x27;: 38}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_comm_ring.{u} α → Prop} (z : free_comm_ring.{u} α), C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) → (∀ (b : α), C (@free_comm_ring.of.{u} α b)) → (∀ (x y : free_comm_ring.{u} α), C x → C y → C (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) → (∀ (x y : free_comm_ring.{u} α), C x → C y → C (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197    ⟨∅, set.finite_empty, is_supported_neg is_supported_one⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.finite_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.is_supported_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.is_supported_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 77, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u}, @set.finite.{u} α (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {x : free_comm_ring.{u} α} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @free_comm_ring.is_supported.{u} α (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198    (λ p, ⟨{p}, set.finite_singleton p, is_supported_of.2 $ finset.mem_singleton_self _⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.finite_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.is_supported_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.mem_singleton_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 159, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 166, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} (a : α), @set.finite.{u} α (@singleton.{u u} α (set.{u} α) (@set.has_emptyc.{u} α) (@set.has_insert.{u} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : α} {s : set.{u} α}, iff (@free_comm_ring.is_supported.{u} α (@free_comm_ring.of.{u} α p) s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) p s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@finset.singleton.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199    (λ x y ⟨s, hfs, hxs⟩ ⟨t, hft, hxt⟩, ⟨s ∪ t, set.finite_union hfs hft, is_supported_add</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hfs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hft'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.finite_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring.is_supported_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@set.finite.{u} α s) (@free_comm_ring.is_supported.{u} α x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.finite.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@set.finite.{u} α s) (@free_comm_ring.is_supported.{u} α y s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.finite.{u} α t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α y t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, @set.finite.{u} α s → @set.finite.{u} α t → @set.finite.{u} α (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} {x y : free_comm_ring.{u} α} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @free_comm_ring.is_supported.{u} α y s → @free_comm_ring.is_supported.{u} α (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200      (is_supported_upwards hxs $ set.subset_union_left s t)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_comm_ring.is_supported_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.subset_union_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 119, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {x : free_comm_ring.{u} α} {s t : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @free_comm_ring.is_supported.{u} α x t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201      (is_supported_upwards hxt $ set.subset_union_right s t)⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_comm_ring.is_supported_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.subset_union_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 119, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {x : free_comm_ring.{u} α} {s t : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @free_comm_ring.is_supported.{u} α x t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    (λ x y ⟨s, hfs, hxs⟩ ⟨t, hft, hxt⟩, ⟨s ∪ t, set.finite_union hfs hft, is_supported_mul</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hfs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hft'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hxt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.finite_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring.is_supported_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 135, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@set.finite.{u} α s) (@free_comm_ring.is_supported.{u} α x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.finite.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@set.finite.{u} α s) (@free_comm_ring.is_supported.{u} α y s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.finite.{u} α t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@free_comm_ring.is_supported.{u} α y t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, @set.finite.{u} α s → @set.finite.{u} α t → @set.finite.{u} α (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} {x y : free_comm_ring.{u} α} {s : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @free_comm_ring.is_supported.{u} α y s → @free_comm_ring.is_supported.{u} α (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203      (is_supported_upwards hxs $ set.subset_union_left s t)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_comm_ring.is_supported_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.subset_union_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 119, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {x : free_comm_ring.{u} α} {s t : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @free_comm_ring.is_supported.{u} α x t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204      (is_supported_upwards hxt $ set.subset_union_right s t)⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_comm_ring.is_supported_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.subset_union_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 119, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {x : free_comm_ring.{u} α} {s t : set.{u} α}, @free_comm_ring.is_supported.{u} α x s → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @free_comm_ring.is_supported.{u} α x t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) t (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  theorem exists_finset_support (x : free_comm_ring α) : ∃ s : finset α, is_supported x ↑s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.is_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, free_comm_ring.{u} α → set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type u} {b : Type u} [_inst_1 : has_lift_t.{u+1 (max (u+1) 1)} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`finset α` is the type of finite sets of elements of `α`. It is implemented
 as a multiset (a list up to permutation) which has no duplicate elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  let ⟨s, hfs, hxs⟩ := exists_finite_support x in ⟨hfs.to_finset, by rwa finset.coe_to_finset⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hfs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring.exists_finite_support'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.finite.to_finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='finset.coe_to_finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 195, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 349, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@set.finite.{u} α s) (@free_comm_ring.is_supported.{u} α x s)) → @Exists.{u+1} (finset.{u} α) (λ (s : finset.{u} α), @free_comm_ring.is_supported.{u} α x (@coe.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α) (@lift_base.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α) (@finset.has_lift.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@set.finite.{u} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} (x : free_comm_ring.{u} α), @Exists.{(max (u+1) 1)} (set.{u} α) (λ (s : set.{u} α), and (@set.finite.{u} α s) (@free_comm_ring.is_supported.{u} α x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {s : set.{u} α}, @set.finite.{u} α s → finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} {hs : @set.finite.{u} α s}, @eq.{(max (u+1) 1)} (set.{u} α) (@coe.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α) (@lift_base.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α) (@finset.has_lift.{u} α)) (@set.finite.to_finset.{u} α s hs)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='Get a finset from a finite set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_let_match :
  @Exists.{(max (u+1) 1)} (set.{u} α)
    (λ (s : set.{u} α), and (@set.finite.{u} α s) (@free_comm_ring.is_supported.{u} α x s)) →
  @Exists.{u+1} (finset.{u} α)
    (λ (s : finset.{u} α),
       @free_comm_ring.is_supported.{u} α x
         (@coe.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α)
            (@lift_base.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α) (@finset.has_lift.{u} α))
            s)),
s : set.{u} α,
hfs : @set.finite.{u} α s,
hxs : @free_comm_ring.is_supported.{u} α x s
⊢ @free_comm_ring.is_supported.{u} α x
    (@coe.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α)
       (@lift_base.{u+1 (max (u+1) 1)} (finset.{u} α) (set.{u} α) (@finset.has_lift.{u} α))
       (@set.finite.to_finset.{u} α s hfs))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  end free_comm_ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  namespace free_ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  open function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  variable (α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  def to_free_comm_ring {α} : free_ring α → free_comm_ring α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  free_ring.lift free_comm_ring.of</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{v} β], (α → β) → free_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  instance to_free_comm_ring.is_ring_hom : is_ring_hom (@to_free_comm_ring α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_ring.to_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 216, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, free_ring.{u_1} α → free_comm_ring.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  free_ring.is_ring_hom free_comm_ring.of</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 77, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{v} β] (f : α → β), @is_ring_hom.{u v} (free_ring.{u} α) β (free_ring.ring.{u} α) _inst_1 (@free_ring.lift.{u v} α β _inst_1 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  instance : has_coe (free_ring α) (free_comm_ring α) := ⟨to_free_comm_ring⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_ring.to_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 216, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort v → Sort (max 1 (imax u v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_1}, free_ring.{u_1} α → free_comm_ring.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  instance coe.is_ring_hom : is_ring_hom (coe : free_ring α → free_comm_ring α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  free_ring.to_free_comm_ring.is_ring_hom _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.to_free_comm_ring.is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 219, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type u), @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@free_ring.to_free_comm_ring.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  @[simp] protected lemma coe_zero : ↑(0 : free_ring α) = (0 : free_comm_ring α) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  @[simp] protected lemma coe_one : ↑(1 : free_ring α) = (1 : free_comm_ring α) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  variable {α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  @[simp] protected lemma coe_of (a : α) : ↑(free_ring.of a) = free_comm_ring.of a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  free_ring.lift_of _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_ring.lift.{u u} α β _inst_1 f (@free_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  @[simp] protected lemma coe_neg (x : free_ring α) : ↑(-x) = -(x : free_comm_ring α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  free_ring.lift_neg _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} β] (f : α → β) (x : free_ring.{u} α), @eq.{u+1} β (@free_ring.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_ring.{u} α) (@add_group.to_has_neg.{u} (free_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_ring.{u} α) (@ring.to_add_comm_group.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β (@ring.to_add_comm_group.{u} β _inst_1))) (@free_ring.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  @[simp] protected lemma coe_add (x y : free_ring α) : ↑(x + y) = (x : free_comm_ring α) + y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  free_ring.lift_add _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} β] (f : α → β) (x y : free_ring.{u} α), @eq.{u+1} β (@free_ring.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_ring.{u} α) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) x y)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@ring.to_distrib.{u} β _inst_1)) (@free_ring.lift.{u u} α β _inst_1 f x) (@free_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  @[simp] protected lemma coe_sub (x y : free_ring α) : ↑(x - y) = (x : free_comm_ring α) - y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  free_ring.lift_sub _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.lift_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} β] (f : α → β) (x y : free_ring.{u} α), @eq.{u+1} β (@free_ring.lift.{u u} α β _inst_1 f (@has_sub.sub.{u} (free_ring.{u} α) (@add_group_has_sub.{u} (free_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_ring.{u} α) (@ring.to_add_comm_group.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) x y)) (@has_sub.sub.{u} β (@add_group_has_sub.{u} β (@add_comm_group.to_add_group.{u} β (@ring.to_add_comm_group.{u} β _inst_1))) (@free_ring.lift.{u u} α β _inst_1 f x) (@free_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  @[simp] protected lemma coe_mul (x y : free_ring α) : ↑(x * y) = (x : free_comm_ring α) * y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  free_ring.lift_mul _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='free_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} β] (f : α → β) (x y : free_ring.{u} α), @eq.{u+1} β (@free_ring.lift.{u u} α β _inst_1 f (@has_mul.mul.{u} (free_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) x y)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1))) (@free_ring.lift.{u u} α β _inst_1 f x) (@free_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  variable (α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  protected lemma coe_surjective : surjective (coe : free_ring α → free_comm_ring α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='function.surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  λ x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    apply free_comm_ring.induction_on x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_comm_ring.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 30, &#x27;column&#x27;: 38}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_comm_ring.{u} α → Prop} (z : free_comm_ring.{u} α), C (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) → (∀ (b : α), C (@free_comm_ring.of.{u} α b)) → (∀ (x y : free_comm_ring.{u} α), C x → C y → C (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) → (∀ (x y : free_comm_ring.{u} α), C x → C y → C (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
x : free_comm_ring.{u} α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         (@has_neg.neg.{u} (free_comm_ring.{u} α)
            (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            (@has_one.one.{u} (free_comm_ring.{u} α)
               (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                  (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (b : α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@free_comm_ring.of.{u} α b))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_add.add.{u} (free_comm_ring.{u} α)
              (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                 (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
              x
              y))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249    { use -1, refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [c : has_neg.{?l_1} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
x : free_comm_ring.{u} α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         (@has_neg.neg.{u} (free_comm_ring.{u} α)
            (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            (@has_one.one.{u} (free_comm_ring.{u} α)
               (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                  (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (b : α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@free_comm_ring.of.{u} α b))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_add.add.{u} (free_comm_ring.{u} α)
              (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                 (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
              x
              y))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         (@has_neg.neg.{u} (free_comm_ring.{u} α)
            (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            (@has_one.one.{u} (free_comm_ring.{u} α)
               (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                  (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       (@has_neg.neg.{u} (free_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
          (@has_one.one.{u} (free_ring.{u} α)
             (@monoid.to_has_one.{u} (free_ring.{u} α)
                (@ring.to_monoid.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))))
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_one.one.{u} (free_comm_ring.{u} α)
          (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
             (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (b : α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@free_comm_ring.of.{u} α b))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_add.add.{u} (free_comm_ring.{u} α)
              (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                 (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
              x
              y))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250    { intro x, use free_ring.of x, refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='free_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (b : α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@free_comm_ring.of.{u} α b))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_add.add.{u} (free_comm_ring.{u} α)
              (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                 (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
              x
              y))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (b : α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@free_comm_ring.of.{u} α b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
x : α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         (@free_comm_ring.of.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
x : α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       (@free_ring.of.{u} α x))
    (@free_comm_ring.of.{u} α x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_add.add.{u} (free_comm_ring.{u} α)
              (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                 (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
              x
              y))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    { rintros _ _ ⟨x, rfl⟩ ⟨y, rfl⟩, use x + y, exact free_ring.lift_add _ _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} β] (f : α → β) (x y : free_ring.{u} α), @eq.{u+1} β (@free_ring.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_ring.{u} α) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) x y)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@ring.to_distrib.{u} β _inst_1)) (@free_ring.lift.{u u} α β _inst_1 f x) (@free_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_add.add.{u} (free_comm_ring.{u} α)
              (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                 (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
              x
              y))

α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_add.add.{u} (free_comm_ring.{u} α)
              (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                 (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
x y : free_ring.{u} α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         (@has_add.add.{u} (free_comm_ring.{u} α)
            (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
               (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
            (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                  (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
               x)
            (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                  (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       (@has_add.add.{u} (free_ring.{u} α)
          (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
          x
          y))
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
          x)
       (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    { rintros _ _ ⟨x, rfl⟩ ⟨y, rfl⟩, use x * y, exact free_ring.lift_mul _ _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} β] (f : α → β) (x y : free_ring.{u} α), @eq.{u+1} β (@free_ring.lift.{u u} α β _inst_1 f (@has_mul.mul.{u} (free_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) x y)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_1))) (@free_ring.lift.{u u} α β _inst_1 f x) (@free_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ ∀ (x y : free_comm_ring.{u} α),
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           x) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           y) →
    @Exists.{u+1} (free_ring.{u} α)
      (λ (a : free_ring.{u} α),
         @eq.{u+1} (free_comm_ring.{u} α)
           (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
              (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                 (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
              a)
           (@has_mul.mul.{u} (free_comm_ring.{u} α)
              (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                 (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
              x
              y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
x y : free_ring.{u} α
⊢ @Exists.{u+1} (free_ring.{u} α)
    (λ (a : free_ring.{u} α),
       @eq.{u+1} (free_comm_ring.{u} α)
         (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
            a)
         (@has_mul.mul.{u} (free_comm_ring.{u} α)
            (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
               (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                  (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
            (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                  (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
               x)
            (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
               (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
                  (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       (@has_mul.mul.{u} (free_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
          x
          y))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
          x)
       (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  lemma coe_eq :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256    (coe : free_ring α → free_comm_ring α) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257    @functor.map free_abelian_group _ _ _ (λ (l : list α), (l : multiset α)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type v} [c : functor.{u v} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='orange'><a title='`multiset α` is the quotient of `list α` by list permutation. The result
 is a type of finite sets with duplicates allowed.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u
⊢ @eq.{u+1} (free_ring.{u} α → free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α))))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (list.{u} α)
       (multiset.{u} α)
       (λ (l : list.{u} α),
          @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
            (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
            l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259    funext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u
⊢ @eq.{u+1} (free_ring.{u} α → free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α))))
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (list.{u} α)
       (multiset.{u} α)
       (λ (l : list.{u} α),
          @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
            (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
            l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       x)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (list.{u} α)
       (multiset.{u} α)
       (λ (l : list.{u} α),
          @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
            (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
            l)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260    apply @free_abelian_group.lift.ext _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_abelian_group.lift.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (g h : free_abelian_group.{u} α → β) [_inst_2 : @is_add_group_hom.{u u} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{u} β _inst_1) g] [_inst_3 : @is_add_group_hom.{u u} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{u} β _inst_1) h], (∀ (x : α), @eq.{u+1} β (g (@free_abelian_group.of.{u} α x)) (h (@free_abelian_group.of.{u} α x))) → ∀ {x : free_abelian_group.{u} α}, @eq.{u+1} β (g x) (h x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       x)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (list.{u} α)
       (multiset.{u} α)
       (λ (l : list.{u} α),
          @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
            (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
            l)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261      (coe : free_ring α → free_comm_ring α) _ _ (free_abelian_group.lift.is_add_group_hom _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='free_abelian_group.lift.is_add_group_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β), @is_add_group_hom.{u u} (free_abelian_group.{u} α) β (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α)) (@add_comm_group.to_add_group.{u} β _inst_1) (@free_abelian_group.lift.{u u} α β _inst_1 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       x)
    (@functor.map.{u u} free_abelian_group.{u}
       (@applicative.to_functor.{u u} free_abelian_group.{u}
          (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
       (list.{u} α)
       (multiset.{u} α)
       (λ (l : list.{u} α),
          @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
            (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
            l)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α
⊢ ∀ (x : free_monoid.{u} α),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
         (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
         (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
      (@free_abelian_group.lift.{u u} (free_monoid.{u} α) (free_comm_ring.{u} α)
         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
         (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (free_abelian_group.{u} (multiset.{u} α))
            ((λ (α : Type u), @free_abelian_group.of.{u} α) (multiset.{u} α))
            (λ (l : list.{u} α),
               @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                 (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                    (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                 l))
         (@free_abelian_group.of.{u} (free_monoid.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262    intros x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α
⊢ ∀ (x : free_monoid.{u} α),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
         (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
            (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
         (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
      (@free_abelian_group.lift.{u u} (free_monoid.{u} α) (free_comm_ring.{u} α)
         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
         (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (free_abelian_group.{u} (multiset.{u} α))
            ((λ (α : Type u), @free_abelian_group.of.{u} α) (multiset.{u} α))
            (λ (l : list.{u} α),
               @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                 (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                    (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                 l))
         (@free_abelian_group.of.{u} (free_monoid.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α,
x : free_monoid.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
    (@free_abelian_group.lift.{u u} (free_monoid.{u} α) (free_comm_ring.{u} α)
       (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
       (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (free_abelian_group.{u} (multiset.{u} α))
          ((λ (α : Type u), @free_abelian_group.of.{u} α) (multiset.{u} α))
          (λ (l : list.{u} α),
             @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                  (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
               l))
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    change free_ring.lift free_comm_ring.of (free_abelian_group.of x) = _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u} [_inst_1 : ring.{u} β], (α → β) → free_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_monoid.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α,
x : free_monoid.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
    (@free_abelian_group.lift.{u u} (free_monoid.{u} α) (free_comm_ring.{u} α)
       (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
       (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (free_abelian_group.{u} (multiset.{u} α))
          ((λ (α : Type u), @free_abelian_group.of.{u} α) (multiset.{u} α))
          (λ (l : list.{u} α),
             @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                  (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
               l))
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α,
x : free_monoid.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
    (@free_abelian_group.lift.{u u} (free_monoid.{u} α) (free_comm_ring.{u} α)
       (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
       (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (free_abelian_group.{u} (multiset.{u} α))
          ((λ (α : Type u), @free_abelian_group.of.{u} α) (multiset.{u} α))
          (λ (l : list.{u} α),
             @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                  (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
               l))
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    change _ = free_abelian_group.of (↑x),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='free_monoid.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α,
x : free_monoid.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
    (@free_abelian_group.lift.{u u} (free_monoid.{u} α) (free_comm_ring.{u} α)
       (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
          (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
       (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (free_abelian_group.{u} (multiset.{u} α))
          ((λ (α : Type u), @free_abelian_group.of.{u} α) (multiset.{u} α))
          (λ (l : list.{u} α),
             @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
               (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                  (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
               l))
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α,
x : free_monoid.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265    induction x with hd tl ih, {refl},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_monoid.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_ring.{u} α,
x : free_monoid.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) x))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case list.nil
α : Type u,
x : free_ring.{u} α
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) (@list.nil.{u} α)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          (@list.nil.{u} α)))

case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) tl))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          tl))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) (@list.cons.{u} α hd tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          (@list.cons.{u} α hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) tl))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          tl))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) (@list.cons.{u} α hd tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          (@list.cons.{u} α hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266    simp only [*, free_ring.lift, free_comm_ring.of, free_abelian_group.of, free_abelian_group.lift,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='free_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_abelian_group.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : ring.{?l_2} β], (α → β) → free_ring.{?l_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, α → free_comm_ring.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, α → free_abelian_group.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_comm_group.{?l_2} β], (α → β) → free_abelian_group.{?l_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) tl))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          tl))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) (@list.cons.{u} α hd tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          (@list.cons.{u} α hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267      free_group.of, free_group.to_group, free_group.to_group.aux,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_group.to_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_group.to_group.aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 357, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 383, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 373, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, α → free_group.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : group.{?l_2} β], (α → β) → free_group.{?l_1} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : group.{?l_2} β], (α → β) → list.{?l_1} (prod.{?l_1 0} α bool) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `of x` is the canonical injection from the type to the free group over that type by sending each
element to the equivalence class of the letter that is the element.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If `β` is a group, then any function from `α` to `β`
extends uniquely to a group homomorphism from
the free group over `α` to `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) tl))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          tl))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) (@list.cons.{u} α hd tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          (@list.cons.{u} α hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268      mul_one, free_group.quot_lift_mk, abelianization.lift.of, bool.cond_tt, list.prod_cons,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_group.quot_lift_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='abelianization.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='bool.cond_tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.prod_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_group.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/abelianization.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/bool.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α] (a : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) a (@has_one.one.{?l_1} α (@monoid.to_has_one.{?l_1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {L : list.{?l_1} (prod.{?l_1 0} α bool)} (β : Type ?l_2) (f : list.{?l_1} (prod.{?l_1 0} α bool) → β) (H : ∀ (L₁ L₂ : list.{?l_1} (prod.{?l_1 0} α bool)), @free_group.red.step.{?l_1} α L₁ L₂ → @eq.{?l_2+1} β (f L₁) (f L₂)), @eq.{?l_2+1} β (@quot.lift.{?l_1+1 ?l_2+1} (list.{?l_1} (prod.{?l_1 0} α bool)) (λ (L₁ L₂ : list.{?l_1} (prod.{?l_1 0} α bool)), @free_group.red.step.{?l_1} α L₁ L₂) β f H (@free_group.mk.{?l_1} α L)) (f L)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : group.{?l_1} α] {β : Type ?l_2} [_inst_2 : comm_group.{?l_2} β] (f : α → β) [_inst_3 : @is_group_hom.{?l_1 ?l_2} α β _inst_1 (@comm_group.to_group.{?l_2} β _inst_2) f] (x : α), @eq.{?l_2+1} β (@abelianization.lift.{?l_1 ?l_2} α _inst_1 β _inst_2 f _inst_3 (@abelianization.of.{?l_1} α _inst_1 x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (t e : α), @eq.{?l_1+1} α (@cond.{?l_1} α bool.tt t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α] {l : list.{?l_1} α} {a : α}, @eq.{?l_1+1} α (@list.prod.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) (@monoid.to_has_one.{?l_1} α _inst_1) (@list.cons.{?l_1} α a l)) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) a (@list.prod.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) (@monoid.to_has_one.{?l_1} α _inst_1) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) tl))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          tl))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) (@list.cons.{u} α hd tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          (@list.cons.{u} α hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269      cond, list.prod_nil, list.map] at *,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='cond'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.prod_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/bool/basic.lean&#x27;, &#x27;line&#x27;: 7, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1496, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {a : Type ?l_1}, bool → a → a → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : monoid.{?l_1} α], @eq.{?l_1+1} α (@list.prod.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) (@monoid.to_has_one.{?l_1} α _inst_1) (@list.nil.{?l_1} α)) (@has_one.one.{?l_1} α (@monoid.to_has_one.{?l_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, (α → β) → list.{?l_1} α → list.{?l_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) tl))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          tl))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@free_ring.lift.{u u} α (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.of.{u} (free_monoid.{u} α) (@list.cons.{u} α hd tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
          (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
             (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
          (@list.cons.{u} α hd tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@list.prod.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
          (@ring.to_monoid.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@list.map.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) tl))
    (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
          (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
             (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
                   (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                      (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                   tl)
                bool.tt)
             (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)))))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
             (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
                (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                   (@coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                      (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                         (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                      (@list.cons.{u} α hd (@list.nil.{u} α)))
                   bool.tt)
                (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)))))
       (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
             (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
                (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                   (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
                      (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                         (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                      tl)
                   bool.tt)
                (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool))))))
    (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
          (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
             (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
                   (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                      (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                   (@list.cons.{u} α hd tl))
                bool.tt)
             (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270    refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : free_ring.{u} α,
hd : α,
tl : list.{u} α,
ih :
  @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@list.prod.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
          (@ring.to_monoid.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@list.map.{u u} α (free_comm_ring.{u} α) (@free_comm_ring.of.{u} α) tl))
    (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
          (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
             (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
                   (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                      (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                   tl)
                bool.tt)
             (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)))))
⊢ @eq.{u+1} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
             (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
                (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                   (@coe.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                      (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                         (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                      (@list.cons.{u} α hd (@list.nil.{u} α)))
                   bool.tt)
                (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)))))
       (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
             (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
                (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                   (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
                      (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                         (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                      tl)
                   bool.tt)
                (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool))))))
    (@abelianization.of.{u} (free_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@free_group.mk.{u} (multiplicative.{u} (multiset.{u} α))
          (@list.cons.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)
             (@prod.mk.{u 0} (multiplicative.{u} (multiset.{u} α)) bool
                (@coe.{u+1 u+1} (free_monoid.{u} α) (multiplicative.{u} (multiset.{u} α))
                   (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                      (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α)))
                   (@list.cons.{u} α hd tl))
                bool.tt)
             (@list.nil.{u} (prod.{u 0} (multiplicative.{u} (multiset.{u} α)) bool)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  def subsingleton_equiv_free_comm_ring [subsingleton α] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='subsingleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 804, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    free_ring α ≃+* free_comm_ring α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β : Type u) [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{u} β] [_inst_4 : has_add.{u} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  @ring_equiv.of&#x27; (free_ring α) (free_comm_ring α) _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring_equiv.of&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 594, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (e : equiv.{u+1 v+1} α β) [_inst_3 : @is_ring_hom.{u v} α β _inst_1 _inst_2 (@coe_fn.{(max 1 (max (u+1) (v+1)) (v+1) (u+1)) (max (u+1) (v+1))} (equiv.{u+1 v+1} α β) (@equiv.has_coe_to_fun.{u+1 v+1} α β) e)], @ring_equiv.{u v} α β (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@distrib.to_has_add.{u} α (@ring.to_distrib.{u} α _inst_1)) (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β _inst_2))) (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Interpret an equivalence `f : α ≃ β` as a ring equivalence `α ≃+* β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276    (@functor.map_equiv _ _ free_abelian_group _ _ $ multiset.subsingleton_equiv α) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='functor.map_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_abelian_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='multiset.subsingleton_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/functor.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 3212, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α β : Type u} {f : Type u → Type v} [_inst_1 : functor.{u v} f] [_inst_2 : @is_lawful_functor.{u v} f _inst_1], equiv.{u+1 u+1} α β → equiv.{v+1 v+1} (f α) (f β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u_1) [_inst_3 : subsingleton.{u_1+1} α], equiv.{u_1+1 u_1+1} (list.{u_1} α) (multiset.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@functor.map_equiv.{u u} (list.{u} α) (multiset.{u} α) free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}
                free_abelian_group.is_lawful_monad.{u}))
          (@multiset.subsingleton_equiv.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278      delta functor.map_equiv,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1360, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `dunfold`, but performs a raw delta reduction, rather than using an equation associated with the defined constants.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='delta'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@functor.map_equiv.{u u} (list.{u} α) (multiset.{u} α) free_abelian_group.{u}
          (@applicative.to_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
          (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
             (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
             (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}
                free_abelian_group.is_lawful_monad.{u}))
          (@multiset.subsingleton_equiv.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.mk.{u+1 u+1} (free_abelian_group.{u} (list.{u} α)) (free_abelian_group.{u} (multiset.{u} α))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (list.{u} α)
             (multiset.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@multiset.subsingleton_equiv.{u} α _inst_1)))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (multiset.{u} α)
             (list.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.subsingleton_equiv.{u} α _inst_1))))
          (λ (x : free_abelian_group.{u} (list.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (list.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (list.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           x))
                     (λ (_a : free_abelian_group.{u} (list.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (multiset.{u} α)
                                (list.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                      (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (list.{u} α)
                                   (multiset.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@multiset.subsingleton_equiv.{u} α _inst_1))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (list.{u} α)
                                 (multiset.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@map_map.{u u} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (list.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (list.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (list.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (list.{u} α))
                           (free_abelian_group.{u} (list.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@id.{u+1} (list.{u} α))
                        (@funext.{u+1 u+1} (list.{u} α) (λ (x : list.{u} α), list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@id.{u+1} (list.{u} α))
                           (λ (a : list.{u} α),
                              @equiv.symm_apply_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (list.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (list.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (list.{u} α)
                     x)))
          (λ (x : free_abelian_group.{u} (multiset.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (multiset.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@multiset.subsingleton_equiv.{u} α _inst_1))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (multiset.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1))))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x))
                     (λ (_a : free_abelian_group.{u} (multiset.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (list.{u} α)
                                (multiset.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@multiset.subsingleton_equiv.{u} α _inst_1))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (multiset.{u} α)
                                   (list.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                         (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (multiset.{u} α)
                                 (list.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                       (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@map_map.{u u} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (multiset.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (multiset.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (multiset.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (multiset.{u} α))
                           (free_abelian_group.{u} (multiset.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        (@id.{u+1} (multiset.{u} α))
                        (@funext.{u+1 u+1} (multiset.{u} α) (λ (x : multiset.{u} α), multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           (@id.{u+1} (multiset.{u} α))
                           (λ (a : multiset.{u} α),
                              @equiv.apply_symm_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (multiset.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (multiset.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (multiset.{u} α)
                     x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279      rw congr_arg is_ring_hom _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} {a₁ a₂ : α} (f : α → β), @eq.{u+1} α a₁ a₂ → @eq.{1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u} [_inst_1 : ring.{u} α] [_inst_2 : ring.{u} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.mk.{u+1 u+1} (free_abelian_group.{u} (list.{u} α)) (free_abelian_group.{u} (multiset.{u} α))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (list.{u} α)
             (multiset.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@multiset.subsingleton_equiv.{u} α _inst_1)))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (multiset.{u} α)
             (list.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.subsingleton_equiv.{u} α _inst_1))))
          (λ (x : free_abelian_group.{u} (list.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (list.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (list.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           x))
                     (λ (_a : free_abelian_group.{u} (list.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (multiset.{u} α)
                                (list.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                      (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (list.{u} α)
                                   (multiset.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@multiset.subsingleton_equiv.{u} α _inst_1))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (list.{u} α)
                                 (multiset.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@map_map.{u u} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (list.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (list.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (list.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (list.{u} α))
                           (free_abelian_group.{u} (list.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@id.{u+1} (list.{u} α))
                        (@funext.{u+1 u+1} (list.{u} α) (λ (x : list.{u} α), list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@id.{u+1} (list.{u} α))
                           (λ (a : list.{u} α),
                              @equiv.symm_apply_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (list.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (list.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (list.{u} α)
                     x)))
          (λ (x : free_abelian_group.{u} (multiset.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (multiset.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@multiset.subsingleton_equiv.{u} α _inst_1))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (multiset.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1))))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x))
                     (λ (_a : free_abelian_group.{u} (multiset.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (list.{u} α)
                                (multiset.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@multiset.subsingleton_equiv.{u} α _inst_1))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (multiset.{u} α)
                                   (list.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                         (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (multiset.{u} α)
                                 (list.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                       (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@map_map.{u u} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (multiset.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (multiset.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (multiset.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (multiset.{u} α))
                           (free_abelian_group.{u} (multiset.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        (@id.{u+1} (multiset.{u} α))
                        (@funext.{u+1 u+1} (multiset.{u} α) (λ (x : multiset.{u} α), multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           (@id.{u+1} (multiset.{u} α))
                           (λ (a : multiset.{u} α),
                              @equiv.apply_symm_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (multiset.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (multiset.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (multiset.{u} α)
                     x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    ?m_1

α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ free_ring.{u} α → free_comm_ring.{u} α

α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @eq.{u+1} (free_ring.{u} α → free_comm_ring.{u} α)
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.mk.{u+1 u+1} (free_abelian_group.{u} (list.{u} α)) (free_abelian_group.{u} (multiset.{u} α))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (list.{u} α)
             (multiset.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@multiset.subsingleton_equiv.{u} α _inst_1)))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (multiset.{u} α)
             (list.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.subsingleton_equiv.{u} α _inst_1))))
          (λ (x : free_abelian_group.{u} (list.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (list.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (list.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           x))
                     (λ (_a : free_abelian_group.{u} (list.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (multiset.{u} α)
                                (list.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                      (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (list.{u} α)
                                   (multiset.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@multiset.subsingleton_equiv.{u} α _inst_1))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (list.{u} α)
                                 (multiset.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@map_map.{u u} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (list.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (list.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (list.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (list.{u} α))
                           (free_abelian_group.{u} (list.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@id.{u+1} (list.{u} α))
                        (@funext.{u+1 u+1} (list.{u} α) (λ (x : list.{u} α), list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@id.{u+1} (list.{u} α))
                           (λ (a : list.{u} α),
                              @equiv.symm_apply_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (list.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (list.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (list.{u} α)
                     x)))
          (λ (x : free_abelian_group.{u} (multiset.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (multiset.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@multiset.subsingleton_equiv.{u} α _inst_1))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (multiset.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1))))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x))
                     (λ (_a : free_abelian_group.{u} (multiset.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (list.{u} α)
                                (multiset.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@multiset.subsingleton_equiv.{u} α _inst_1))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (multiset.{u} α)
                                   (list.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                         (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (multiset.{u} α)
                                 (list.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                       (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@map_map.{u u} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (multiset.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (multiset.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (multiset.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (multiset.{u} α))
                           (free_abelian_group.{u} (multiset.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        (@id.{u+1} (multiset.{u} α))
                        (@funext.{u+1 u+1} (multiset.{u} α) (λ (x : multiset.{u} α), multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           (@id.{u+1} (multiset.{u} α))
                           (λ (a : multiset.{u} α),
                              @equiv.apply_symm_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (multiset.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (multiset.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (multiset.{u} α)
                     x)))))
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280      work_on_goal 2 { symmetry, exact coe_eq α },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='free_ring.coe_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/chain.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/chain.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 255, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/chain.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse nat (λ (a : nat), nat.reflect a) lean.parser.small_nat → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse nat (λ (a : nat), nat.reflect a) lean.parser.small_nat → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type u), @eq.{u+1} (free_ring.{u} α → free_comm_ring.{u} α) (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α)))) (@functor.map.{u u} free_abelian_group.{u} (@applicative.to_functor.{u u} free_abelian_group.{u} (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})) (list.{u} α) (multiset.{u} α) (λ (l : list.{u} α), @coe.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@coe_to_lift.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@coe_base.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.has_coe.{u} α))) l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse nat (λ (a : nat), nat.reflect a) lean.parser.small_nat → tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='work_on_goal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='work_on_goal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='work_on_goal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    ?m_1

α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ free_ring.{u} α → free_comm_ring.{u} α

α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @eq.{u+1} (free_ring.{u} α → free_comm_ring.{u} α)
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.mk.{u+1 u+1} (free_abelian_group.{u} (list.{u} α)) (free_abelian_group.{u} (multiset.{u} α))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (list.{u} α)
             (multiset.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@multiset.subsingleton_equiv.{u} α _inst_1)))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (multiset.{u} α)
             (list.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.subsingleton_equiv.{u} α _inst_1))))
          (λ (x : free_abelian_group.{u} (list.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (list.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (list.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           x))
                     (λ (_a : free_abelian_group.{u} (list.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (multiset.{u} α)
                                (list.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                      (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (list.{u} α)
                                   (multiset.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@multiset.subsingleton_equiv.{u} α _inst_1))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (list.{u} α)
                                 (multiset.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@map_map.{u u} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (list.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (list.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (list.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (list.{u} α))
                           (free_abelian_group.{u} (list.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@id.{u+1} (list.{u} α))
                        (@funext.{u+1 u+1} (list.{u} α) (λ (x : list.{u} α), list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@id.{u+1} (list.{u} α))
                           (λ (a : list.{u} α),
                              @equiv.symm_apply_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (list.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (list.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (list.{u} α)
                     x)))
          (λ (x : free_abelian_group.{u} (multiset.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (multiset.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@multiset.subsingleton_equiv.{u} α _inst_1))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (multiset.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1))))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x))
                     (λ (_a : free_abelian_group.{u} (multiset.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (list.{u} α)
                                (multiset.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@multiset.subsingleton_equiv.{u} α _inst_1))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (multiset.{u} α)
                                   (list.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                         (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (multiset.{u} α)
                                 (list.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                       (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@map_map.{u u} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (multiset.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (multiset.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (multiset.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (multiset.{u} α))
                           (free_abelian_group.{u} (multiset.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        (@id.{u+1} (multiset.{u} α))
                        (@funext.{u+1 u+1} (multiset.{u} α) (λ (x : multiset.{u} α), multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           (@id.{u+1} (multiset.{u} α))
                           (λ (a : multiset.{u} α),
                              @equiv.apply_symm_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (multiset.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (multiset.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (multiset.{u} α)
                     x)))))
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @eq.{u+1} (free_ring.{u} α → free_comm_ring.{u} α)
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.mk.{u+1 u+1} (free_abelian_group.{u} (list.{u} α)) (free_abelian_group.{u} (multiset.{u} α))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (list.{u} α)
             (multiset.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@multiset.subsingleton_equiv.{u} α _inst_1)))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (multiset.{u} α)
             (list.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.subsingleton_equiv.{u} α _inst_1))))
          (λ (x : free_abelian_group.{u} (list.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (list.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (list.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           x))
                     (λ (_a : free_abelian_group.{u} (list.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (multiset.{u} α)
                                (list.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                      (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (list.{u} α)
                                   (multiset.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@multiset.subsingleton_equiv.{u} α _inst_1))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (list.{u} α)
                                 (multiset.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@map_map.{u u} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (list.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (list.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (list.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (list.{u} α))
                           (free_abelian_group.{u} (list.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@id.{u+1} (list.{u} α))
                        (@funext.{u+1 u+1} (list.{u} α) (λ (x : list.{u} α), list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@id.{u+1} (list.{u} α))
                           (λ (a : list.{u} α),
                              @equiv.symm_apply_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (list.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (list.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (list.{u} α)
                     x)))
          (λ (x : free_abelian_group.{u} (multiset.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (multiset.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@multiset.subsingleton_equiv.{u} α _inst_1))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (multiset.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1))))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x))
                     (λ (_a : free_abelian_group.{u} (multiset.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (list.{u} α)
                                (multiset.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@multiset.subsingleton_equiv.{u} α _inst_1))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (multiset.{u} α)
                                   (list.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                         (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (multiset.{u} α)
                                 (list.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                       (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@map_map.{u u} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (multiset.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (multiset.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (multiset.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (multiset.{u} α))
                           (free_abelian_group.{u} (multiset.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        (@id.{u+1} (multiset.{u} α))
                        (@funext.{u+1 u+1} (multiset.{u} α) (λ (x : multiset.{u} α), multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           (@id.{u+1} (multiset.{u} α))
                           (λ (a : multiset.{u} α),
                              @equiv.apply_symm_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (multiset.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (multiset.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (multiset.{u} α)
                     x)))))
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @eq.{u+1} (free_ring.{u} α → free_comm_ring.{u} α) ?m_1
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.has_coe_to_fun.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α))
       (@equiv.mk.{u+1 u+1} (free_abelian_group.{u} (list.{u} α)) (free_abelian_group.{u} (multiset.{u} α))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (list.{u} α)
             (multiset.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                (@multiset.subsingleton_equiv.{u} α _inst_1)))
          (@functor.map.{u u} free_abelian_group.{u}
             (@applicative.to_functor.{u u} free_abelian_group.{u}
                (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
             (multiset.{u} α)
             (list.{u} α)
             (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α) (@multiset.subsingleton_equiv.{u} α _inst_1))))
          (λ (x : free_abelian_group.{u} (list.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (list.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                        (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (list.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1)))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           x))
                     (λ (_a : free_abelian_group.{u} (list.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (multiset.{u} α)
                                (list.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                   (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                      (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (list.{u} α)
                                   (multiset.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                      (@multiset.subsingleton_equiv.{u} α _inst_1))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (list.{u} α)
                                 (multiset.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@map_map.{u u} (list.{u} α) (multiset.{u} α) (list.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (list.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (list.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (list.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (list.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (list.{u} α))
                           (free_abelian_group.{u} (list.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (list.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@id.{u+1} (list.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (list.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@id.{u+1} (list.{u} α))
                        (@funext.{u+1 u+1} (list.{u} α) (λ (x : list.{u} α), list.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (list.{u} α) (multiset.{u} α) (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           (@id.{u+1} (list.{u} α))
                           (λ (a : list.{u} α),
                              @equiv.symm_apply_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (list.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (list.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (list.{u} α)
                     x)))
          (λ (x : free_abelian_group.{u} (multiset.{u} α)),
             @eq.mpr.{0}
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (list.{u} α)
                     (multiset.{u} α)
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                        (@multiset.subsingleton_equiv.{u} α _inst_1))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (list.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        x))
                  x)
               (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                  (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (multiset.{u} α)
                     (multiset.{u} α)
                     (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1))))
                     x)
                  x)
               (@id.{0}
                  (@eq.{1} Prop
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} free_abelian_group.{u}
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (list.{u} α)
                           (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (multiset.{u} α)
                              (list.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1)))
                              x))
                        x)
                     (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                        (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           x)
                        x))
                  (@eq.rec.{0 u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (list.{u} α)
                        (multiset.{u} α)
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        (@functor.map.{u u} (λ {α : Type u}, free_abelian_group.{u} α)
                           (@applicative.to_functor.{u u} free_abelian_group.{u}
                              (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                           (multiset.{u} α)
                           (list.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1)))
                           x))
                     (λ (_a : free_abelian_group.{u} (multiset.{u} α)),
                        @eq.{1} Prop
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                             (@functor.map.{u u} free_abelian_group.{u}
                                (@applicative.to_functor.{u u} free_abelian_group.{u}
                                   (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                (list.{u} α)
                                (multiset.{u} α)
                                (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                   (@multiset.subsingleton_equiv.{u} α _inst_1))
                                (@functor.map.{u u} free_abelian_group.{u}
                                   (@applicative.to_functor.{u u} free_abelian_group.{u}
                                      (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                   (multiset.{u} α)
                                   (list.{u} α)
                                   (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                      (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                         (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                   x))
                             x)
                          (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) _a x))
                     (@eq.refl.{1} Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                           (@functor.map.{u u} free_abelian_group.{u}
                              (@applicative.to_functor.{u u} free_abelian_group.{u}
                                 (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                              (list.{u} α)
                              (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@functor.map.{u u} free_abelian_group.{u}
                                 (@applicative.to_functor.{u u} free_abelian_group.{u}
                                    (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                                 (multiset.{u} α)
                                 (list.{u} α)
                                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                    (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                       (@multiset.subsingleton_equiv.{u} α _inst_1)))
                                 x))
                           x))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@map_map.{u u} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                        (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                           (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                              free_abelian_group.monad.{u}
                              free_abelian_group.is_lawful_monad.{u}))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                           (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                              (@multiset.subsingleton_equiv.{u} α _inst_1)))
                        (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                           (@multiset.subsingleton_equiv.{u} α _inst_1))
                        x)))
               (@eq.mpr.{0}
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     x)
                  (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α))
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     x)
                  ((λ (a a_1 : free_abelian_group.{u} (multiset.{u} α))
                    (e_1 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a a_1)
                    (a_2 a_3 : free_abelian_group.{u} (multiset.{u} α))
                    (e_2 : @eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_2 a_3),
                      @congr.{u+1 1} (free_abelian_group.{u} (multiset.{u} α)) Prop
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a)
                        (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)) a_1)
                        a_2
                        a_3
                        (@congr_arg.{u+1 (max (u+1) 1)} (free_abelian_group.{u} (multiset.{u} α))
                           (free_abelian_group.{u} (multiset.{u} α) → Prop)
                           a
                           a_1
                           (@eq.{u+1} (free_abelian_group.{u} (multiset.{u} α)))
                           e_1)
                        e_2)
                     (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        x)
                     (@functor.map.{u u} free_abelian_group.{u}
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@id.{u+1} (multiset.{u} α))
                        x)
                     (@(λ [c : functor.{u u} (λ (α : Type u), free_abelian_group.{u} α)] {α β : Type u}
                       (a a_1 : α → β) (e_4 : @eq.{u+1} (α → β) a a_1)
                       (a_2 a_3 : (λ (α : Type u), free_abelian_group.{u} α) α)
                       (e_5 : @eq.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) α) a_2 a_3),
                         @congr.{u+1 u+1} ((λ (α : Type u), free_abelian_group.{u} α) α)
                           ((λ (α : Type u), free_abelian_group.{u} α) β)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a)
                           (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β a_1)
                           a_2
                           a_3
                           (@congr_arg.{u+1 u+1} (α → β)
                              ((λ (α : Type u), free_abelian_group.{u} α) α →
                               (λ (α : Type u), free_abelian_group.{u} α) β)
                              a
                              a_1
                              (@functor.map.{u u} (λ (α : Type u), free_abelian_group.{u} α) c α β)
                              e_4)
                           e_5)
                        (@applicative.to_functor.{u u} free_abelian_group.{u}
                           (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                        (multiset.{u} α)
                        (multiset.{u} α)
                        (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                              (@multiset.subsingleton_equiv.{u} α _inst_1))
                           (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                              (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))))
                        (@id.{u+1} (multiset.{u} α))
                        (@funext.{u+1 u+1} (multiset.{u} α) (λ (x : multiset.{u} α), multiset.{u} α)
                           (@function.comp.{u+1 u+1 u+1} (multiset.{u} α) (list.{u} α) (multiset.{u} α)
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (list.{u} α) (multiset.{u} α))
                                 (@multiset.subsingleton_equiv.{u} α _inst_1))
                              (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.has_coe_to_fun.{u+1 u+1} (multiset.{u} α) (list.{u} α))
                                 (@equiv.symm.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                    (@multiset.subsingleton_equiv.{u} α _inst_1))))
                           (@id.{u+1} (multiset.{u} α))
                           (λ (a : multiset.{u} α),
                              @equiv.apply_symm_apply.{u+1 u+1} (list.{u} α) (multiset.{u} α)
                                (@multiset.subsingleton_equiv.{u} α _inst_1)
                                a))
                        x
                        x
                        (@eq.refl.{u+1} ((λ (α : Type u), free_abelian_group.{u} α) (multiset.{u} α)) x))
                     x
                     x
                     (@eq.refl.{u+1} (free_abelian_group.{u} (multiset.{u} α)) x))
                  (@is_lawful_functor.id_map.{u u} free_abelian_group.{u}
                     (@applicative.to_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u}))
                     (@is_lawful_applicative.to_is_lawful_functor.{u u} free_abelian_group.{u}
                        (@monad.to_applicative.{u u} free_abelian_group.{u} free_abelian_group.monad.{u})
                        (@is_lawful_monad.to_is_lawful_applicative.{u u} free_abelian_group.{u}
                           free_abelian_group.monad.{u}
                           free_abelian_group.is_lawful_monad.{u}))
                     (multiset.{u} α)
                     x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281      apply_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α
⊢ @is_ring_hom.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.ring.{u} α)
    (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
    (@coe.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@coe_to_lift.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@coe_base.{u+1 u+1} (free_ring.{u} α) (free_comm_ring.{u} α) (free_ring.has_coe.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  instance [subsingleton α] : comm_ring (free_ring α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='subsingleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 804, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  { mul_comm := λ x y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    by rw [← (subsingleton_equiv_free_comm_ring α).left_inv (y * x),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='free_ring.subsingleton_equiv_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : subsingleton.{u+1} α], @ring_equiv.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
          (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
          (@has_mul.mul.{u} (free_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             y
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287          is_ring_hom.map_mul ((subsingleton_equiv_free_comm_ring α)).to_fun,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_ring_hom.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_ring.subsingleton_equiv_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} α] [_inst_2 : ring.{u} β] (f : α → β) [c : @is_ring_hom.{u u} α β _inst_1 _inst_2 f] {x y : α}, @eq.{u+1} β (f (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) x y)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_2))) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_1 : subsingleton.{u+1} α], @ring_equiv.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
          (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
          (@has_mul.mul.{u} (free_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             y
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             y)
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288          mul_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : comm_semigroup.{u} α] (a b : α), @eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@comm_semigroup.to_semigroup.{u} α _inst_1)) a b) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@comm_semigroup.to_semigroup.{u} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             y)
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@semigroup.to_has_mul.{u} (free_comm_ring.{u} α)
             (@comm_semigroup.to_semigroup.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semigroup.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             x)
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289          ← is_ring_hom.map_mul ((subsingleton_equiv_free_comm_ring α)).to_fun,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_ring_hom.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_ring.subsingleton_equiv_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : ring.{u} α] [_inst_2 : ring.{u} β] (f : α → β) [c : @is_ring_hom.{u u} α β _inst_1 _inst_2 f] {x y : α}, @eq.{u+1} β (f (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) x y)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β _inst_2))) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_1 : subsingleton.{u+1} α], @ring_equiv.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@semigroup.to_has_mul.{u} (free_comm_ring.{u} α)
             (@comm_semigroup.to_semigroup.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semigroup.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             x)
          (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             (@distrib.to_has_add.{u} (free_ring.{u} α)
                (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
             (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
          (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
          (@has_mul.mul.{u} (free_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290          (subsingleton_equiv_free_comm_ring α).left_inv],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='free_ring.subsingleton_equiv_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : subsingleton.{u+1} α], @ring_equiv.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : subsingleton.{u+1} α,
x y : free_ring.{u} α
⊢ @eq.{u+1} (free_ring.{u} α)
    (@has_mul.mul.{u} (free_ring.{u} α)
       (@semigroup.to_has_mul.{u} (free_ring.{u} α)
          (@semigroup.mk.{u} (free_ring.{u} α) (@ring.mul.{u} (free_ring.{u} α) (free_ring.ring.{u} α))
             (@ring.mul_assoc.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       x
       y)
    (@ring_equiv.inv_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
             (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
       (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@ring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
       (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
       (@ring_equiv.to_fun.{u u} (free_ring.{u} α) (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
          (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
          (@free_ring.subsingleton_equiv_free_comm_ring.{u} α _inst_1)
          (@has_mul.mul.{u} (free_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_ring.{u} α)
                   (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α))))
             x
             y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291    .. free_ring.ring α }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='free_ring.ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u), ring.{u} (free_ring.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  end free_ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  def free_comm_ring_equiv_mv_polynomial_int :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296    free_comm_ring α ≃+* mv_polynomial α ℤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β : Type u) [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{u} β] [_inst_4 : has_add.{u} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  { to_fun  := free_comm_ring.lift $ λ a, mv_polynomial.X a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_ring.{v} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α], σ → @mv_polynomial.{u_1 u} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`X n` is the degree `1` monomial `1*n`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298    inv_fun := mv_polynomial.eval₂ coe free_comm_ring.of,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='mv_polynomial.eval₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type u} {β : Type v} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α] [_inst_2 : comm_semiring.{v} β], (α → β) → (σ → β) → @mv_polynomial.{u_1 u} σ α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `g` of all the variables
 and a ring hom `f` from the scalar ring to the target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299    map_mul&#x27; := λ _ _, is_ring_hom.map_mul _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_ring_hom.map_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (f : α → β) [c : @is_ring_hom.{u v} α β _inst_1 _inst_2 f] {x y : α}, @eq.{v+1} β (f (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) x y)) (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β (@ring.to_semiring.{v} β _inst_2))) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300    map_add&#x27; := λ _ _, is_ring_hom.map_add _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_ring_hom.map_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : ring.{u} α] [_inst_2 : ring.{v} β] (f : α → β) [c : @is_ring_hom.{u v} α β _inst_1 _inst_2 f] {x y : α}, @eq.{v+1} β (f (@has_add.add.{u} α (@distrib.to_has_add.{u} α (@ring.to_distrib.{u} α _inst_1)) x y)) (@has_add.add.{v} β (@distrib.to_has_add.{v} β (@ring.to_distrib.{v} β _inst_2)) (f x) (f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301    left_inv :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u
⊢ @function.left_inverse.{u+1 u+1} (free_comm_ring.{u} α) (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α))
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303      intro x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u
⊢ @function.left_inverse.{u+1 u+1} (free_comm_ring.{u} α) (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α))
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304      haveI : is_semiring_hom (coe : int → free_comm_ring α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_semiring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 138, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β : Type u} [_inst_1 : semiring.{0} α] [_inst_2 : semiring.{u} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type} {b : Type u} [_inst_1 : has_lift_t.{1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Predicate for semiring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305        @@is_ring_hom.is_semiring_hom _ _ _ (@@int.cast.is_ring_hom _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_ring_hom.is_semiring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='int.cast.is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 308, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1139, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : ring.{0} α] [_inst_2 : ring.{u} β] (f : α → β) [_inst_3 : @is_ring_hom.{0 u} α β _inst_1 _inst_2 f], @is_semiring_hom.{0 u} α β (@ring.to_semiring.{0} α _inst_1) (@ring.to_semiring.{u} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α], @is_ring_hom.{0 u} int α int.ring _inst_1 (@int.cast.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) (@mul_zero_class.to_has_zero.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)) (@distrib.to_has_add.{u} α (@ring.to_distrib.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A ring homomorphism is also a semiring homomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306      refine free_abelian_group.induction_on x rfl _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_abelian_group.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {C : free_abelian_group.{u} α → Prop} (z : free_abelian_group.{u} α), C (@has_zero.zero.{u} (free_abelian_group.{u} α) (@add_monoid.to_has_zero.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) → (∀ (x : α), C (@free_abelian_group.of.{u} α x)) → (∀ (x : α), C (@free_abelian_group.of.{u} α x) → C (@has_neg.neg.{u} (free_abelian_group.{u} α) (@add_group.to_has_neg.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))) (@free_abelian_group.of.{u} α x))) → (∀ (x y : free_abelian_group.{u} α), C x → C y → C (@has_add.add.{u} (free_abelian_group.{u} α) (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} α) (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} α) (@add_group.to_add_monoid.{u} (free_abelian_group.{u} α) (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} α) (free_abelian_group.add_comm_group.{u} α))))) x y)) → C z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
         (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307      { intro s,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
         (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308        refine multiset.induction_on s _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='multiset.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 40}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : multiset.{u} α → Prop} (s : multiset.{u} α), p (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)) → (∀ ⦃a : α⦄ {s : multiset.{u} α}, p s → p (@multiset.cons.{u} α a s)) → p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='multiplicative.{u} (multiset.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
             (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ ∀ ⦃a : α⦄ {s : multiset.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309        { unfold free_comm_ring.lift,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
             (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ ∀ ⦃a : α⦄ {s : multiset.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
             (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@comm_semiring.to_comm_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                  (@comm_ring.to_comm_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                     (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))
               (@multiset.map.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
                  (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
                  s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
             (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310          rw [free_abelian_group.lift.of],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='free_abelian_group.lift.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : add_comm_group.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_abelian_group.lift.{u u} α β _inst_1 f (@free_abelian_group.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_abelian_group.lift.{u u} (multiplicative.{u} (multiset.{u} α))
          (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))
          (λ (s : multiplicative.{u} (multiset.{u} α)),
             @multiset.prod.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@comm_semiring.to_comm_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                  (@comm_ring.to_comm_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                     (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))
               (@multiset.map.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
                  (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
                  s))
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
             (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@multiset.prod.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@comm_semiring.to_comm_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_comm_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))
          (@multiset.map.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311          exact mv_polynomial.eval₂_one _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='mv_polynomial.eval₂_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 380, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f], @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@has_one.one.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_one.{0 u} α σ _inst_1))) (@has_one.one.{u} β (@monoid.to_has_one.{u} β (@semiring.to_monoid.{u} β (@comm_semiring.to_semiring.{u} β _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@multiset.prod.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@comm_semiring.to_comm_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_comm_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))
          (@multiset.map.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α))
       (@has_zero.zero.{u} (multiset.{u} α) (@multiset.has_zero.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ ∀ ⦃a : α⦄ {s : multiset.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312        { intros hd tl ih,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α)
⊢ ∀ ⦃a : α⦄ {s : multiset.{u} α},
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313          show mv_polynomial.eval₂ coe free_comm_ring.of</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='mv_polynomial.eval₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] [_inst_2 : comm_semiring.{u} β], (α → β) → (σ → β) → @mv_polynomial.{u 0} σ α _inst_1 → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {a : Type} {b : Type u} [_inst_1 : has_lift_t.{1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `g` of all the variables
 and a ring hom `f` from the scalar ring to the target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314            (free_comm_ring.lift (λ a, mv_polynomial.X a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mv_polynomial.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} [_inst_1 : comm_ring.{u} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α], σ → @mv_polynomial.{u 0} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`X n` is the degree `1` monomial `1*n`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315            (free_comm_ring.of hd * free_abelian_group.of tl)) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316            free_comm_ring.of hd * free_abelian_group.of tl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_abelian_group.of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/free_abelian_group.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → free_comm_ring.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → free_abelian_group.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='multiset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) (@multiset.cons.{u} α hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@free_comm_ring.of.{u} α hd)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317          rw [free_comm_ring.lift_mul, free_comm_ring.lift_of,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='free_comm_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 66, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β (@comm_ring.to_ring.{u} β _inst_1)))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@free_comm_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@free_comm_ring.of.{u} α hd)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mul_zero_class.to_has_mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@semiring.to_mul_zero_class.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@ring.to_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_comm_ring.of.{u} α hd))
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mul_zero_class.to_has_mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@semiring.to_mul_zero_class.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@ring.to_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
          (@mv_polynomial.X.{0 u} int α int.comm_semiring hd)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318            mv_polynomial.eval₂_mul, mv_polynomial.eval₂_X, ih] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mv_polynomial.eval₂_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval₂_X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 402, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 383, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] {q : @mv_polynomial.{u 0} σ α _inst_1} [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f] {p : @mv_polynomial.{u 0} σ α _inst_1}, @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@has_mul.mul.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_mul.{0 u} α σ _inst_1) p q)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@comm_semiring.to_semiring.{u} β _inst_2))) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g p) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f] (n : σ), @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@mv_polynomial.X.{0 u} α σ _inst_1 n)) (g n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_comm_ring.{u} α) (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))) (@free_comm_ring.of.{u} α) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))) (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mul_zero_class.to_has_mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@semiring.to_mul_zero_class.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@ring.to_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
          (@mv_polynomial.X.{0 u} int α int.comm_semiring hd)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@mv_polynomial.X.{0 u} int α int.comm_semiring hd))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
hd : α,
tl : multiset.{u} α,
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_mul.mul.{u} (free_comm_ring.{u} α)
             (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
                (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                   (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
             (@free_comm_ring.of.{u} α hd)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))))
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@free_comm_ring.of.{u} α hd)
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
         (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319      { intros s ih,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
         (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))

α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x : multiplicative.{u} (multiset.{u} α)),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x)))
      (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x) →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
               (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))))
      (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
         (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320        rw [free_comm_ring.lift_neg, ← neg_one_mul, mv_polynomial.eval₂_mul,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='free_comm_ring.lift_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='neg_one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval₂_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 60, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 402, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_neg.neg.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x)) (@has_neg.neg.{u} β (@add_group.to_has_neg.{u} β (@add_comm_group.to_add_group.{u} β (@ring.to_add_comm_group.{u} β (@comm_ring.to_ring.{u} β _inst_1)))) (@free_comm_ring.lift.{u u} α β _inst_1 f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) (@has_one.one.{u} α (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)))) a) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] {q : @mv_polynomial.{u 0} σ α _inst_1} [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f] {p : @mv_polynomial.{u 0} σ α _inst_1}, @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@has_mul.mul.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_mul.{0 u} α σ _inst_1) p q)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@comm_semiring.to_semiring.{u} β _inst_2))) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g p) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The additive inverse of one multiplied by an element of a ring is the element&#x27;s additive
   inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@has_neg.neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@add_group.to_has_neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mul_zero_class.to_has_mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@semiring.to_mul_zero_class.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@ring.to_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.ring.{0 u} int α int.comm_ring))))
          (@has_neg.neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@add_group.to_has_neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.ring.{0 u} int α int.comm_ring))))
             (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.ring.{0 u} int α int.comm_ring)))))
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_neg.neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@add_group.to_has_neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.ring.{0 u} int α int.comm_ring))))
             (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.ring.{0 u} int α int.comm_ring))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321          ← mv_polynomial.C_1, ← mv_polynomial.C_neg, mv_polynomial.eval₂_C,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mv_polynomial.C_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mv_polynomial.C_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval₂_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 377, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α], @eq.{(max (u+1) 1)} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.C.{0 u} α σ _inst_1 (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))))) (@has_one.one.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_one.{0 u} α σ _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (σ : Type u) (a : α) [_inst_1 : comm_ring.{0} α], @eq.{(max (u+1) 1)} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@mv_polynomial.C.{0 u} α σ (@comm_ring.to_comm_semiring.{0} α _inst_1) (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@comm_ring.to_ring.{0} α _inst_1)))) a)) (@has_neg.neg.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@add_group.to_has_neg.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@mv_polynomial.ring.{0 u} α σ _inst_1)))) (@mv_polynomial.C.{0 u} α σ (@comm_ring.to_comm_semiring.{0} α _inst_1) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f] (a : α), @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@mv_polynomial.C.{0 u} α σ _inst_1 a)) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_neg.neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@add_group.to_has_neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.ring.{0 u} int α int.comm_ring))))
             (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.ring.{0 u} int α int.comm_ring))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_neg.neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@add_group.to_has_neg.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                      (@mv_polynomial.ring.{0 u} int α int.comm_ring))))
             (@mv_polynomial.C.{0 u} int α int.comm_semiring
                (@has_one.one.{0} int
                   (@monoid.to_has_one.{0} int
                      (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@mv_polynomial.C.{0 u} int α (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
             (@has_neg.neg.{0} int
                (@add_group.to_has_neg.{0} int
                   (@add_comm_group.to_add_group.{0} int
                      (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
                (@has_one.one.{0} int
                   (@monoid.to_has_one.{0} int
                      (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring)))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int
             (@add_group.to_has_neg.{0} int
                (@add_comm_group.to_add_group.{0} int
                   (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
             (@has_one.one.{0} int
                (@monoid.to_has_one.{0} int
                   (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322          int.cast_neg, int.cast_one, neg_one_mul, ih] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='int.cast_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.cast_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='neg_one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1105, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1080, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : has_one.{u} α] (n : int), @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) (@has_neg.neg.{0} int int.has_neg n)) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] [_inst_2 : has_one.{u} α] [_inst_3 : has_neg.{u} α], @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α _inst_3 (@add_monoid.to_has_zero.{u} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1))))) (@has_one.one.{0} int int.has_one)) (@has_one.one.{u} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α] (a : α), @eq.{u+1} α (@has_mul.mul.{u} α (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) (@has_one.one.{u} α (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)))) a) (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_comm_ring.{u} α) (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))) (@free_comm_ring.of.{u} α) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))) (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The additive inverse of one multiplied by an element of a ring is the element&#x27;s additive
   inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int
             (@add_group.to_has_neg.{0} int
                (@add_comm_group.to_add_group.{0} int
                   (@ring.to_add_comm_group.{0} int (@comm_ring.to_ring.{0} int int.comm_ring))))
             (@has_one.one.{0} int
                (@monoid.to_has_one.{0} int
                   (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_one.one.{0} int
                (@monoid.to_has_one.{0} int
                   (@semiring.to_monoid.{0} int (@comm_semiring.to_semiring.{0} int int.comm_semiring))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_mul.mul.{u} (free_comm_ring.{u} α)
       (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
          (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@has_neg.neg.{u} (free_comm_ring.{u} α)
          (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_neg.neg.{u} (free_comm_ring.{u} α)
       (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
          (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
             (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
s : multiplicative.{u} (multiset.{u} α),
ih :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)))
    (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s)
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
             (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))))
    (@has_neg.neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_group.to_has_neg.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))
       (@free_abelian_group.of.{u} (multiplicative.{u} (multiset.{u} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323      { intros x₁ x₂ ih₁ ih₂, rw [free_comm_ring.lift_add, mv_polynomial.eval₂_add, ih₁, ih₂] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval₂_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 369, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@ring.to_distrib.{u} β (@comm_ring.to_ring.{u} β _inst_1))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] {p q : @mv_polynomial.{u 0} σ α _inst_1} [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f], @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@has_add.add.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_add.{0 u} α σ _inst_1) p q)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@semiring.to_distrib.{u} β (@comm_semiring.to_semiring.{u} β _inst_2))) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g p) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_comm_ring.{u} α) (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))) (@free_comm_ring.of.{u} α) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) x₁)) x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (free_comm_ring.{u} α) (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))) (@free_comm_ring.of.{u} α) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) x₂)) x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (x y : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α))),
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            x))
      x →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            y))
      y →
    @eq.{u+1} (free_comm_ring.{u} α)
      (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
         (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
         (@free_comm_ring.of.{u} α)
         (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
            (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
            (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
            (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                        (@add_comm_group.to_add_group.{u}
                           (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                           (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
               x
               y)))
      (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
         (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
            (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
               (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                  (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                     (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
         x
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
x₁ x₂ : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih₁ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₁))
    x₁,
ih₂ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₂))
    x₂
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             x₁
             x₂)))
    (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
       x₁
       x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
x₁ x₂ : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih₁ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₁))
    x₁,
ih₂ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₂))
    x₂
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             x₁)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             x₂)))
    (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
       x₁
       x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
x₁ x₂ : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih₁ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₁))
    x₁,
ih₂ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₂))
    x₂
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@semiring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             x₁))
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             x₂)))
    (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
       x₁
       x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
x₁ x₂ : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih₁ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₁))
    x₁,
ih₂ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₂))
    x₂
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@has_add.add.{u} (free_comm_ring.{u} α)
       (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
          (@semiring.to_distrib.{u} (free_comm_ring.{u} α)
             (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
       x₁
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
             (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
             x₂)))
    (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
       x₁
       x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : free_comm_ring.{u} α,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
x₁ x₂ : free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)),
ih₁ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₁))
    x₁,
ih₂ :
  @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          x₂))
    x₂
⊢ @eq.{u+1} (free_comm_ring.{u} α)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α)
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                      (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                         (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
             x₁
             x₂)))
    (@has_add.add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
       (@add_semigroup.to_has_add.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
          (@add_monoid.to_add_semigroup.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
             (@add_group.to_add_monoid.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                (@add_comm_group.to_add_group.{u} (free_abelian_group.{u} (multiplicative.{u} (multiset.{u} α)))
                   (free_abelian_group.add_comm_group.{u} (multiplicative.{u} (multiset.{u} α)))))))
       x₁
       x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325    right_inv :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u
⊢ @function.right_inverse.{u+1 u+1} (free_comm_ring.{u} α) (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α))
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327      intro x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u
⊢ @function.right_inverse.{u+1 u+1} (free_comm_ring.{u} α) (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
       (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
       (@free_comm_ring.of.{u} α))
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328      haveI : is_semiring_hom (coe : int → free_comm_ring α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_semiring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 138, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β : Type u} [_inst_1 : semiring.{0} α] [_inst_2 : semiring.{u} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type} {b : Type u} [_inst_1 : has_lift_t.{1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Predicate for semiring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329        @@is_ring_hom.is_semiring_hom _ _ _ (@@int.cast.is_ring_hom _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_ring_hom.is_semiring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='int.cast.is_ring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 308, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1139, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : ring.{0} α] [_inst_2 : ring.{u} β] (f : α → β) [_inst_3 : @is_ring_hom.{0 u} α β _inst_1 _inst_2 f], @is_semiring_hom.{0 u} α β (@ring.to_semiring.{0} α _inst_1) (@ring.to_semiring.{u} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : ring.{u} α], @is_ring_hom.{0 u} int α int.ring _inst_1 (@int.cast.{u} α (@add_group.to_has_neg.{u} α (@add_comm_group.to_add_group.{u} α (@ring.to_add_comm_group.{u} α _inst_1))) (@mul_zero_class.to_has_zero.{u} α (@semiring.to_mul_zero_class.{u} α (@ring.to_semiring.{u} α _inst_1))) (@monoid.to_has_one.{u} α (@ring.to_monoid.{u} α _inst_1)) (@distrib.to_has_add.{u} α (@ring.to_distrib.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A ring homomorphism is also a semiring homomorphism.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330      have : ∀ i : ℤ, free_comm_ring.lift (λ (a : α), mv_polynomial.X a) ↑i = mv_polynomial.C i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='free_comm_ring.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mv_polynomial.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mv_polynomial.C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u} [_inst_1 : comm_ring.{u} β], (α → β) → free_comm_ring.{u} α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α], σ → @mv_polynomial.{u 0} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α], α → @mv_polynomial.{u 0} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`X n` is the degree `1` monomial `1*n`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`C a` is the constant polynomial with value `a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331      { exact λ i, int.induction_on i</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='int.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 38}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p : int → Prop} (i : int), p (@has_zero.zero.{0} int int.has_zero) → (∀ (i : nat), p (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i) → p (@has_add.add.{0} int int.has_add (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i) (@has_one.one.{0} int int.has_one))) → (∀ (i : nat), p (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)) → p (@has_sub.sub.{0} int int.has_sub (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)) (@has_one.one.{0} int int.has_one))) → p i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332        (by rw [int.cast_zero, free_comm_ring.lift_zero, mv_polynomial.C_0])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='int.cast_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.C_0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1068, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : has_neg.{u} α] [_inst_2 : has_zero.{u} α] [_inst_3 : has_one.{u} α] [_inst_4 : has_add.{u} α], @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α _inst_1 _inst_2 _inst_3 _inst_4))) (@has_zero.zero.{0} int int.has_zero)) (@has_zero.zero.{u} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_zero.zero.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@has_zero.zero.{u} β (@mul_zero_class.to_has_zero.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β (@comm_ring.to_ring.{u} β _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α], @eq.{(max (u+1) 1)} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.C.{0 u} α σ _inst_1 (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))))) (@has_zero.zero.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_zero.{0 u} α σ _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_zero.zero.{0} int int.has_zero)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_zero.zero.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_zero.zero.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mul_zero_class.to_has_zero.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@semiring.to_mul_zero_class.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring (@has_zero.zero.{0} int int.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333        (λ i ih, by rw [int.cast_add, int.cast_one, free_comm_ring.lift_add,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='int.cast_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.cast_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1094, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1080, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : has_one.{u} α] (m n : int), @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) (@has_add.add.{0} int int.has_add m n)) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1))) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) m) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] [_inst_2 : has_one.{u} α] [_inst_3 : has_neg.{u} α], @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α _inst_3 (@add_monoid.to_has_zero.{u} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1))))) (@has_one.one.{0} int int.has_one)) (@has_one.one.{u} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@ring.to_distrib.{u} β (@comm_ring.to_ring.{u} β _inst_1))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_add.add.{0} int int.has_add
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
             (@has_one.one.{0} int int.has_one))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_one.one.{0} int int.has_one))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
             (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334          free_comm_ring.lift_one, ih, mv_polynomial.C_add, mv_polynomial.C_1])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_comm_ring.lift_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.C_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.C_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{u} β (@monoid.to_has_one.{u} β (@ring.to_monoid.{u} β (@comm_ring.to_ring.{u} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))) (@mv_polynomial.C.{0 u} int α int.comm_semiring (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {σ : Type u} {a a&#x27; : α} [_inst_1 : comm_semiring.{0} α], @eq.{(max (u+1) 1)} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.C.{0 u} α σ _inst_1 (@has_add.add.{0} α (@distrib.to_has_add.{0} α (@semiring.to_distrib.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))) a a&#x27;)) (@has_add.add.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_add.{0 u} α σ _inst_1) (@mv_polynomial.C.{0 u} α σ _inst_1 a) (@mv_polynomial.C.{0 u} α σ _inst_1 a&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α], @eq.{(max (u+1) 1)} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.C.{0 u} α σ _inst_1 (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))))) (@has_one.one.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_one.{0 u} α σ _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
       (@mv_polynomial.C.{0 u} int α int.comm_semiring
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
       (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_add.add.{0} int int.has_add
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
       (@mv_polynomial.C.{0 u} int α int.comm_semiring
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
       (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))))
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
       (@mv_polynomial.C.{0 u} int α int.comm_semiring
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
       (@mv_polynomial.C.{0 u} int α int.comm_semiring (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335        (λ i ih, by rw [int.cast_sub, int.cast_one, free_comm_ring.lift_sub,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='int.cast_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.cast_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1109, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1080, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] [_inst_2 : has_one.{u} α] (m n : int), @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) (@has_sub.sub.{0} int int.has_sub m n)) (@has_sub.sub.{u} α (@add_group_has_sub.{u} α _inst_1) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) m) (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α (@add_group.to_has_neg.{u} α _inst_1) (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] [_inst_2 : has_one.{u} α] [_inst_3 : has_neg.{u} α], @eq.{u+1} α (@coe.{1 u+1} int α (@coe_to_lift.{1 u+1} int α (@coe_base.{1 u+1} int α (@int.cast_coe.{u} α _inst_3 (@add_monoid.to_has_zero.{u} α _inst_1) _inst_2 (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1))))) (@has_one.one.{0} int int.has_one)) (@has_one.one.{u} α _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_sub.sub.{u} (free_comm_ring.{u} α) (@add_group_has_sub.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_sub.sub.{u} β (@add_group_has_sub.{u} β (@add_comm_group.to_add_group.{u} β (@ring.to_add_comm_group.{u} β (@comm_ring.to_ring.{u} β _inst_1)))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_sub.sub.{0} int int.has_sub
             (@has_neg.neg.{0} int int.has_neg
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
             (@has_one.one.{0} int int.has_one))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_sub.sub.{u} (free_comm_ring.{u} α)
          (@add_group_has_sub.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_neg.neg.{0} int int.has_neg
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_one.one.{0} int int.has_one))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_sub.sub.{u} (free_comm_ring.{u} α)
          (@add_group_has_sub.{u} (free_comm_ring.{u} α)
             (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_neg.neg.{0} int int.has_neg
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_sub.sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@add_group_has_sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_neg.neg.{0} int int.has_neg
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336          free_comm_ring.lift_one, ih, mv_polynomial.C_sub, mv_polynomial.C_1]) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_comm_ring.lift_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.C_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.C_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 801, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_one.one.{u} (free_comm_ring.{u} α) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))) (@has_one.one.{u} β (@monoid.to_has_one.{u} β (@ring.to_monoid.{u} β (@comm_ring.to_ring.{u} β _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))) (@mv_polynomial.C.{0 u} int α int.comm_semiring (@has_neg.neg.{0} int int.has_neg (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (σ : Type u) (a a&#x27; : α) [_inst_1 : comm_ring.{0} α], @eq.{(max (u+1) 1)} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@mv_polynomial.C.{0 u} α σ (@comm_ring.to_comm_semiring.{0} α _inst_1) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@comm_ring.to_ring.{0} α _inst_1)))) a a&#x27;)) (@has_sub.sub.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@add_group_has_sub.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} σ α (@comm_ring.to_comm_semiring.{0} α _inst_1)) (@mv_polynomial.ring.{0 u} α σ _inst_1)))) (@mv_polynomial.C.{0 u} α σ (@comm_ring.to_comm_semiring.{0} α _inst_1) a) (@mv_polynomial.C.{0 u} α σ (@comm_ring.to_comm_semiring.{0} α _inst_1) a&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α], @eq.{(max (u+1) 1)} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.C.{0 u} α σ _inst_1 (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@comm_semiring.to_semiring.{0} α _inst_1))))) (@has_one.one.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_one.{0 u} α σ _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_sub.sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@add_group_has_sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_neg.neg.{0} int int.has_neg
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@has_one.one.{u} (free_comm_ring.{u} α)
             (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_sub.sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@add_group_has_sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@add_monoid.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@add_semigroup.to_has_add.{u} (free_comm_ring.{u} α)
                         (@add_monoid.to_add_semigroup.{u} (free_comm_ring.{u} α)
                            (@add_group.to_add_monoid.{u} (free_comm_ring.{u} α)
                               (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                                  (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                     (@comm_ring.to_ring.{u} (free_comm_ring.{u} α)
                                        (free_comm_ring.comm_ring.{u} α))))))))))
             (@has_neg.neg.{0} int int.has_neg
                (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
       (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_sub.sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@add_group_has_sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
       (@mv_polynomial.C.{0 u} int α int.comm_semiring
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_sub.sub.{0} int int.has_sub
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
i : int,
i : nat,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i))))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring
       (@has_neg.neg.{0} int int.has_neg
          (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_sub.sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@add_group_has_sub.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@add_comm_group.to_add_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_add_comm_group.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
       (@mv_polynomial.C.{0 u} int α int.comm_semiring
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@has_one.one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@monoid.to_has_one.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_monoid.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))))
    (@has_sub.sub.{u} (@mv_polynomial.{u 0} α int (@comm_ring.to_comm_semiring.{0} int int.comm_ring))
       (@add_group_has_sub.{u} (@mv_polynomial.{u 0} α int (@comm_ring.to_comm_semiring.{0} int int.comm_ring))
          (@add_comm_group.to_add_group.{u}
             (@mv_polynomial.{u 0} α int (@comm_ring.to_comm_semiring.{0} int int.comm_ring))
             (@ring.to_add_comm_group.{u}
                (@mv_polynomial.{u 0} α int (@comm_ring.to_comm_semiring.{0} int int.comm_ring))
                (@mv_polynomial.ring.{0 u} int α int.comm_ring))))
       (@mv_polynomial.C.{0 u} int α (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
          (@has_neg.neg.{0} int int.has_neg
             (@coe.{1 1} nat int (@coe_to_lift.{1 1} nat int (@coe_base.{1 1} nat int int.has_coe)) i)))
       (@mv_polynomial.C.{0 u} int α (@comm_ring.to_comm_semiring.{0} int int.comm_ring)
          (@has_one.one.{0} int int.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
⊢ ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337      apply mv_polynomial.induction_on x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mv_polynomial.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {σ : Type u} [_inst_1 : comm_semiring.{0} α] {M : @mv_polynomial.{u 0} σ α _inst_1 → Prop} (p : @mv_polynomial.{u 0} σ α _inst_1), (∀ (a : α), M (@mv_polynomial.C.{0 u} α σ _inst_1 a)) → (∀ (p q : @mv_polynomial.{u 0} σ α _inst_1), M p → M q → M (@has_add.add.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_add.{0 u} α σ _inst_1) p q)) → (∀ (p : @mv_polynomial.{u 0} σ α _inst_1) (n : σ), M p → M (@has_mul.mul.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_mul.{0 u} α σ _inst_1) p (@mv_polynomial.X.{0 u} α σ _inst_1 n))) → M p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@mv_polynomial.{u 0} α int int.comm_semiring'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (a : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@mv_polynomial.C.{0 u} int α int.comm_semiring a)))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring a)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p q : @mv_polynomial.{u 0} α int int.comm_semiring),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            q))
      q →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
               p
               q)))
      (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
         p
         q)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p : @mv_polynomial.{u 0} α int int.comm_semiring) (n : α),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
               p
               (@mv_polynomial.X.{0 u} int α int.comm_semiring n))))
      (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
         p
         (@mv_polynomial.X.{0 u} int α int.comm_semiring n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338      { intro i, rw [mv_polynomial.eval₂_C, this] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='mv_polynomial.eval₂_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 377, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f] (a : α), @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@mv_polynomial.C.{0 u} α σ _inst_1 a)) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : int), @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))) i)) (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (a : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@mv_polynomial.C.{0 u} int α int.comm_semiring a)))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring a)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p q : @mv_polynomial.{u 0} α int int.comm_semiring),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            q))
      q →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
               p
               q)))
      (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
         p
         q)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p : @mv_polynomial.{u 0} α int int.comm_semiring) (n : α),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
               p
               (@mv_polynomial.X.{0 u} int α int.comm_semiring n))))
      (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
         p
         (@mv_polynomial.X.{0 u} int α int.comm_semiring n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (a : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@mv_polynomial.C.{0 u} int α int.comm_semiring a)))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
i : int
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@mv_polynomial.C.{0 u} int α int.comm_semiring i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
i : int
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@coe.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                (@int.cast_coe.{u} (free_comm_ring.{u} α)
                   (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                      (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                         (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                      (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                         (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                   (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                      (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                   (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                      (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
          i))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
i : int
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@mv_polynomial.C.{0 u} int α int.comm_semiring i)))
    (@mv_polynomial.C.{0 u} int α int.comm_semiring i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p q : @mv_polynomial.{u 0} α int int.comm_semiring),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            q))
      q →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
               p
               q)))
      (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
         p
         q)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p : @mv_polynomial.{u 0} α int int.comm_semiring) (n : α),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
               p
               (@mv_polynomial.X.{0 u} int α int.comm_semiring n))))
      (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
         p
         (@mv_polynomial.X.{0 u} int α int.comm_semiring n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339      { intros p q ihp ihq, rw [mv_polynomial.eval₂_add, free_comm_ring.lift_add, ihp, ihq] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='mv_polynomial.eval₂_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ihq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 369, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] {p q : @mv_polynomial.{u 0} σ α _inst_1} [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f], @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@has_add.add.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_add.{0 u} α σ _inst_1) p q)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@semiring.to_distrib.{u} β (@comm_semiring.to_semiring.{u} β _inst_2))) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g p) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_add.add.{u} (free_comm_ring.{u} α) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) x y)) (@has_add.add.{u} β (@distrib.to_has_add.{u} β (@ring.to_distrib.{u} β (@comm_ring.to_ring.{u} β _inst_1))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))) (@free_comm_ring.of.{u} α) p)) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))) (@free_comm_ring.of.{u} α) q)) q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p q : @mv_polynomial.{u 0} α int int.comm_semiring),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            q))
      q →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
               p
               q)))
      (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
         p
         q)

α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p : @mv_polynomial.{u 0} α int int.comm_semiring) (n : α),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
               p
               (@mv_polynomial.X.{0 u} int α int.comm_semiring n))))
      (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
         p
         (@mv_polynomial.X.{0 u} int α int.comm_semiring n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p q : @mv_polynomial.{u 0} α int int.comm_semiring),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            q))
      q →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
               p
               q)))
      (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
         p
         q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p q : @mv_polynomial.{u 0} α int int.comm_semiring,
ihp :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p,
ihq :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          q))
    q
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
             p
             q)))
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
       p
       q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p q : @mv_polynomial.{u 0} α int int.comm_semiring,
ihp :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p,
ihq :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          q))
    q
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_add.add.{u} (free_comm_ring.{u} α)
          (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
             (@semiring.to_distrib.{u} (free_comm_ring.{u} α)
                (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             p)
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             q)))
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
       p
       q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p q : @mv_polynomial.{u 0} α int int.comm_semiring,
ihp :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p,
ihq :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          q))
    q
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             p))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             q)))
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
       p
       q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p q : @mv_polynomial.{u 0} α int int.comm_semiring,
ihp :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p,
ihq :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          q))
    q
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@distrib.to_has_add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@ring.to_distrib.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring))))
       p
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             q)))
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
       p
       q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p q : @mv_polynomial.{u 0} α int int.comm_semiring,
ihp :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p,
ihq :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          q))
    q
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
             p
             q)))
    (@has_add.add.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)
       p
       q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p : @mv_polynomial.{u 0} α int int.comm_semiring) (n : α),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
               p
               (@mv_polynomial.X.{0 u} int α int.comm_semiring n))))
      (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
         p
         (@mv_polynomial.X.{0 u} int α int.comm_semiring n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340      { intros p a ih,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i)
⊢ ∀ (p : @mv_polynomial.{u 0} α int int.comm_semiring) (n : α),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            p))
      p →
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
            (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
            (@coe.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                  (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                     (@int.cast_coe.{u} (free_comm_ring.{u} α)
                        (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                           (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                              (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                           (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                              (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                 (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                        (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                           (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                        (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                           (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
            (@free_comm_ring.of.{u} α)
            (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
               (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
               p
               (@mv_polynomial.X.{0 u} int α int.comm_semiring n))))
      (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
         p
         (@mv_polynomial.X.{0 u} int α int.comm_semiring n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
             p
             (@mv_polynomial.X.{0 u} int α int.comm_semiring a))))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341        rw [mv_polynomial.eval₂_mul, mv_polynomial.eval₂_X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mv_polynomial.eval₂_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval₂_X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 402, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 383, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] {q : @mv_polynomial.{u 0} σ α _inst_1} [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f] {p : @mv_polynomial.{u 0} σ α _inst_1}, @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@has_mul.mul.{u} (@mv_polynomial.{u 0} σ α _inst_1) (@mv_polynomial.has_mul.{0 u} α σ _inst_1) p q)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@comm_semiring.to_semiring.{u} β _inst_2))) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g p) (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β σ : Type u} [_inst_1 : comm_semiring.{0} α] [_inst_2 : comm_semiring.{u} β] (f : α → β) (g : σ → β) [_inst_3 : @is_semiring_hom.{0 u} α β (@comm_semiring.to_semiring.{0} α _inst_1) (@comm_semiring.to_semiring.{u} β _inst_2) f] (n : σ), @eq.{u+1} β (@mv_polynomial.eval₂.{0 u u} α β σ _inst_1 _inst_2 f g (@mv_polynomial.X.{0 u} α σ _inst_1 n)) (g n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
             p
             (@mv_polynomial.X.{0 u} int α int.comm_semiring a))))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             p)
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             (@mv_polynomial.X.{0 u} int α int.comm_semiring a))))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             p)
          (@free_comm_ring.of.{u} α a)))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342          free_comm_ring.lift_mul, free_comm_ring.lift_of, ih] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='free_comm_ring.lift_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring.lift_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 66, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x y : free_comm_ring.{u} α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@has_mul.mul.{u} (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) x y)) (@has_mul.mul.{u} β (@mul_zero_class.to_has_mul.{u} β (@semiring.to_mul_zero_class.{u} β (@ring.to_semiring.{u} β (@comm_ring.to_ring.{u} β _inst_1)))) (@free_comm_ring.lift.{u u} α β _inst_1 f x) (@free_comm_ring.lift.{u u} α β _inst_1 f y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : comm_ring.{u} β] (f : α → β) (x : α), @eq.{u+1} β (@free_comm_ring.lift.{u u} α β _inst_1 f (@free_comm_ring.of.{u} α x)) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring) (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring) (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring) (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a) (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)) (@coe.{1 u+1} int (free_comm_ring.{u} α) (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α) (@coe_base.{1 u+1} int (free_comm_ring.{u} α) (@int.cast_coe.{u} (free_comm_ring.{u} α) (@add_group.to_has_neg.{u} (free_comm_ring.{u} α) (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α) (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@monoid.to_has_one.{u} (free_comm_ring.{u} α) (@ring.to_monoid.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))) (@free_comm_ring.of.{u} α) p)) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@has_mul.mul.{u} (free_comm_ring.{u} α)
          (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α)
             (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                (@comm_semiring.to_semiring.{u} (free_comm_ring.{u} α)
                   (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             p)
          (@free_comm_ring.of.{u} α a)))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mul_zero_class.to_has_mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@semiring.to_mul_zero_class.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             p))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@free_comm_ring.of.{u} α a)))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mul_zero_class.to_has_mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@semiring.to_mul_zero_class.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@ring.to_semiring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                (@comm_ring.to_ring.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
                   (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)))))
       (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
          (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
          (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
          (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
             (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
             (@coe.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                   (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                      (@int.cast_coe.{u} (free_comm_ring.{u} α)
                         (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                            (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                               (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                            (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                               (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                                  (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                         (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                            (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                         (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                            (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
             (@free_comm_ring.of.{u} α)
             p))
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : @mv_polynomial.{u 0} α int int.comm_semiring,
_inst :
  @is_semiring_hom.{0 u} int (free_comm_ring.{u} α) int.semiring
    (@ring.to_semiring.{u} (free_comm_ring.{u} α)
       (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))
    (@coe.{1 u+1} int (free_comm_ring.{u} α)
       (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
          (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
             (@int.cast_coe.{u} (free_comm_ring.{u} α)
                (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                   (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                      (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                   (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                      (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                         (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                   (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                   (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                      (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))),
this :
  ∀ (i : int),
    @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
      (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
         (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
         (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
         (@coe.{1 u+1} int (free_comm_ring.{u} α)
            (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
               (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                  (@int.cast_coe.{u} (free_comm_ring.{u} α)
                     (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                        (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                           (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                        (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                           (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                              (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                     (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                        (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                     (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                        (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                           (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))))
            i))
      (@mv_polynomial.C.{0 u} int α int.comm_semiring i),
p : @mv_polynomial.{u 0} α int int.comm_semiring,
a : α,
ih :
  @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          p))
    p
⊢ @eq.{u+1} (@mv_polynomial.{u 0} α int int.comm_semiring)
    (@free_comm_ring.lift.{u u} α (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.comm_ring.{0 u} int α int.comm_ring)
       (λ (a : α), @mv_polynomial.X.{0 u} int α int.comm_semiring a)
       (@mv_polynomial.eval₂.{0 u u} int (free_comm_ring.{u} α) α int.comm_semiring
          (@comm_ring.to_comm_semiring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))
          (@coe.{1 u+1} int (free_comm_ring.{u} α)
             (@coe_to_lift.{1 u+1} int (free_comm_ring.{u} α)
                (@coe_base.{1 u+1} int (free_comm_ring.{u} α)
                   (@int.cast_coe.{u} (free_comm_ring.{u} α)
                      (@add_group.to_has_neg.{u} (free_comm_ring.{u} α)
                         (@add_comm_group.to_add_group.{u} (free_comm_ring.{u} α)
                            (@ring.to_add_comm_group.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@mul_zero_class.to_has_zero.{u} (free_comm_ring.{u} α)
                         (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α)
                            (@ring.to_semiring.{u} (free_comm_ring.{u} α)
                               (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))))
                      (@monoid.to_has_one.{u} (free_comm_ring.{u} α)
                         (@ring.to_monoid.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))
                      (@distrib.to_has_add.{u} (free_comm_ring.{u} α)
                         (@ring.to_distrib.{u} (free_comm_ring.{u} α)
                            (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))))))
          (@free_comm_ring.of.{u} α)
          (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
             (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
             p
             (@mv_polynomial.X.{0 u} int α int.comm_semiring a))))
    (@has_mul.mul.{u} (@mv_polynomial.{u 0} α int int.comm_semiring)
       (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring)
       p
       (@mv_polynomial.X.{0 u} int α int.comm_semiring a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345  def free_comm_ring_pempty_equiv_int : free_comm_ring pempty.{u+1} ≃+* ℤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u) (β : Type) [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{0} β] [_inst_4 : has_add.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='`pempty` is the universe-polymorphic analogue of `empty`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346  ring_equiv.trans (free_comm_ring_equiv_mv_polynomial_int _) (mv_polynomial.pempty_ring_equiv _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring_equiv_mv_polynomial_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mv_polynomial.pempty_ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 481, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 295, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 1060, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{v} β] [_inst_4 : has_add.{v} β] [_inst_5 : has_mul.{w} γ] [_inst_6 : has_add.{w} γ], @ring_equiv.{u v} α β _inst_1 _inst_2 _inst_3 _inst_4 → @ring_equiv.{v w} β γ _inst_3 _inst_4 _inst_5 _inst_6 → @ring_equiv.{u w} α γ _inst_1 _inst_2 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u), @ring_equiv.{u u} (free_comm_ring.{u} α) (@mv_polynomial.{u 0} α int int.comm_semiring) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring) (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_1 : comm_semiring.{u} α], @ring_equiv.{(max u_1 u) u} (@mv_polynomial.{u_1 u} pempty.{u_1+1} α _inst_1) α (@mv_polynomial.has_mul.{u u_1} α pempty.{u_1+1} _inst_1) (@mv_polynomial.has_add.{u u_1} α pempty.{u_1+1} _inst_1) (@mul_zero_class.to_has_mul.{u} α (@semiring.to_mul_zero_class.{u} α (@comm_semiring.to_semiring.{u} α _inst_1))) (@distrib.to_has_add.{u} α (@semiring.to_distrib.{u} α (@comm_semiring.to_semiring.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Transitivity of `ring_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The ring isomorphism between multivariable polynomials in no variables and the ground ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348  def free_comm_ring_punit_equiv_polynomial_int : free_comm_ring punit.{u+1} ≃+* polynomial ℤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='punit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u) (β : Type) [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{0} β] [_inst_4 : has_add.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : comm_semiring.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='orange'><a title=' `polynomial α` is the type of univariate polynomials over `α`.

Polynomials should be seen as (semi-)rings with the additional constructor `X`.
The embedding from α is called `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  ring_equiv.trans (free_comm_ring_equiv_mv_polynomial_int _) (mv_polynomial.punit_ring_equiv _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_comm_ring_equiv_mv_polynomial_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mv_polynomial.punit_ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 481, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 295, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 1072, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{v} β] [_inst_4 : has_add.{v} β] [_inst_5 : has_mul.{w} γ] [_inst_6 : has_add.{w} γ], @ring_equiv.{u v} α β _inst_1 _inst_2 _inst_3 _inst_4 → @ring_equiv.{v w} β γ _inst_3 _inst_4 _inst_5 _inst_6 → @ring_equiv.{u w} α γ _inst_1 _inst_2 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u), @ring_equiv.{u u} (free_comm_ring.{u} α) (@mv_polynomial.{u 0} α int int.comm_semiring) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α)))) (@mv_polynomial.has_mul.{0 u} int α int.comm_semiring) (@mv_polynomial.has_add.{0 u} int α int.comm_semiring)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u) [_inst_1 : comm_semiring.{u} α], @ring_equiv.{(max u_1 u) u} (@mv_polynomial.{u_1 u} punit.{u_1+1} α _inst_1) (@polynomial.{u} α _inst_1) (@mv_polynomial.has_mul.{u u_1} α punit.{u_1+1} _inst_1) (@mv_polynomial.has_add.{u u_1} α punit.{u_1+1} _inst_1) (@polynomial.has_mul.{u} α _inst_1) (@polynomial.has_add.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Transitivity of `ring_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The ring isomorphism between multivariable polynomials in a single variable and
polynomials over the ground ring.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351  open free_ring</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  def free_ring_pempty_equiv_int : free_ring pempty.{u+1} ≃+* ℤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u) (β : Type) [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{0} β] [_inst_4 : has_add.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='`pempty` is the universe-polymorphic analogue of `empty`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  ring_equiv.trans (subsingleton_equiv_free_comm_ring _) free_comm_ring_pempty_equiv_int</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_ring.subsingleton_equiv_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring_pempty_equiv_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 481, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 345, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{v} β] [_inst_4 : has_add.{v} β] [_inst_5 : has_mul.{w} γ] [_inst_6 : has_add.{w} γ], @ring_equiv.{u v} α β _inst_1 _inst_2 _inst_3 _inst_4 → @ring_equiv.{v w} β γ _inst_3 _inst_4 _inst_5 _inst_6 → @ring_equiv.{u w} α γ _inst_1 _inst_2 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_1 : subsingleton.{u+1} α], @ring_equiv.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@ring_equiv.{u 0} (free_comm_ring.{u} pempty.{u+1}) int (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} pempty.{u+1}) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} pempty.{u+1}) (@ring.to_semiring.{u} (free_comm_ring.{u} pempty.{u+1}) (@comm_ring.to_ring.{u} (free_comm_ring.{u} pempty.{u+1}) (free_comm_ring.comm_ring.{u} pempty.{u+1}))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} pempty.{u+1}) (@ring.to_distrib.{u} (free_comm_ring.{u} pempty.{u+1}) (@comm_ring.to_ring.{u} (free_comm_ring.{u} pempty.{u+1}) (free_comm_ring.comm_ring.{u} pempty.{u+1})))) int.has_mul int.has_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Transitivity of `ring_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  def free_ring_punit_equiv_polynomial_int : free_ring punit.{u+1} ≃+* polynomial ℤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='free_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='punit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ring_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/free_ring.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/polynomial.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Sort u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (α : Type u) (β : Type) [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{0} β] [_inst_4 : has_add.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : comm_semiring.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='orange'><a title=' `polynomial α` is the type of univariate polynomials over `α`.

Polynomials should be seen as (semi-)rings with the additional constructor `X`.
The embedding from α is called `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  ring_equiv.trans (subsingleton_equiv_free_comm_ring _) free_comm_ring_punit_equiv_polynomial_int</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ring_equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='free_ring.subsingleton_equiv_free_comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='free_comm_ring_punit_equiv_polynomial_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/algebra.lean&#x27;, &#x27;line&#x27;: 481, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 273, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 348, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : has_mul.{u} α] [_inst_2 : has_add.{u} α] [_inst_3 : has_mul.{v} β] [_inst_4 : has_add.{v} β] [_inst_5 : has_mul.{w} γ] [_inst_6 : has_add.{w} γ], @ring_equiv.{u v} α β _inst_1 _inst_2 _inst_3 _inst_4 → @ring_equiv.{v w} β γ _inst_3 _inst_4 _inst_5 _inst_6 → @ring_equiv.{u w} α γ _inst_1 _inst_2 _inst_5 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_1 : subsingleton.{u+1} α], @ring_equiv.{u u} (free_ring.{u} α) (free_comm_ring.{u} α) (@mul_zero_class.to_has_mul.{u} (free_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_ring.{u} α) (@ring.to_semiring.{u} (free_ring.{u} α) (free_ring.ring.{u} α)))) (@distrib.to_has_add.{u} (free_ring.{u} α) (@ring.to_distrib.{u} (free_ring.{u} α) (free_ring.ring.{u} α))) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} α) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} α) (@ring.to_semiring.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} α) (@ring.to_distrib.{u} (free_comm_ring.{u} α) (@comm_ring.to_ring.{u} (free_comm_ring.{u} α) (free_comm_ring.comm_ring.{u} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@ring_equiv.{u 0} (free_comm_ring.{u} punit.{u+1}) (@polynomial.{0} int int.comm_semiring) (@mul_zero_class.to_has_mul.{u} (free_comm_ring.{u} punit.{u+1}) (@semiring.to_mul_zero_class.{u} (free_comm_ring.{u} punit.{u+1}) (@ring.to_semiring.{u} (free_comm_ring.{u} punit.{u+1}) (@comm_ring.to_ring.{u} (free_comm_ring.{u} punit.{u+1}) (free_comm_ring.comm_ring.{u} punit.{u+1}))))) (@distrib.to_has_add.{u} (free_comm_ring.{u} punit.{u+1}) (@ring.to_distrib.{u} (free_comm_ring.{u} punit.{u+1}) (@comm_ring.to_ring.{u} (free_comm_ring.{u} punit.{u+1}) (free_comm_ring.comm_ring.{u} punit.{u+1})))) (@polynomial.has_mul.{0} int int.comm_semiring) (@polynomial.has_add.{0} int int.comm_semiring)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Transitivity of `ring_equiv`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font></pre>
</body>