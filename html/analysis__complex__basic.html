<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) Sébastien Gouëzel. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Sébastien Gouëzel</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import analysis.calculus.deriv analysis.normed_space.finite_dimension</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/finite_dimension.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  # Normed space structure on `ℂ`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  This file gathers basic facts on complex numbers of an analytic nature.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  ## Main results</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  This file registers `ℂ` as a normed field, expresses basic properties of the norm, and gives</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  tools on the real vector space structure of `ℂ`. Notably, in the namespace `complex`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  it defines functions:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  * `linear_map.re`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  * `continuous_linear_map.re`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  * `linear_map.im`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  * `continuous_linear_map.im`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  * `linear_map.of_real`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  * `continuous_linear_map.of_real`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  They are bundled versions of the real part, the imaginary part, and the embedding of `ℝ` in `ℂ`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  as `ℝ`-linear maps.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  `has_deriv_at_real_of_complex` expresses that, if a function on `ℂ` is differentiable (over `ℂ`),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  then its restriction to `ℝ` is differentiable over `ℝ`, with derivative the real part of the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  complex derivative.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  set_option class.instance_max_depth 40</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  namespace complex</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  instance : normed_field ℂ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  { norm := abs,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    dist_eq := λ _ _, rfl,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    norm_mul&#x27; := abs_mul,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    .. complex.discrete_field }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  instance : nondiscrete_normed_field ℂ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  { non_trivial := ⟨2, by simp [norm]; norm_num⟩ }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  instance normed_algebra_over_reals : normed_algebra ℝ ℂ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  { norm_algebra_map_eq := abs_of_real,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    ..complex.algebra_over_reals }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  @[simp] lemma norm_eq_abs (z : ℂ) : ∥z∥ = abs z := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  @[simp] lemma norm_real (r : ℝ) : ∥(r : ℂ)∥ = ∥r∥ := abs_of_real _</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  @[simp] lemma norm_rat (r : ℚ) : ∥(r : ℂ)∥ = _root_.abs (r : ℝ) :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  suffices ∥((r : ℝ) : ℂ)∥ = _root_.abs r, by simpa,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  by rw [norm_real, real.norm_eq_abs]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='complex.norm_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='real.norm_eq_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 565, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (r : real), @eq.{1} real (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field) (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) r)) (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (r : real), @eq.{1} real (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) r) (@abs.{0} real real.decidable_linear_ordered_comm_group r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='r : rat
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
          (@coe.{1 1} rat real
             (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
             r)))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} rat real
          (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
          r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='r : rat
⊢ @eq.{1} real
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe.{1 1} rat real
          (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
          r))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} rat real
          (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
          r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='r : rat
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
          (@coe.{1 1} rat real
             (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
             r)))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} rat real
          (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
          r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='r : rat
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
          (@coe.{1 1} rat real
             (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
             r)))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} rat real
          (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring)))
          r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  @[simp] lemma norm_nat (n : ℕ) : ∥(n : ℂ)∥ = n := abs_of_nat _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex.abs_of_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 334, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (n : nat), @eq.{1} real (complex.abs (@coe.{1 1} nat complex (@coe_to_lift.{1 1} nat complex (@coe_base.{1 1} nat complex (@nat.cast_coe.{0} complex complex.has_zero complex.has_one complex.has_add))) n)) (@coe.{1 1} nat real (@coe_to_lift.{1 1} nat real (@coe_base.{1 1} nat real (@nat.cast_coe.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)) (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))))) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  @[simp] lemma norm_int {n : ℤ} : ∥(n : ℂ)∥ = _root_.abs n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_ordered_comm_group.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  suffices ∥((n : ℝ) : ℂ)∥ = _root_.abs n, by simpa,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='lime'><a title='n : int,
this :
  @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
          (@coe.{1 1} int real
             (@coe_to_lift.{1 1} int real
                (@coe_base.{1 1} int real
                   (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                      (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                      (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                      (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
             n)))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} int complex
          (@coe_to_lift.{1 1} int complex
             (@coe_base.{1 1} int complex
                (@int.cast_coe.{0} complex complex.has_neg complex.has_zero complex.has_one complex.has_add)))
          n))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  by rw [norm_real, real.norm_eq_abs]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='complex.norm_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='real.norm_eq_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 565, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (r : real), @eq.{1} real (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field) (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) r)) (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (r : real), @eq.{1} real (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) r) (@abs.{0} real real.decidable_linear_ordered_comm_group r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : int
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
          (@coe.{1 1} int real
             (@coe_to_lift.{1 1} int real
                (@coe_base.{1 1} int real
                   (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                      (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                      (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                      (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
             n)))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : int
⊢ @eq.{1} real
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : int
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
          (@coe.{1 1} int real
             (@coe_to_lift.{1 1} int real
                (@coe_base.{1 1} int real
                   (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                      (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                      (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                      (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
             n)))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : int
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
          (@coe.{1 1} int real
             (@coe_to_lift.{1 1} int real
                (@coe_base.{1 1} int real
                   (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                      (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                      (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                      (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
             n)))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  lemma norm_int_of_nonneg {n : ℤ} (hn : 0 ≤ n) : ∥(n : ℂ)∥ = n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='int'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  by rw [norm_int, _root_.abs_of_nonneg]; exact int.cast_nonneg.2 hn</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='complex.norm_int'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='abs_of_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='int.cast_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1159, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : int}, @eq.{1} real (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field) (@coe.{1 1} int complex (@coe_to_lift.{1 1} int complex (@coe_base.{1 1} int complex (@int.cast_coe.{0} complex complex.has_neg complex.has_zero complex.has_one complex.has_add))) n)) (@abs.{0} real real.decidable_linear_ordered_comm_group (@coe.{1 1} int real (@coe_to_lift.{1 1} int real (@coe_base.{1 1} int real (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)) (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] {a : α}, @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} α _inst_1)))) a (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) → @eq.{1} α (@abs.{0} α _inst_1 a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_ring.{0} α] {n : int}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α _inst_1))))))) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1)))) (@coe.{1 1} int α (@coe_to_lift.{1 1} int α (@coe_base.{1 1} int α (@int.cast_coe.{0} α (@add_group.to_has_neg.{0} α (@add_comm_group.to_add_group.{0} α (@ring.to_add_comm_group.{0} α (@domain.to_ring.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))))) (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))) (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))) (@distrib.to_has_add.{0} α (@ring.to_distrib.{0} α (@domain.to_ring.{0} α (@linear_ordered_ring.to_domain.{0} α _inst_1))))))) n)) (@has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : int,
hn : @has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) n
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} int complex
          (@coe_to_lift.{1 1} int complex
             (@coe_base.{1 1} int complex
                (@int.cast_coe.{0} complex complex.has_neg complex.has_zero complex.has_one complex.has_add)))
          n))
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : int,
hn : @has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) n
⊢ @eq.{1} real
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@coe.{1 1} int real
          (@coe_to_lift.{1 1} int real
             (@coe_base.{1 1} int real
                (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                   (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
          n))
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : int,
hn : @has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) n
⊢ @ge.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_group.to_partial_order.{0} real
             (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} real
                real.decidable_linear_ordered_comm_group))))
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       n)
    (@has_zero.zero.{0} real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} real
                   real.decidable_linear_ordered_comm_group)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : int,
hn : @has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) n
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} int complex
          (@coe_to_lift.{1 1} int complex
             (@coe_base.{1 1} int complex
                (@int.cast_coe.{0} complex complex.has_neg complex.has_zero complex.has_one complex.has_add)))
          n))
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : int,
hn : @has_le.le.{0} int int.has_le (@has_zero.zero.{0} int int.has_zero) n
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe.{1 1} int complex
          (@coe_to_lift.{1 1} int complex
             (@coe_base.{1 1} int complex
                (@int.cast_coe.{0} complex complex.has_neg complex.has_zero complex.has_one complex.has_add)))
          n))
    (@coe.{1 1} int real
       (@coe_to_lift.{1 1} int real
          (@coe_base.{1 1} int real
             (@int.cast_coe.{0} real (@add_group.to_has_neg.{0} real real.add_group)
                (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))
                (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)))))
       n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  /-- Over the complex numbers, any finite-dimensional spaces is proper (and therefore complete).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  We can register this as an instance, as it will not cause problems in instance resolution since</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  the properness of `ℂ` is already known and there is no metavariable. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  instance finite_dimensional.proper</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    (E : Type) [normed_group E] [normed_space ℂ E] [finite_dimensional ℂ E] : proper_space E :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finite_dimensional'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='proper_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finite_dimensional.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1090, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α β : Type) [_inst_1 : normed_field.{0} α] [_inst_2 : normed_group.{0} β], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (K V : Type) [_inst_6 : discrete_field.{0} K] [_inst_7 : add_comm_group.{0} V] [_inst_8 : @vector_space.{0 0} K V _inst_6 _inst_7], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : metric_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' `finite_dimensional` vector spaces are defined to be noetherian modules.
Use `finite_dimensional.iff_fg` or `finite_dimensional.of_finite_basis` to prove finite dimension
from a conventional definition.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A metric space is proper if all closed balls are compact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  finite_dimensional.proper ℂ E</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finite_dimensional.proper'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/finite_dimension.lean&#x27;, &#x27;line&#x27;: 241, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (𝕜 : Type u) [_inst_1 : nondiscrete_normed_field.{u} 𝕜] (E : Type v) [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] [_inst_4 : @proper_space.{u} 𝕜 (@normed_field.to_metric_space.{u} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1))] [_inst_5 : @finite_dimensional.{u v} 𝕜 E (@normed_field.to_discrete_field.{u} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1)) (@normed_group.to_add_comm_group.{v} E _inst_2) (@normed_space.to_module.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2 _inst_3)], @proper_space.{v} E (@normed_group.to_metric_space.{v} E _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Any finite-dimensional vector space over a proper field is proper.
We do not register this as an instance to avoid an instance loop when trying to prove the
properness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance
explicitly when needed.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  attribute [instance, priority 900] complex.finite_dimensional.proper</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='complex.finite_dimensional.proper'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='∀ (E : Type) [_inst_1 : normed_group.{0} E] [_inst_2 : @normed_space.{0 0} complex E complex.normed_field _inst_1] [_inst_3 : @finite_dimensional.{0 0} complex E complex.discrete_field (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_space.to_module.{0 0} complex E complex.normed_field _inst_1 _inst_2)], @proper_space.{0} E (@normed_group.to_metric_space.{0} E _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title=' Over the complex numbers, any finite-dimensional spaces is proper (and therefore complete).
We can register this as an instance, as it will not cause problems in instance resolution since
the properness of `ℂ` is already known and there is no metavariable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  /-- A complex normed vector space is also a real normed vector space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  instance normed_space.restrict_scalars_real (E : Type*) [normed_group E] [normed_space ℂ E] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type) (β : Type u_1) [_inst_1 : normed_field.{0} α] [_inst_2 : normed_group.{u_1} β], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    normed_space ℝ E := normed_space.restrict_scalars ℝ ℂ</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='normed_space.restrict_scalars'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 743, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_5) (β : Type u_6) [_inst_1 : normed_field.{u_5} α] [_inst_2 : normed_group.{u_6} β], Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (𝕜 : Type u_5) (𝕜&#x27; : Type u_6) [_inst_1 : normed_field.{u_5} 𝕜] [_inst_2 : normed_field.{u_6} 𝕜&#x27;] [_inst_3 : @normed_algebra.{u_5 u_6} 𝕜 𝕜&#x27; _inst_1 (@normed_field.to_normed_ring.{u_6} 𝕜&#x27; _inst_2)] {E : Type u_7} [_inst_4 : normed_group.{u_7} E] [_inst_5 : @normed_space.{u_6 u_7} 𝕜&#x27; E _inst_2 _inst_4], @normed_space.{u_5 u_7} 𝕜 E _inst_1 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' `𝕜`-normed space structure induced by a `𝕜&#x27;`-normed space structure when `𝕜&#x27;` is a
normed algebra over `𝕜`. Not registered as an instance as `𝕜&#x27;` can not be inferred.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  attribute [instance, priority 900] complex.normed_space.restrict_scalars_real</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='complex.normed_space.restrict_scalars_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 78, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Π (E : Type u_1) [_inst_1 : normed_group.{u_1} E] [_inst_2 : @normed_space.{0 u_1} complex E complex.normed_field _inst_1], @normed_space.{0 u_1} real E normed_field.normed_field _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A complex normed vector space is also a real normed vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  /-- Linear map version of the real part function, from `ℂ` to `ℝ`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  def linear_map.re : ℂ →ₗ[ℝ] ℝ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  { to_fun := λx, x.re,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    add := by simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='⊢ ∀ (x y : complex),
    @eq.{1} real
      ((@has_add.add.{0} complex
          (@add_semigroup.to_has_add.{0} complex
             (@add_monoid.to_add_semigroup.{0} complex
                (@add_group.to_add_monoid.{0} complex
                   (@add_comm_group.to_add_group.{0} complex
                      (@normed_group.to_add_comm_group.{0} complex
                         (@normed_ring.to_normed_group.{0} complex
                            (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))))
          x
          y).re)
      (@has_add.add.{0} real
         (@add_semigroup.to_has_add.{0} real
            (@add_monoid.to_add_semigroup.{0} real
               (@add_group.to_add_monoid.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))))
         (x.re)
         (y.re))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    smul := λc x, by { change ((c : ℂ) * x).re = c * x.re, simp } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='c : real,
x : complex
⊢ @eq.{1} real
    ((@has_scalar.smul.{0 0} real complex
        (@mul_action.to_has_scalar.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
           (@distrib_mul_action.to_mul_action.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
              (@add_group.to_add_monoid.{0} complex
                 (@add_comm_group.to_add_group.{0} complex
                    (@normed_group.to_add_comm_group.{0} complex
                       (@normed_ring.to_normed_group.{0} complex
                          (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
              (@semimodule.to_distrib_mul_action.{0 0} real complex (@ring.to_semiring.{0} real real.ring)
                 (@add_comm_group.to_add_comm_monoid.{0} complex
                    (@normed_group.to_add_comm_group.{0} complex
                       (@normed_ring.to_normed_group.{0} complex
                          (@normed_field.to_normed_ring.{0} complex complex.normed_field))))
                 (@module.to_semimodule.{0 0} real complex real.ring
                    (@normed_group.to_add_comm_group.{0} complex
                       (@normed_ring.to_normed_group.{0} complex
                          (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                    (@module.complex_to_real.{0} complex
                       (@normed_group.to_add_comm_group.{0} complex
                          (@normed_ring.to_normed_group.{0} complex
                             (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                       (@discrete_field.to_vector_space.{0} complex complex.discrete_field))))))
        c
        x).re)
    (@has_scalar.smul.{0 0} real real
       (@mul_action.to_has_scalar.{0 0} real real (@ring.to_monoid.{0} real real.ring)
          (@distrib_mul_action.to_mul_action.{0 0} real real (@ring.to_monoid.{0} real real.ring)
             (@add_group.to_add_monoid.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
             (@semimodule.to_distrib_mul_action.{0 0} real real (@ring.to_semiring.{0} real real.ring)
                (@add_comm_group.to_add_comm_monoid.{0} real real.add_comm_group)
                (@module.to_semimodule.{0 0} real real real.ring real.add_comm_group
                   (@discrete_field.to_vector_space.{0} real real.discrete_field)))))
       c
       (x.re))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
x : complex
⊢ @eq.{1} real
    ((@has_mul.mul.{0} complex complex.has_mul
        (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) c)
        x).re)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) c
       (x.re))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  @[simp] lemma linear_map.re_apply (z : ℂ) : linear_map.re z = z.re := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex.linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@linear_map.{0 0 0} real complex real real.ring (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='Linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  /-- Continuous linear map version of the real part function, from `ℂ` to `ℝ`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  def continuous_linear_map.re : ℂ →L[ℝ] ℝ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  linear_map.re.mk_continuous 1 $ λx, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.mk_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@linear_map.{0 0 0} real complex real real.ring (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E _inst_4 _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F _inst_4 _inst_2] (f : @linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) (C : real), (∀ (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) (@linear_map.has_coe_to_fun.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) f x)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) C (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x))) → @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Construct a continuous linear map from a linear map and a bound on this linear map.
The fact that the norm of the continuous linear map is then controlled is given in
`linear_map.mk_continuous_norm_le`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} real
       (@normed_group.to_has_norm.{0} real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
       (@coe_fn.{1 1}
          (@linear_map.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          (@linear_map.has_coe_to_fun.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          complex.linear_map.re
          x))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@has_norm.norm.{0} complex
          (@normed_group.to_has_norm.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    change _root_.abs (x.re) ≤ 1 * abs x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} real
       (@normed_group.to_has_norm.{0} real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
       (@coe_fn.{1 1}
          (@linear_map.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          (@linear_map.has_coe_to_fun.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          complex.linear_map.re
          x))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@has_norm.norm.{0} complex
          (@normed_group.to_has_norm.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.re))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (complex.abs x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    rw one_mul,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.re))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (complex.abs x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.re)) (complex.abs x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    exact abs_re_le_abs x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='complex.abs_re_le_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (z : complex), @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (z.re)) (complex.abs z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.re)) (complex.abs x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  @[simp] lemma continuous_linear_map.re_coe :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    (coe (continuous_linear_map.re) : ℂ →ₗ[ℝ] ℝ) = linear_map.re := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.continuous_linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 83, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@linear_map.{0 0 0} real complex real real.ring (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  @[simp] lemma continuous_linear_map.re_apply (z : ℂ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    (continuous_linear_map.re : ℂ → ℝ) z = z.re := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex.continuous_linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  @[simp] lemma continuous_linear_map.re_norm :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    ∥continuous_linear_map.re∥ = 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.continuous_linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
       complex.continuous_linear_map.re)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    apply le_antisymm (linear_map.mk_continuous_norm_le _ zero_le_one _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.mk_continuous_norm_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='zero_le_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 520, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : nondiscrete_normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2] (f : @linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) {C : real}, @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) C → ∀ (h : ∀ (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@linear_map.has_coe_to_fun.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f x)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) C (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x))), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.has_op_norm.{0 0 0} 𝕜 E F _inst_1 _inst_2 _inst_4 _inst_5 _inst_6) (@linear_map.mk_continuous.{0 0 0} 𝕜 E F _inst_1 _inst_2 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_5 _inst_6 f C h)) C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α], @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' If a continuous linear map is constructed from a linear map via the constructor `mk_continuous`,
then its norm is bounded by the bound given to the constructor if it is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
       complex.continuous_linear_map.re)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field))
       (@linear_map.mk_continuous.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          complex.linear_map.re
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.re._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    calc 1 = ∥continuous_linear_map.re (1 : ℂ)∥ : by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field))
       (@linear_map.mk_continuous.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          complex.linear_map.re
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.re._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re
          (@has_one.one.{0} complex complex.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109      ... ≤ ∥continuous_linear_map.re∥ : by { apply continuous_linear_map.unit_le_op_norm, simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='complex.continuous_linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='continuous_linear_map.unit_le_op_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 224, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : nondiscrete_normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2] (f : @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) → @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.to_fun.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f x)) (@has_norm.norm.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.has_op_norm.{0 0 0} 𝕜 E F _inst_1 _inst_2 _inst_4 _inst_5 _inst_6) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The image of the unit ball under a continuous linear map is bounded.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re
          (@has_one.one.{0} complex complex.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field))
       (@linear_map.mk_continuous.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          complex.linear_map.re
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.re._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re
          (@has_one.one.{0} complex complex.has_one)))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
       complex.continuous_linear_map.re)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} complex
       (@normed_group.to_has_norm.{0} complex
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
       (@has_one.one.{0} complex complex.has_one))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  /-- Linear map version of the imaginary part function, from `ℂ` to `ℝ`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  def linear_map.im : ℂ →ₗ[ℝ] ℝ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  { to_fun := λx, x.im,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    add := by simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='⊢ ∀ (x y : complex),
    @eq.{1} real
      ((@has_add.add.{0} complex
          (@add_semigroup.to_has_add.{0} complex
             (@add_monoid.to_add_semigroup.{0} complex
                (@add_group.to_add_monoid.{0} complex
                   (@add_comm_group.to_add_group.{0} complex
                      (@normed_group.to_add_comm_group.{0} complex
                         (@normed_ring.to_normed_group.{0} complex
                            (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))))
          x
          y).im)
      (@has_add.add.{0} real
         (@add_semigroup.to_has_add.{0} real
            (@add_monoid.to_add_semigroup.{0} real
               (@add_group.to_add_monoid.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))))
         (x.im)
         (y.im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    smul := λc x, by { change ((c : ℂ) * x).im = c * x.im, simp } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='c : real,
x : complex
⊢ @eq.{1} real
    ((@has_scalar.smul.{0 0} real complex
        (@mul_action.to_has_scalar.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
           (@distrib_mul_action.to_mul_action.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
              (@add_group.to_add_monoid.{0} complex
                 (@add_comm_group.to_add_group.{0} complex
                    (@normed_group.to_add_comm_group.{0} complex
                       (@normed_ring.to_normed_group.{0} complex
                          (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
              (@semimodule.to_distrib_mul_action.{0 0} real complex (@ring.to_semiring.{0} real real.ring)
                 (@add_comm_group.to_add_comm_monoid.{0} complex
                    (@normed_group.to_add_comm_group.{0} complex
                       (@normed_ring.to_normed_group.{0} complex
                          (@normed_field.to_normed_ring.{0} complex complex.normed_field))))
                 (@module.to_semimodule.{0 0} real complex real.ring
                    (@normed_group.to_add_comm_group.{0} complex
                       (@normed_ring.to_normed_group.{0} complex
                          (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                    (@module.complex_to_real.{0} complex
                       (@normed_group.to_add_comm_group.{0} complex
                          (@normed_ring.to_normed_group.{0} complex
                             (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                       (@discrete_field.to_vector_space.{0} complex complex.discrete_field))))))
        c
        x).im)
    (@has_scalar.smul.{0 0} real real
       (@mul_action.to_has_scalar.{0 0} real real (@ring.to_monoid.{0} real real.ring)
          (@distrib_mul_action.to_mul_action.{0 0} real real (@ring.to_monoid.{0} real real.ring)
             (@add_group.to_add_monoid.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
             (@semimodule.to_distrib_mul_action.{0 0} real real (@ring.to_semiring.{0} real real.ring)
                (@add_comm_group.to_add_comm_monoid.{0} real real.add_comm_group)
                (@module.to_semimodule.{0 0} real real real.ring real.add_comm_group
                   (@discrete_field.to_vector_space.{0} real real.discrete_field)))))
       c
       (x.im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
x : complex
⊢ @eq.{1} real
    ((@has_mul.mul.{0} complex complex.has_mul
        (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) c)
        x).im)
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) c
       (x.im))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  @[simp] lemma linear_map.im_apply (z : ℂ) : linear_map.im z = z.im := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex.linear_map.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@linear_map.{0 0 0} real complex real real.ring (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='Linear map version of the imaginary part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  /-- Continuous linear map version of the real part function, from `ℂ` to `ℝ`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  def continuous_linear_map.im : ℂ →L[ℝ] ℝ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  linear_map.im.mk_continuous 1 $ λx, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.linear_map.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.mk_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@linear_map.{0 0 0} real complex real real.ring (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E _inst_4 _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F _inst_4 _inst_2] (f : @linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) (C : real), (∀ (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) (@linear_map.has_coe_to_fun.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) f x)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) C (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x))) → @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Linear map version of the imaginary part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Construct a continuous linear map from a linear map and a bound on this linear map.
The fact that the norm of the continuous linear map is then controlled is given in
`linear_map.mk_continuous_norm_le`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} real
       (@normed_group.to_has_norm.{0} real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
       (@coe_fn.{1 1}
          (@linear_map.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          (@linear_map.has_coe_to_fun.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          complex.linear_map.im
          x))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@has_norm.norm.{0} complex
          (@normed_group.to_has_norm.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    change _root_.abs (x.im) ≤ 1 * abs x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} real
       (@normed_group.to_has_norm.{0} real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
       (@coe_fn.{1 1}
          (@linear_map.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          (@linear_map.has_coe_to_fun.{0 0 0} real complex real
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
          complex.linear_map.im
          x))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@has_norm.norm.{0} complex
          (@normed_group.to_has_norm.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (complex.abs x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    rw one_mul,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (complex.abs x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im)) (complex.abs x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    exact complex.abs_im_le_abs x</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='complex.abs_im_le_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 366, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (z : complex), @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (z.im)) (complex.abs z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : complex
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (x.im)) (complex.abs x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  @[simp] lemma continuous_linear_map.im_coe :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    (coe (continuous_linear_map.im) : ℂ →ₗ[ℝ] ℝ) = linear_map.im := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.continuous_linear_map.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.linear_map.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@linear_map.{0 0 0} real complex real real.ring (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Linear map version of the imaginary part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  @[simp] lemma continuous_linear_map.im_apply (z : ℂ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    (continuous_linear_map.im : ℂ → ℝ) z = z.im := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex.continuous_linear_map.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  @[simp] lemma continuous_linear_map.im_norm :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    ∥continuous_linear_map.im∥ = 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.continuous_linear_map.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
       complex.continuous_linear_map.im)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    apply le_antisymm (linear_map.mk_continuous_norm_le _ zero_le_one _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.mk_continuous_norm_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='zero_le_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 520, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : nondiscrete_normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2] (f : @linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) {C : real}, @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) C → ∀ (h : ∀ (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@linear_map.has_coe_to_fun.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f x)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) C (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x))), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.has_op_norm.{0 0 0} 𝕜 E F _inst_1 _inst_2 _inst_4 _inst_5 _inst_6) (@linear_map.mk_continuous.{0 0 0} 𝕜 E F _inst_1 _inst_2 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_5 _inst_6 f C h)) C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α], @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' If a continuous linear map is constructed from a linear map via the constructor `mk_continuous`,
then its norm is bounded by the bound given to the constructor if it is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
       complex.continuous_linear_map.im)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field))
       (@linear_map.mk_continuous.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          complex.linear_map.im
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.im._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    calc 1 = ∥continuous_linear_map.im (I : ℂ)∥ : by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='complex.I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field))
       (@linear_map.mk_continuous.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          complex.linear_map.im
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.im._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.im
          complex.I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139      ... ≤ ∥continuous_linear_map.im∥ :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='complex.continuous_linear_map.im'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 121, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.im
          complex.I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field))
       (@linear_map.mk_continuous.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          complex.linear_map.im
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.im._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140        by { apply continuous_linear_map.unit_le_op_norm, rw ← abs_I, exact le_refl _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='continuous_linear_map.unit_le_op_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='complex.abs_I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 224, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 343, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : nondiscrete_normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2] (f : @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) → @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.to_fun.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f x)) (@has_norm.norm.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.has_op_norm.{0 0 0} 𝕜 E F _inst_1 _inst_2 _inst_4 _inst_5 _inst_6) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real (complex.abs complex.I) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The image of the unit ball under a continuous linear map is bounded.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field))
       (@linear_map.mk_continuous.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          complex.linear_map.im
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.im._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.im
          complex.I))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_op_norm.{0 0 0} real complex real
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          normed_field.nondiscrete_normed_field
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
       complex.continuous_linear_map.im)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} complex
       (@normed_group.to_has_norm.{0} complex
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
       complex.I)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} complex
       (@normed_group.to_has_norm.{0} complex
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
       complex.I)
    (complex.abs complex.I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  /-- Linear map version of the canonical embedding of `ℝ` in `ℂ`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  def linear_map.of_real : ℝ →ₗ[ℝ] ℂ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  { to_fun := λx, of_real x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real → complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    add := by simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='⊢ ∀ (x y : real),
    @eq.{1} complex
      (complex.of_real
         (@has_add.add.{0} real
            (@add_semigroup.to_has_add.{0} real
               (@add_monoid.to_add_semigroup.{0} real
                  (@add_group.to_add_monoid.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))))
            x
            y))
      (@has_add.add.{0} complex
         (@add_semigroup.to_has_add.{0} complex
            (@add_monoid.to_add_semigroup.{0} complex
               (@add_group.to_add_monoid.{0} complex
                  (@add_comm_group.to_add_group.{0} complex
                     (@normed_group.to_add_comm_group.{0} complex
                        (@normed_ring.to_normed_group.{0} complex
                           (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))))
         (complex.of_real x)
         (complex.of_real y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    smul := λc x, by { simp, refl } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='c x : real
⊢ @eq.{1} complex
    (complex.of_real
       (@has_scalar.smul.{0 0} real real
          (@mul_action.to_has_scalar.{0 0} real real (@ring.to_monoid.{0} real real.ring)
             (@distrib_mul_action.to_mul_action.{0 0} real real (@ring.to_monoid.{0} real real.ring)
                (@add_group.to_add_monoid.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
                (@semimodule.to_distrib_mul_action.{0 0} real real (@ring.to_semiring.{0} real real.ring)
                   (@add_comm_group.to_add_comm_monoid.{0} real real.add_comm_group)
                   (@module.to_semimodule.{0 0} real real real.ring real.add_comm_group
                      (@discrete_field.to_vector_space.{0} real real.discrete_field)))))
          c
          x))
    (@has_scalar.smul.{0 0} real complex
       (@mul_action.to_has_scalar.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
          (@distrib_mul_action.to_mul_action.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
             (@add_group.to_add_monoid.{0} complex
                (@add_comm_group.to_add_group.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@semimodule.to_distrib_mul_action.{0 0} real complex (@ring.to_semiring.{0} real real.ring)
                (@add_comm_group.to_add_comm_monoid.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field))))
                (@module.to_semimodule.{0 0} real complex real.ring
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@module.complex_to_real.{0} complex
                      (@normed_group.to_add_comm_group.{0} complex
                         (@normed_ring.to_normed_group.{0} complex
                            (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                      (@discrete_field.to_vector_space.{0} complex complex.discrete_field))))))
       c
       (complex.of_real x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c x : real
⊢ @eq.{1} complex
    (@has_mul.mul.{0} complex complex.has_mul
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) c)
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) x))
    (@has_scalar.smul.{0 0} real complex
       (@mul_action.to_has_scalar.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
          (@distrib_mul_action.to_mul_action.{0 0} real complex (@ring.to_monoid.{0} real real.ring)
             (@add_group.to_add_monoid.{0} complex
                (@add_comm_group.to_add_group.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@semimodule.to_distrib_mul_action.{0 0} real complex (@ring.to_semiring.{0} real real.ring)
                (@add_comm_group.to_add_comm_monoid.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field))))
                (@module.to_semimodule.{0 0} real complex real.ring
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@module.complex_to_real.{0} complex
                      (@normed_group.to_add_comm_group.{0} complex
                         (@normed_ring.to_normed_group.{0} complex
                            (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                      (@discrete_field.to_vector_space.{0} complex complex.discrete_field))))))
       c
       (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  @[simp] lemma linear_map.of_real_apply (x : ℝ) : linear_map.of_real x = x := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex.linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@linear_map.{0 0 0} real real complex real.ring real.add_comm_group (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='Linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  /-- Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  def continuous_linear_map.of_real : ℝ →L[ℝ] ℂ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  linear_map.of_real.mk_continuous 1 $ λx, by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map.mk_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@linear_map.{0 0 0} real real complex real.ring real.add_comm_group (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E _inst_4 _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F _inst_4 _inst_2] (f : @linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) (C : real), (∀ (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) (@linear_map.has_coe_to_fun.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)) f x)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) C (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x))) → @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_4)) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E _inst_4 _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F _inst_4 _inst_2 _inst_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Construct a continuous linear map from a linear map and a bound on this linear map.
The fact that the norm of the continuous linear map is then controlled is given in
`linear_map.mk_continuous_norm_le`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='lime'><a title='x : real
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} complex
       (@normed_group.to_has_norm.{0} complex
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
       (@coe_fn.{1 1}
          (@linear_map.{0 0 0} real real complex
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field))))
          (@linear_map.has_coe_to_fun.{0 0 0} real real complex
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field))))
          complex.linear_map.of_real
          x))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@has_norm.norm.{0} real
          (@normed_group.to_has_norm.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='x : real
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} complex
       (@normed_group.to_has_norm.{0} complex
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
       (@coe_fn.{1 1}
          (@linear_map.{0 0 0} real real complex
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field))))
          (@linear_map.has_coe_to_fun.{0 0 0} real real complex
             (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real normed_field.normed_field
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real normed_field.normed_field))
             (@normed_space.to_module.{0 0} real complex normed_field.normed_field
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field))))
          complex.linear_map.of_real
          x))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
       (@has_norm.norm.{0} real
          (@normed_group.to_has_norm.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  @[simp] lemma continuous_linear_map.of_real_coe :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    (coe (continuous_linear_map.of_real) : ℝ →ₗ[ℝ] ℂ) = linear_map.of_real := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β γ : Type) [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{0} β] [_inst_3 : add_comm_group.{0} γ] [_inst_4 : @module.{0 0} α β _inst_1 _inst_2] [_inst_5 : @module.{0 0} α γ _inst_1 _inst_3], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@linear_map.{0 0 0} real real complex real.ring real.add_comm_group (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  @[simp] lemma continuous_linear_map.of_real_apply (x : ℝ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    (continuous_linear_map.of_real : ℝ → ℂ) x = x := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  @[simp] lemma continuous_linear_map.of_real_norm :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    ∥continuous_linear_map.of_real∥ = 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          normed_field.nondiscrete_normed_field
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field)))
       complex.continuous_linear_map.of_real)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164    apply le_antisymm (linear_map.mk_continuous_norm_le _ zero_le_one _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.mk_continuous_norm_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='zero_le_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 520, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : nondiscrete_normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2] (f : @linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) {C : real}, @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) C → ∀ (h : ∀ (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@linear_map.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@linear_map.has_coe_to_fun.{0 0 0} 𝕜 E F (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) (@normed_group.to_add_comm_group.{0} E _inst_1) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f x)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) C (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x))), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.has_op_norm.{0 0 0} 𝕜 E F _inst_1 _inst_2 _inst_4 _inst_5 _inst_6) (@linear_map.mk_continuous.{0 0 0} 𝕜 E F _inst_1 _inst_2 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_5 _inst_6 f C h)) C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α], @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' If a continuous linear map is constructed from a linear map via the constructor `mk_continuous`,
then its norm is bounded by the bound given to the constructor if it is nonnegative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          normed_field.nondiscrete_normed_field
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field)))
       complex.continuous_linear_map.of_real)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@continuous_linear_map.has_op_norm.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          normed_field.nondiscrete_normed_field
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field)))
       (@linear_map.mk_continuous.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          complex.linear_map.of_real
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.of_real._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165    calc 1 = ∥continuous_linear_map.of_real (1 : ℝ)∥ : by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@continuous_linear_map.has_op_norm.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          normed_field.nondiscrete_normed_field
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field)))
       (@linear_map.mk_continuous.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          complex.linear_map.of_real
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.of_real._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166      ... ≤ ∥continuous_linear_map.of_real∥ :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} real
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@continuous_linear_map.has_op_norm.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          normed_field.nondiscrete_normed_field
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field)))
       (@linear_map.mk_continuous.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          complex.linear_map.of_real
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.of_real._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167        by { apply continuous_linear_map.unit_le_op_norm, simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='continuous_linear_map.unit_le_op_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 224, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : nondiscrete_normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2] (f : @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (x : E), @has_le.le.{0} real real.has_le (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) → @has_le.le.{0} real real.has_le (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.to_fun.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f x)) (@has_norm.norm.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.has_op_norm.{0 0 0} 𝕜 E F _inst_1 _inst_2 _inst_4 _inst_5 _inst_6) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The image of the unit ball under a continuous linear map is bounded.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real normed_field.normed_field))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@continuous_linear_map.has_op_norm.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          normed_field.nondiscrete_normed_field
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field)))
       (@linear_map.mk_continuous.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          complex.linear_map.of_real
          (@has_one.one.{0} real
             (@monoid.to_has_one.{0} real
                (@semiring.to_monoid.{0} real
                   (@ordered_semiring.to_semiring.{0} real
                      (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
          complex.continuous_linear_map.of_real._proof_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} complex (@normed_field.to_has_norm.{0} complex complex.normed_field)
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))
    (@has_norm.norm.{0}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.has_op_norm.{0 0 0} real real complex
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
          normed_field.nondiscrete_normed_field
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
          (@complex.normed_space.restrict_scalars_real.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field)))
       complex.continuous_linear_map.of_real)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{0} real
       (@normed_group.to_has_norm.{0} real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  lemma continuous_linear_map.of_real_isometry :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    isometry continuous_linear_map.of_real :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='isometry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/isometry.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : emetric_space.{u} α] [_inst_2 : emetric_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' An isometry (also known as isometric embedding) is a map preserving the edistance
between emetric spaces, or equivalently the distance between metric space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  continuous_linear_map.isometry_iff_norm_image_eq_norm.2 (λx, by simp)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous_linear_map.isometry_iff_norm_image_eq_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 E F : Type} [_inst_1 : normed_group.{0} E] [_inst_2 : normed_group.{0} F] [_inst_4 : nondiscrete_normed_field.{0} 𝕜] [_inst_5 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1] [_inst_6 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2] {f : @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)}, iff (@isometry.{0 0} E F (@metric_space.to_emetric_space.{0} E (@normed_group.to_metric_space.{0} E _inst_1)) (@metric_space.to_emetric_space.{0} F (@normed_group.to_metric_space.{0} F _inst_2)) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.to_fun.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f)) (∀ (x : E), @eq.{1} real (@has_norm.norm.{0} F (@normed_group.to_has_norm.{0} F _inst_2) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) (@continuous_linear_map.to_fun.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_1))) (@normed_group.to_add_comm_group.{0} E _inst_1) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_1 _inst_5) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_4) _inst_2 _inst_6)) f x)) (@has_norm.norm.{0} E (@normed_group.to_has_norm.{0} E _inst_1) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A continuous linear map is an isometry if and only if it preserves the norm.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='lime'><a title='x : real
⊢ @eq.{1} real
    (@has_norm.norm.{0} complex
       (@normed_group.to_has_norm.{0} complex
          (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex
                   (@normed_group.to_metric_space.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             (@normed_space.to_module.{0 0} real complex
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field))))
          (@continuous_linear_map.to_fun.{0 0 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex
                   (@normed_group.to_metric_space.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             (@normed_space.to_module.{0 0} real complex
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@complex.normed_space.restrict_scalars_real.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field))))
          complex.continuous_linear_map.of_real
          x))
    (@has_norm.norm.{0} real
       (@normed_group.to_has_norm.{0} real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  end complex</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  section real_deriv_of_complex</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  /-! ### Differentiability of the restriction to `ℝ` of complex functions -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  open complex</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  variables {e : ℂ → ℂ} {e&#x27; : ℂ} {z : ℝ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  /-- If a complex function is differentiable at a real point, then the induced real function is also</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  differentiable at this point, with a derivative equal to the real part of the complex derivative. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  theorem has_deriv_at_real_of_complex (h : has_deriv_at e e&#x27; z) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → F → 𝕜 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='`f` has the derivative `f&#x27;` at the point `x`.

That is, `f x&#x27; = f x + (x&#x27; - x) • f&#x27; + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    has_deriv_at (λx:ℝ, (e x).re) e&#x27;.re z :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='complex.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complex.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/complex/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → F → 𝕜 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='complex → complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`f` has the derivative `f&#x27;` at the point `x`.

That is, `f x&#x27; = f x + (x&#x27; - x) • f&#x27; + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186    have : (λx:ℝ, (e x).re) = (continuous_linear_map.re : ℂ → ℝ) ∘ e ∘ (continuous_linear_map.of_real : ℝ → ℂ),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187      by { ext x, refl },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    rw this,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189    have A : has_fderiv_at continuous_linear_map.of_real continuous_linear_map.of_real z :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190      continuous_linear_map.of_real.has_fderiv_at,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    have B : has_fderiv_at e ((continuous_linear_map.smul_right 1 e&#x27; : ℂ →L[ℂ] ℂ).restrict_scalars ℝ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='continuous_linear_map.smul_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type} [_inst_2 : normed_group.{0} E] [_inst_3 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_2))) (@normed_group.to_add_comm_group.{0} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex → complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {R : Type} [_inst_1 : comm_ring.{0} R] [_inst_2 : topological_space.{0} R] {M : Type} [_inst_3 : topological_space.{0} M] [_inst_4 : add_comm_group.{0} M] {M₂ : Type} [_inst_5 : topological_space.{0} M₂] [_inst_6 : add_comm_group.{0} M₂] [_inst_9 : @module.{0 0} R M (@comm_ring.to_ring.{0} R _inst_1) _inst_4] [_inst_10 : @module.{0 0} R M₂ (@comm_ring.to_ring.{0} R _inst_1) _inst_6] [_inst_13 : @topological_module.{0 0} R M₂ (@comm_ring.to_ring.{0} R _inst_1) _inst_2 _inst_5 _inst_6 _inst_10], @continuous_linear_map.{0 0 0} R (@comm_ring.to_ring.{0} R _inst_1) M _inst_3 _inst_4 R _inst_2 (@ring.to_add_comm_group.{0} R (@comm_ring.to_ring.{0} R _inst_1)) _inst_9 (@ring.to_module.{0} R (@comm_ring.to_ring.{0} R _inst_1)) → M₂ → @continuous_linear_map.{0 0 0} R (@comm_ring.to_ring.{0} R _inst_1) M _inst_3 _inst_4 M₂ _inst_5 _inst_6 _inst_9 _inst_10'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type) [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 0} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The linear map `λ x, c x • f`.  Associates to a scalar-valued linear map and an element of
`M₂` the `M₂`-valued linear map obtained by multiplying the two (a.k.a. tensoring by `M₂`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192      (continuous_linear_map.of_real z) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193      (has_deriv_at_iff_has_fderiv_at.1 h).restrict_scalars ℝ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_deriv_at_iff_has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {F : Type} [_inst_2 : normed_group.{0} F] [_inst_3 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {f : 𝕜 → F} {x : 𝕜} {f&#x27; : F}, iff (@has_deriv_at.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f f&#x27; x) (@has_fderiv_at.{0 0 0} 𝕜 _inst_1 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_field.to_normed_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)) F _inst_2 _inst_3 f (@continuous_linear_map.smul_right.{0 0 0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))))) (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.topological_vector_space.{0 0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) F _inst_2 _inst_3) (@has_one.one.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@ring.to_add_comm_group.{0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))))))) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@ring.to_module.{0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))))))) (@continuous_linear_map.has_one.{0 0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))))) f&#x27;) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field)) e e&#x27; (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Expressing `has_deriv_at f f&#x27; x` in terms of `has_fderiv_at`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z)
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    have C : has_fderiv_at continuous_linear_map.re continuous_linear_map.re</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='complex.continuous_linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type} [_inst_2 : normed_group.{0} E] [_inst_3 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{0} E (@metric_space.to_uniform_space&#x27;.{0} E (@normed_group.to_metric_space.{0} E _inst_2))) (@normed_group.to_add_comm_group.{0} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z)
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195      (e (continuous_linear_map.of_real z)) := continuous_linear_map.re.has_fderiv_at,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='complex.continuous_linear_map.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='complex.continuous_linear_map.re'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 152, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='complex → complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Continuous linear map version of the canonical embedding of `ℝ` in `ℂ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Continuous linear map version of the real part function, from `ℂ` to `ℝ`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z)
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z),
C :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       complex.continuous_linear_map.re)
    complex.continuous_linear_map.re
    (e
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          z))
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    convert has_fderiv_at_iff_has_deriv_at.1 (C.comp z (B.comp z A)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_fderiv_at_iff_has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 146, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 1339, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 1339, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {F : Type} [_inst_2 : normed_group.{0} F] [_inst_3 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {f : 𝕜 → F} {x : 𝕜} {f&#x27; : @continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3)}, iff (@has_fderiv_at.{0 0 0} 𝕜 _inst_1 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_field.to_normed_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)) F _inst_2 _inst_3 f f&#x27; x) (@has_deriv_at.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3)) (@continuous_linear_map.to_fun.{0 0 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3)) f&#x27; (@has_one.one.{0} 𝕜 (@zero_ne_one_class.to_has_one.{0} 𝕜 (@domain.to_zero_ne_one_class.{0} 𝕜 (@division_ring.to_domain.{0} 𝕜 (@field.to_division_ring.{0} 𝕜 (@discrete_field.to_field.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))))))))) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@complex.normed_space.restrict_scalars_real.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex complex.normed_field)) real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field)) (@discrete_field.to_vector_space.{0} real real.discrete_field)) complex.continuous_linear_map.re) complex.continuous_linear_map.re (e (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))) (@continuous_linear_map.to_fun.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))) complex.continuous_linear_map.of_real z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_space.restrict_scalars.{0 0 0} real complex (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) complex.normed_field complex.normed_algebra_over_reals complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex complex.normed_field)) complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_space.restrict_scalars.{0 0 0} real complex (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) complex.normed_field complex.normed_algebra_over_reals complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex complex.normed_field)) e (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex complex.normed_field complex.normed_algebra_over_reals complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex complex.normed_field) complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex complex.normed_field) (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field) (@discrete_field.to_vector_space.{0} complex complex.discrete_field) (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex complex.normed_field)) (@has_one.one.{0} (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)) (@discrete_field.to_vector_space.{0} complex complex.discrete_field) (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))) (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))) e&#x27;)) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))) (@continuous_linear_map.to_fun.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))) complex.continuous_linear_map.of_real z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@complex.normed_space.restrict_scalars_real.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)) (@normed_field.to_normed_space.{0} complex complex.normed_field)) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))) (@continuous_linear_map.to_fun.{0 0 0} real real.ring real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group complex (@uniform_space.to_topological_space.{0} complex (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space)) (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} real real.discrete_field) (@module.complex_to_real.{0} complex (@normed_group.to_add_comm_group.{0} complex (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))) (@discrete_field.to_vector_space.{0} complex complex.discrete_field))) complex.continuous_linear_map.of_real) complex.continuous_linear_map.of_real z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Expressing `has_fderiv_at f f&#x27; x` in terms of `has_deriv_at`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The chain rule.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The chain rule.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z),
C :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       complex.continuous_linear_map.re)
    complex.continuous_linear_map.re
    (e
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          z))
⊢ @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real)))
    (e&#x27;.re)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z),
C :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       complex.continuous_linear_map.re)
    complex.continuous_linear_map.re
    (e
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          z))
⊢ @eq.{1} complex e&#x27;
    (@coe_fn.{1 1}
       (@linear_map.{0 0 0} real real complex
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@linear_map.has_coe_to_fun.{0 0 0} real real complex
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@continuous_linear_map.to_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@continuous_linear_map.comp.{0 0 0 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex
                   (@normed_group.to_metric_space.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex
                   (@normed_group.to_metric_space.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             (@normed_space.to_module.{0 0} real complex
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_space.restrict_scalars.{0 0 0} real complex
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                   complex.normed_field
                   complex.normed_algebra_over_reals
                   complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real complex
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_space.restrict_scalars.{0 0 0} real complex
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                   complex.normed_field
                   complex.normed_algebra_over_reals
                   complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
                complex.normed_field
                complex.normed_algebra_over_reals
                complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)
                complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)
                (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
                   (@uniform_space.to_topological_space.{0} complex
                      (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                   complex
                   (@uniform_space.to_topological_space.{0} complex
                      (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   complex
                   (@uniform_space.to_topological_space.{0} complex
                      (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                   (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                      (@normed_field.to_normed_space.{0} complex complex.normed_field))
                   (@has_one.one.{0}
                      (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                         (@uniform_space.to_topological_space.{0} complex
                            (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                         (@normed_group.to_add_comm_group.{0} complex
                            (@normed_ring.to_normed_group.{0} complex
                               (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                         complex
                         (@uniform_space.to_topological_space.{0} complex
                            (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                         (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                         (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                         (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
                      (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)
                         complex
                         (@uniform_space.to_topological_space.{0} complex
                            (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                         (@normed_group.to_add_comm_group.{0} complex
                            (@normed_ring.to_normed_group.{0} complex
                               (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                         (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
                   e&#x27;))
             complex.continuous_linear_map.of_real))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real
             (@domain.to_zero_ne_one_class.{0} real
                (@division_ring.to_domain.{0} real
                   (@field.to_division_ring.{0} real
                      (@discrete_field.to_field.{0} real
                         (@normed_field.to_discrete_field.{0} real
                            (@nondiscrete_normed_field.to_normed_field.{0} real
                               normed_field.nondiscrete_normed_field)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197    change e&#x27; = 1 * e&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='complex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z),
C :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       complex.continuous_linear_map.re)
    complex.continuous_linear_map.re
    (e
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          z))
⊢ @eq.{1} complex e&#x27;
    (@coe_fn.{1 1}
       (@linear_map.{0 0 0} real real complex
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@linear_map.has_coe_to_fun.{0 0 0} real real complex
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field))))
       (@continuous_linear_map.to_linear_map.{0 0 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex
                (@normed_group.to_metric_space.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          (@normed_space.to_module.{0 0} real complex
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@complex.normed_space.restrict_scalars_real.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)))
          (@continuous_linear_map.comp.{0 0 0 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex
                   (@normed_group.to_metric_space.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex
                   (@normed_group.to_metric_space.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             (@normed_space.to_module.{0 0} real complex
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_space.restrict_scalars.{0 0 0} real complex
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                   complex.normed_field
                   complex.normed_algebra_over_reals
                   complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@normed_space.to_module.{0 0} real complex
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_space.restrict_scalars.{0 0 0} real complex
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                   complex.normed_field
                   complex.normed_algebra_over_reals
                   complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                   (@normed_field.to_normed_space.{0} complex complex.normed_field)))
             (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
                complex.normed_field
                complex.normed_algebra_over_reals
                complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)
                complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                (@normed_field.to_normed_space.{0} complex complex.normed_field)
                (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
                   (@uniform_space.to_topological_space.{0} complex
                      (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                   complex
                   (@uniform_space.to_topological_space.{0} complex
                      (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   complex
                   (@uniform_space.to_topological_space.{0} complex
                      (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                   (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field))
                      (@normed_field.to_normed_space.{0} complex complex.normed_field))
                   (@has_one.one.{0}
                      (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                         (@uniform_space.to_topological_space.{0} complex
                            (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                         (@normed_group.to_add_comm_group.{0} complex
                            (@normed_ring.to_normed_group.{0} complex
                               (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                         complex
                         (@uniform_space.to_topological_space.{0} complex
                            (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                         (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                         (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                         (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
                      (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)
                         complex
                         (@uniform_space.to_topological_space.{0} complex
                            (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                         (@normed_group.to_add_comm_group.{0} complex
                            (@normed_ring.to_normed_group.{0} complex
                               (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                         (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
                   e&#x27;))
             complex.continuous_linear_map.of_real))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real
             (@domain.to_zero_ne_one_class.{0} real
                (@division_ring.to_domain.{0} real
                   (@field.to_division_ring.{0} real
                      (@discrete_field.to_field.{0} real
                         (@normed_field.to_discrete_field.{0} real
                            (@nondiscrete_normed_field.to_normed_field.{0} real
                               normed_field.nondiscrete_normed_field)))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z),
C :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       complex.continuous_linear_map.re)
    complex.continuous_linear_map.re
    (e
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          z))
⊢ @eq.{1} complex e&#x27; (@has_mul.mul.{0} complex complex.has_mul (@has_one.one.{0} complex complex.has_one) e&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198    rw one_mul</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='e : complex → complex,
e&#x27; : complex,
z : real,
h :
  @has_deriv_at.{0 0} complex complex.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_field.to_normed_space.{0} complex
       (@nondiscrete_normed_field.to_normed_field.{0} complex complex.nondiscrete_normed_field))
    e
    e&#x27;
    (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe)) z),
this :
  @eq.{1} (real → real)
    (λ (x : real),
       (e
          (@coe.{1 1} real complex (@coe_to_lift.{1 1} real complex (@coe_base.{1 1} real complex complex.has_coe))
             x)).re)
    (@function.comp.{1 1 1} real complex real
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          complex.continuous_linear_map.re)
       (@function.comp.{1 1 1} real complex complex e
          (@coe_fn.{1 1}
             (@continuous_linear_map.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
                (@uniform_space.to_topological_space.{0} real
                   (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
                real.add_comm_group
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} real real.discrete_field)
                (@module.complex_to_real.{0} complex
                   (@normed_group.to_add_comm_group.{0} complex
                      (@normed_ring.to_normed_group.{0} complex
                         (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                   (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
             complex.continuous_linear_map.of_real))),
A :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real)
    complex.continuous_linear_map.of_real
    z,
B :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@normed_space.restrict_scalars.{0 0 0} real complex
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    e
    (@continuous_linear_map.restrict_scalars.{0 0 0 0} real normed_field.nondiscrete_normed_field complex
       complex.normed_field
       complex.normed_algebra_over_reals
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field)
       (@continuous_linear_map.smul_right.{0 0 0} complex complex.comm_ring
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
          (@normed_space.topological_vector_space.{0 0} complex complex.normed_field complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
             (@normed_field.to_normed_space.{0} complex complex.normed_field))
          (@has_one.one.{0}
             (@continuous_linear_map.{0 0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@ring.to_add_comm_group.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)
                (@ring.to_module.{0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring)))
             (@continuous_linear_map.has_one.{0 0} complex (@comm_ring.to_ring.{0} complex complex.comm_ring) complex
                (@uniform_space.to_topological_space.{0} complex
                   (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          e&#x27;))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          (@discrete_field.to_vector_space.{0} real real.discrete_field)
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
       complex.continuous_linear_map.of_real
       z),
C :
  @has_fderiv_at.{0 0 0} real normed_field.nondiscrete_normed_field complex
    (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
    (@complex.normed_space.restrict_scalars_real.{0} complex
       (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field))
       (@normed_field.to_normed_space.{0} complex complex.normed_field))
    real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    (@coe_fn.{1 1}
       (@continuous_linear_map.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 0 0} real real.ring complex
          (@uniform_space.to_topological_space.{0} complex
             (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
          (@normed_group.to_add_comm_group.{0} complex
             (@normed_ring.to_normed_group.{0} complex (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@module.complex_to_real.{0} complex
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} complex complex.discrete_field))
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       complex.continuous_linear_map.re)
    complex.continuous_linear_map.re
    (e
       (@coe_fn.{1 1}
          (@continuous_linear_map.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          (@continuous_linear_map.to_fun.{0 0 0} real real.ring real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             complex
             (@uniform_space.to_topological_space.{0} complex
                (@metric_space.to_uniform_space&#x27;.{0} complex complex.metric_space))
             (@normed_group.to_add_comm_group.{0} complex
                (@normed_ring.to_normed_group.{0} complex
                   (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
             (@discrete_field.to_vector_space.{0} real real.discrete_field)
             (@module.complex_to_real.{0} complex
                (@normed_group.to_add_comm_group.{0} complex
                   (@normed_ring.to_normed_group.{0} complex
                      (@normed_field.to_normed_ring.{0} complex complex.normed_field)))
                (@discrete_field.to_vector_space.{0} complex complex.discrete_field)))
          complex.continuous_linear_map.of_real
          z))
⊢ @eq.{1} complex e&#x27; (@has_mul.mul.{0} complex complex.has_mul (@has_one.one.{0} complex complex.has_one) e&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  end real_deriv_of_complex</code></pre>
</body>