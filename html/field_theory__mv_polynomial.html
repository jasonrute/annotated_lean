<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Johannes Hölzl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Multivariate functions of the form `α^n → α` are isomorphic to multivariate polynomials in</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  `n` variables.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import linear_algebra.finsupp_vector_space field_theory.finite data.mv_polynomial</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp_vector_space.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/field_theory/finite.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open_locale classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  open lattice set linear_map submodule</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  namespace mv_polynomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables {σ : Type u} {α : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  instance [discrete_field α] : vector_space α (mv_polynomial σ α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  finsupp.vector_space _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finsupp.vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 1264, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) {γ : Type u_3} [_inst_1 : discrete_field.{u_3} γ] [_inst_2 : add_comm_group.{u_2} β] [_inst_3 : @vector_space.{u_3 u_2} γ β _inst_1 _inst_2], @vector_space.{u_3 (max u_1 u_2)} γ (@finsupp.{u_1 u_2} α β (@add_monoid.to_has_zero.{u_2} β (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_1 u_2} α β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  variables (σ α) [discrete_field α] (m : ℕ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  def restrict_total_degree : submodule α (mv_polynomial σ α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  finsupp.supported _ _ {n | n.sum (λn e, e) ≤ m }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finsupp.supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finsupp.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} (M : Type u_2) (R : Type u_3) [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_3 u_2} R M _inst_1 _inst_2], set.{u_1} α → @submodule.{u_3 (max u_1 u_2)} R (@finsupp.{u_1 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_1 u_2} α M _inst_2) (@finsupp.module.{u_1 u_2 u_3} α M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β γ : Type} [_inst_1 : has_zero.{0} β] [_inst_2 : add_comm_monoid.{0} γ], @finsupp.{u 0} α β _inst_1 → (α → β → γ) → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`sum f g` is the sum of `g a (f a)` over the support of `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  lemma mem_restrict_total_degree (p : mv_polynomial σ α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    p ∈ restrict_total_degree σ α m ↔ p.total_degree ≤ m :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial.restrict_total_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mv_polynomial.total_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 702, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u v)} [c : has_mem.{(max u v) (max u v)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (σ : Type u) (α : Type v) [_inst_1 : discrete_field.{v} α], nat → @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {σ : Type u} [_inst_1 : comm_semiring.{v} α], @mv_polynomial.{u v} σ α _inst_1 → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`total_degree p` gives the maximum |s| over the monomials X^s in `p`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
m : nat,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_total_degree.{u v} σ α _inst_1 m))
    (@has_le.le.{0} nat nat.has_le
       (@mv_polynomial.total_degree.{v u} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
          p)
       m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    rw [total_degree, finset.sup_le_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.total_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sup_le_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 702, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1781, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α], @mv_polynomial.{?l_2 ?l_1} σ α _inst_1 → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : lattice.semilattice_sup_bot.{0} α] {s : finset.{u} β} {f : β → α} {a : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.semilattice_sup_bot.to_order_bot.{0} α _inst_1)))) (@finset.sup.{0 u} α β _inst_1 s f) a) (∀ (b : β), @has_mem.mem.{u u} β (finset.{u} β) (@finset.has_mem.{u} β) b s → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.semilattice_sup_bot.to_order_bot.{0} α _inst_1)))) (f b) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`total_degree p` gives the maximum |s| over the monomials X^s in `p`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
m : nat,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_total_degree.{u v} σ α _inst_1 m))
    (@has_le.le.{0} nat nat.has_le
       (@mv_polynomial.total_degree.{v u} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
          p)
       m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
m : nat,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_total_degree.{u v} σ α _inst_1 m))
    (@has_le.le.{0} nat nat.has_le
       (@finset.sup.{0 u} nat (@finsupp.{u 0} σ nat nat.has_zero) lattice.nat.semilattice_sup_bot
          (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@mul_zero_class.to_has_zero.{v} α
                (@semiring.to_mul_zero_class.{v} α
                   (@comm_semiring.to_semiring.{v} α
                      (@nonzero_comm_semiring.to_comm_semiring.{v} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                            (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
             p)
          (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
             @finsupp.sum.{u 0 0} σ nat nat nat.has_zero nat.add_comm_monoid s (λ (n : σ) (e : nat), e)))
       m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
m : nat,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_total_degree.{u v} σ α _inst_1 m))
    (∀ (b : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         b
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       @has_le.le.{0} nat
         (@preorder.to_has_le.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@lattice.order_bot.to_partial_order.{0} nat
                  (@lattice.semilattice_sup_bot.to_order_bot.{0} nat lattice.nat.semilattice_sup_bot))))
         (@finsupp.sum.{u 0 0} σ nat nat nat.has_zero nat.add_comm_monoid b (λ (n : σ) (e : nat), e))
         m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
m : nat,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_total_degree.{u v} σ α _inst_1 m))
    (∀ (b : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         b
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       @has_le.le.{0} nat
         (@preorder.to_has_le.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@lattice.order_bot.to_partial_order.{0} nat
                  (@lattice.semilattice_sup_bot.to_order_bot.{0} nat lattice.nat.semilattice_sup_bot))))
         (@finsupp.sum.{u 0 0} σ nat nat nat.has_zero nat.add_comm_monoid b (λ (n : σ) (e : nat), e))
         m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  variables (σ α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  def restrict_degree (m : ℕ) [discrete_field α] : submodule α (mv_polynomial σ α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='submodule'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{v} β] [_inst_3 : @module.{u v} α β _inst_1 _inst_2], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title='A submodule of a module is one which is closed under vector operations.
 This is a sufficient condition for the subset of vectors in the submodule
 to themselves form a module.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  finsupp.supported _ _ {n | ∀i, n i ≤ m }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finsupp.supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} (M : Type u_2) (R : Type u_3) [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_2} M] [_inst_3 : @module.{u_3 u_2} R M _inst_1 _inst_2], set.{u_1} α → @submodule.{u_3 (max u_1 u_2)} R (@finsupp.{u_1 u_2} α M (@add_monoid.to_has_zero.{u_2} M (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u_1 u_2} α M _inst_2) (@finsupp.module.{u_1 u_2 u_3} α M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  lemma mem_restrict_degree [discrete_field α] (p : mv_polynomial σ α) (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    p ∈ restrict_degree σ α n ↔ (∀s ∈ p.support, ∀i, (s : σ →₀ ℕ) i ≤ n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finsupp.support'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u v)} [c : has_mem.{(max u v) (max u v)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (σ : Type u) (α : Type v), nat → Π [_inst_1 : discrete_field.{v} α], @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β], @finsupp.{u v} α β _inst_1 → finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Π (β : Type) [_inst_1 : has_zero.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_degree.{u v} σ α n _inst_1))
    (∀ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         s
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       ∀ (i : σ),
         @has_le.le.{0} nat nat.has_le
           (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
              (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
              s
              i)
           n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    rw [restrict_degree, finsupp.mem_supported],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.mem_supported'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (σ : Type ?l_1) (α : Type ?l_2), nat → Π [_inst_1 : discrete_field.{?l_2} α], @submodule.{?l_2 (max ?l_1 ?l_2)} α (@mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@domain.to_ring.{?l_2} α (@division_ring.to_domain.{?l_2} α (@field.to_division_ring.{?l_2} α (@discrete_field.to_field.{?l_2} α _inst_1)))) (@ring.to_add_comm_group.{(max ?l_1 ?l_2)} (@mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@mv_polynomial.ring.{?l_2 ?l_1} α σ (@nonzero_comm_ring.to_comm_ring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@mv_polynomial.vector_space.{?l_1 ?l_2} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {M : Type v} (R : Type v) [_inst_1 : ring.{v} R] [_inst_2 : add_comm_group.{v} M] [_inst_3 : @module.{v v} R M _inst_1 _inst_2] {s : set.{u} α} (p : @finsupp.{u v} α M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))), iff (@has_mem.mem.{(max u v) (max u v)} (@finsupp.{u v} α M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) (@submodule.{v (max u v)} R (@finsupp.{u v} α M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u v} α M _inst_2) (@finsupp.module.{u v v} α M R _inst_1 _inst_2 _inst_3)) (@submodule.has_mem.{v (max u v)} R (@finsupp.{u v} α M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u v} α M _inst_2) (@finsupp.module.{u v v} α M R _inst_1 _inst_2 _inst_3)) p (@finsupp.supported.{u v v} α M R _inst_1 _inst_2 _inst_3 s)) (@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@coe.{u+1 u+1} (finset.{u} α) (set.{u} α) (@lift_base.{u+1 u+1} (finset.{u} α) (set.{u} α) (@finset.has_lift.{u} α)) (@finsupp.support.{u v} α M (@add_monoid.to_has_zero.{v} M (@add_group.to_add_monoid.{v} M (@add_comm_group.to_add_group.{v} M _inst_2))) p)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_degree.{u v} σ α n _inst_1))
    (∀ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         s
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       ∀ (i : σ),
         @has_le.le.{0} nat nat.has_le
           (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
              (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
              s
              i)
           n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@finsupp.supported.{u v v} (@finsupp.{u 0} σ nat nat.has_zero) α α
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{v} α
             (@domain.to_ring.{v} α
                (@division_ring.to_domain.{v} α
                   (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))
          (@discrete_field.to_vector_space.{v} α _inst_1)
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (n_1 : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (i : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       n_1
                       i)
                    n))))
    (∀ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         s
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       ∀ (i : σ),
         @has_le.le.{0} nat nat.has_le
           (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
              (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
              s
              i)
           n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_subset.subset.{u} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       (@set.has_subset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       (@coe.{u+1 u+1} (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero)) (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@lift_base.{u+1 u+1} (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@finset.has_lift.{u} (@finsupp.{u 0} σ nat nat.has_zero)))
          (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_group.to_add_monoid.{v} α
                   (@add_comm_group.to_add_group.{v} α
                      (@ring.to_add_comm_group.{v} α
                         (@domain.to_ring.{v} α
                            (@division_ring.to_domain.{v} α
                               (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))))))
             p))
       (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
          (λ (n_1 : @finsupp.{u 0} σ nat nat.has_zero),
             ∀ (i : σ),
               @has_le.le.{0} nat nat.has_le
                 (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                    (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                    n_1
                    i)
                 n)))
    (∀ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         s
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       ∀ (i : σ),
         @has_le.le.{0} nat nat.has_le
           (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
              (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
              s
              i)
           n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_subset.subset.{u} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       (@set.has_subset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       (@coe.{u+1 u+1} (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero)) (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@lift_base.{u+1 u+1} (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@finset.has_lift.{u} (@finsupp.{u 0} σ nat nat.has_zero)))
          (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_group.to_add_monoid.{v} α
                   (@add_comm_group.to_add_group.{v} α
                      (@ring.to_add_comm_group.{v} α
                         (@domain.to_ring.{v} α
                            (@division_ring.to_domain.{v} α
                               (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))))))
             p))
       (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
          (λ (n_1 : @finsupp.{u 0} σ nat nat.has_zero),
             ∀ (i : σ),
               @has_le.le.{0} nat nat.has_le
                 (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                    (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                    n_1
                    i)
                 n)))
    (∀ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         s
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       ∀ (i : σ),
         @has_le.le.{0} nat nat.has_le
           (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
              (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
              s
              i)
           n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  lemma mem_restrict_degree_iff_sup [discrete_field α] (p : mv_polynomial σ α) (n : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero)) (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero)) s (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α (@comm_semiring.to_semiring.{v} α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))))) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (s : @finsupp.{u 0} σ nat nat.has_zero), @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero)) (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero)) s (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α (@comm_semiring.to_semiring.{v} α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))))) p) → ∀ (i : σ), @has_le.le.{0} nat nat.has_le (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero) (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero) s i) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    p ∈ restrict_degree σ α n ↔ ∀i, p.degrees.count i ≤ n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mv_polynomial.degrees'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='multiset.count'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 598, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1849, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u v)} [c : has_mem.{(max u v) (max u v)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (σ : Type u) (α : Type v), nat → Π [_inst_1 : discrete_field.{v} α], @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {σ : Type u} [_inst_1 : comm_semiring.{v} α], @mv_polynomial.{u v} σ α _inst_1 → multiset.{u} σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α], α → multiset.{u} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The maximal degrees of each variable in a multi-variable polynomial, expressed as a multiset.

(For example, `degrees (x^2 * y + y^3)` would be `{x, x, y, y, y}`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`count a s` is the multiplicity of `a` in `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_degree.{u v} σ α n _inst_1))
    (∀ (i : σ),
       @has_le.le.{0} nat nat.has_le
         (@multiset.count.{u} σ (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b)) i
            (@mv_polynomial.degrees.{v u} α σ
               (@nonzero_comm_semiring.to_comm_semiring.{v} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                     (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
               p))
         n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    simp only [mem_restrict_degree, degrees, multiset.count_sup, finsupp.count_to_multiset,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='mv_polynomial.mem_restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.degrees'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.count_sup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.count_to_multiset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 598, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 2350, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 1076, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {σ : Type ?l_1} {α : Type ?l_2} [_inst_1 : discrete_field.{?l_2} α] (p : @mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (n : nat), iff (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (@mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@submodule.{?l_2 (max ?l_1 ?l_2)} α (@mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@domain.to_ring.{?l_2} α (@division_ring.to_domain.{?l_2} α (@field.to_division_ring.{?l_2} α (@discrete_field.to_field.{?l_2} α _inst_1)))) (@ring.to_add_comm_group.{(max ?l_1 ?l_2)} (@mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@mv_polynomial.ring.{?l_2 ?l_1} α σ (@nonzero_comm_ring.to_comm_ring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@mv_polynomial.vector_space.{?l_1 ?l_2} σ α _inst_1)) (@submodule.has_mem.{?l_2 (max ?l_1 ?l_2)} α (@mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@domain.to_ring.{?l_2} α (@division_ring.to_domain.{?l_2} α (@field.to_division_ring.{?l_2} α (@discrete_field.to_field.{?l_2} α _inst_1)))) (@ring.to_add_comm_group.{(max ?l_1 ?l_2)} (@mv_polynomial.{?l_1 ?l_2} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@mv_polynomial.ring.{?l_2 ?l_1} α σ (@nonzero_comm_ring.to_comm_ring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))) (@mv_polynomial.vector_space.{?l_1 ?l_2} σ α _inst_1)) p (@mv_polynomial.restrict_degree.{?l_1 ?l_2} σ α n _inst_1)) (∀ (s : @finsupp.{?l_1 0} σ nat nat.has_zero), @has_mem.mem.{?l_1 ?l_1} (@finsupp.{?l_1 0} σ nat nat.has_zero) (finset.{?l_1} (@finsupp.{?l_1 0} σ nat nat.has_zero)) (@finset.has_mem.{?l_1} (@finsupp.{?l_1 0} σ nat nat.has_zero)) s (@finsupp.support.{?l_1 ?l_2} (@finsupp.{?l_1 0} σ nat nat.has_zero) α (@mul_zero_class.to_has_zero.{?l_2} α (@semiring.to_mul_zero_class.{?l_2} α (@comm_semiring.to_semiring.{?l_2} α (@nonzero_comm_semiring.to_comm_semiring.{?l_2} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} α (@local_ring.to_nonzero_comm_ring.{?l_2} α (@discrete_field.local_ring.{?l_2} α _inst_1))))))) p) → ∀ (i : σ), @has_le.le.{0} nat nat.has_le (@coe_fn.{(max (?l_1+1) 1) (max (?l_1+1) 1)} (@finsupp.{?l_1 0} σ nat nat.has_zero) (@finsupp.has_coe_to_fun.{?l_1 0} σ nat nat.has_zero) s i) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α], @mv_polynomial.{?l_2 ?l_1} σ α _inst_1 → multiset.{?l_2} σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_eq.{?l_2+1} β] (s : finset.{?l_1} α) (f : α → multiset.{?l_2} β) (b : β), @eq.{1} nat (@multiset.count.{?l_2} β (λ (a b : β), _inst_1 a b) b (@finset.sup.{?l_2 ?l_1} (multiset.{?l_2} β) α (@multiset.lattice.semilattice_sup_bot.{?l_2} β (λ (a b : β), _inst_1 a b)) s f)) (@finset.sup.{0 ?l_1} nat α lattice.nat.semilattice_sup_bot s (λ (a : α), @multiset.count.{?l_2} β (λ (a b : β), _inst_1 a b) b (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (f : @finsupp.{?l_1 0} α nat nat.has_zero) (a : α), @eq.{1} nat (@multiset.count.{?l_1} α (λ (a b : α), classical.prop_decidable (@eq.{?l_1+1} α a b)) a (@finsupp.to_multiset.{?l_1} α f)) (@coe_fn.{(max (?l_1+1) 1) (max (?l_1+1) 1)} (@finsupp.{?l_1 0} α nat nat.has_zero) (@finsupp.has_coe_to_fun.{?l_1 0} α nat nat.has_zero) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The maximal degrees of each variable in a multi-variable polynomial, expressed as a multiset.

(For example, `degrees (x^2 * y + y^3)` would be `{x, x, y, y, y}`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_degree.{u v} σ α n _inst_1))
    (∀ (i : σ),
       @has_le.le.{0} nat nat.has_le
         (@multiset.count.{u} σ (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b)) i
            (@mv_polynomial.degrees.{v u} α σ
               (@nonzero_comm_semiring.to_comm_semiring.{v} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                     (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
               p))
         n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54      finset.sup_le_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.sup_le_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1781, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : lattice.semilattice_sup_bot.{?l_1} α] {s : finset.{?l_2} β} {f : β → α} {a : α}, iff (@has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.order_bot.to_partial_order.{?l_1} α (@lattice.semilattice_sup_bot.to_order_bot.{?l_1} α _inst_1)))) (@finset.sup.{?l_1 ?l_2} α β _inst_1 s f) a) (∀ (b : β), @has_mem.mem.{?l_2 ?l_2} β (finset.{?l_2} β) (@finset.has_mem.{?l_2} β) b s → @has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.order_bot.to_partial_order.{?l_1} α (@lattice.semilattice_sup_bot.to_order_bot.{?l_1} α _inst_1)))) (f b) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (@has_mem.mem.{(max u v) (max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@submodule.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       (@submodule.has_mem.{v (max u v)} α
          (@mv_polynomial.{u v} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{v} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@domain.to_ring.{v} α
             (@division_ring.to_domain.{v} α
                (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
          (@ring.to_add_comm_group.{(max u v)}
             (@mv_polynomial.{u v} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{v} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                      (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
             (@mv_polynomial.ring.{v u} α σ
                (@nonzero_comm_ring.to_comm_ring.{v} α
                   (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
          (@mv_polynomial.vector_space.{u v} σ α _inst_1))
       p
       (@mv_polynomial.restrict_degree.{u v} σ α n _inst_1))
    (∀ (i : σ),
       @has_le.le.{0} nat nat.has_le
         (@multiset.count.{u} σ (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b)) i
            (@mv_polynomial.degrees.{v u} α σ
               (@nonzero_comm_semiring.to_comm_semiring.{v} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                     (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
               p))
         n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (∀ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         s
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       ∀ (i : σ),
         @has_le.le.{0} nat nat.has_le
           (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
              (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
              s
              i)
           n)
    (∀ (i : σ) (b : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         b
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       @has_le.le.{0} nat nat.has_le
         (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
            (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
            b
            i)
         n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    exact ⟨assume h n s hs, h s hs n, assume h s hs n, h n s hs⟩</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
p :
  @mv_polynomial.{u v} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{v} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
          (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))),
n : nat
⊢ iff
    (∀ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         s
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       ∀ (i : σ),
         @has_le.le.{0} nat nat.has_le
           (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
              (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
              s
              i)
           n)
    (∀ (i : σ) (b : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         b
         (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
            (@mul_zero_class.to_has_zero.{v} α
               (@semiring.to_mul_zero_class.{v} α
                  (@comm_semiring.to_semiring.{v} α
                     (@nonzero_comm_semiring.to_comm_semiring.{v} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                           (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))))
            p) →
       @has_le.le.{0} nat nat.has_le
         (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
            (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
            b
            i)
         n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  lemma map_range_eq_map {β : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    [comm_ring α] [comm_ring β] (p : mv_polynomial σ α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    (f : α → β) [is_semiring_hom f]:</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_semiring_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 138, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v} {β : Type u_1} [_inst_1 : semiring.{v} α] [_inst_2 : semiring.{u_1} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Predicate for semiring homomorphisms (deprecated -- use the bundled `ring_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    finsupp.map_range f (is_semiring_hom.map_zero f) p = p.map f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.map_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_semiring_hom.map_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mv_polynomial.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 138, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 501, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β₁ : Type u_8} {β₂ : Type u_9} [_inst_1 : has_zero.{u_8} β₁] [_inst_2 : has_zero.{u_9} β₂] (f : β₁ → β₂), @eq.{u_9+1} β₂ (f (@has_zero.zero.{u_8} β₁ _inst_1)) (@has_zero.zero.{u_9} β₂ _inst_2) → @finsupp.{u_1 u_8} α β₁ _inst_1 → @finsupp.{u_1 u_9} α β₂ _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : semiring.{u} α] [_inst_2 : semiring.{v} β] (f : α → β) [c : @is_semiring_hom.{u v} α β _inst_1 _inst_2 f], @eq.{v+1} β (f (@has_zero.zero.{u} α (@mul_zero_class.to_has_zero.{u} α (@semiring.to_mul_zero_class.{u} α _inst_1)))) (@has_zero.zero.{v} β (@mul_zero_class.to_has_zero.{v} β (@semiring.to_mul_zero_class.{v} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type u_1} {σ : Type u} [_inst_1 : comm_semiring.{v} α] [_inst_2 : comm_semiring.{u_1} β], (α → β) → @mv_polynomial.{u v} σ α _inst_1 → @mv_polynomial.{u u_1} σ β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The composition of `f : β₁ → β₂` and `g : α →₀ β₁` is
 `map_range f hf g : α →₀ β₂`, well defined when `f 0 = 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`map f p` maps a polynomial `p` across a ring hom `f`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       f
       (@is_semiring_hom.map_zero.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
          (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
          f
          _inst_3)
       p)
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    rw [← finsupp.sum_single p, finsupp.sum, finsupp.map_range_finset_sum,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finsupp.sum_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finsupp.map_range_finset_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 569, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 672, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β] (f : @finsupp.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1))), @eq.{(max u v)+1} (@finsupp.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1))) (@finsupp.sum.{u v (max u v)} α β (@finsupp.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1))) (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)) (@finsupp.add_comm_monoid.{u v} α β _inst_1) f (@finsupp.single.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} [_inst_1 : has_zero.{?l_2} β] [_inst_2 : add_comm_monoid.{?l_3} γ], @finsupp.{?l_1 ?l_2} α β _inst_1 → (α → β → γ) → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β₁ : Type v} {β₂ : Type u_1} [_inst_1 : add_comm_monoid.{v} β₁] [_inst_2 : add_comm_monoid.{u_1} β₂] (f : β₁ → β₂) [hf : @is_add_monoid_hom.{v u_1} β₁ β₂ (@add_comm_monoid.to_add_monoid.{v} β₁ _inst_1) (@add_comm_monoid.to_add_monoid.{u_1} β₂ _inst_2) f] {ι : Type u} (s : finset.{u} ι) (g : ι → @finsupp.{u v} α β₁ (@add_monoid.to_has_zero.{v} β₁ (@add_comm_monoid.to_add_monoid.{v} β₁ _inst_1))), @eq.{(max (u+1) (u_1+1))} (@finsupp.{u u_1} α β₂ (@add_monoid.to_has_zero.{u_1} β₂ (@add_comm_monoid.to_add_monoid.{u_1} β₂ _inst_2))) (@finsupp.map_range.{u v u_1} α β₁ β₂ (@add_monoid.to_has_zero.{v} β₁ (@add_comm_monoid.to_add_monoid.{v} β₁ _inst_1)) (@add_monoid.to_has_zero.{u_1} β₂ (@add_comm_monoid.to_add_monoid.{u_1} β₂ _inst_2)) f (@is_add_monoid_hom.map_zero.{v u_1} β₁ β₂ (@add_comm_monoid.to_add_monoid.{v} β₁ _inst_1) (@add_comm_monoid.to_add_monoid.{u_1} β₂ _inst_2) f hf) (@finset.sum.{u (max u v)} ι (@finsupp.{u v} α β₁ (@add_monoid.to_has_zero.{v} β₁ (@add_comm_monoid.to_add_monoid.{v} β₁ _inst_1))) (@finsupp.add_comm_monoid.{u v} α β₁ _inst_1) s g)) (@finset.sum.{u (max u u_1)} ι (@finsupp.{u u_1} α β₂ (@add_monoid.to_has_zero.{u_1} β₂ (@add_comm_monoid.to_add_monoid.{u_1} β₂ _inst_2))) (@finsupp.add_comm_monoid.{u u_1} α β₂ _inst_2) s (λ (x : ι), @finsupp.map_range.{u v u_1} α β₁ β₂ (@add_monoid.to_has_zero.{v} β₁ (@add_comm_monoid.to_add_monoid.{v} β₁ _inst_1)) (@add_monoid.to_has_zero.{u_1} β₂ (@add_comm_monoid.to_add_monoid.{u_1} β₂ _inst_2)) f (@is_add_monoid_hom.map_zero.{v u_1} β₁ β₂ (@add_comm_monoid.to_add_monoid.{v} β₁ _inst_1) (@add_comm_monoid.to_add_monoid.{u_1} β₂ _inst_2) f hf) (g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`sum f g` is the sum of `g a (f a)` over the support of `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       f
       (@is_semiring_hom.map_zero.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
          (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
          f
          _inst_3)
       p)
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       f
       (@is_semiring_hom.map_zero.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
          (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
          f
          _inst_3)
       (@finsupp.sum.{u v (max u v)} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          p
          (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finsupp.sum.{u v (max u v)} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          p
          (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       f
       (@is_semiring_hom.map_zero.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
          (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
          f
          _inst_3)
       (@finset.sum.{u (max u v)} (@finsupp.{u 0} σ nat nat.has_zero)
          (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
          (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
             p)
          (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
             @finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               a
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  a))))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finset.sum.{u (max u v)} (@finsupp.{u 0} σ nat nat.has_zero)
          (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
          (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
             p)
          (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
             @finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               a
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@add_monoid.to_has_zero.{u_1} β
             (@add_comm_monoid.to_add_monoid.{u_1} β
                (@semiring.to_add_comm_monoid.{u_1} β
                   (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))))
       (@finsupp.add_comm_monoid.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
            (@add_monoid.to_has_zero.{v} α
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
            (@add_monoid.to_has_zero.{u_1} β
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
            f
            (@is_add_monoid_hom.map_zero.{v u_1} α β
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
               f
               (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
                  (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
                  (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
                  f
                  _inst_3))
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finset.sum.{u (max u v)} (@finsupp.{u 0} σ nat nat.has_zero)
          (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
          (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
             p)
          (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
             @finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               a
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64      ← p.support.sum_hom (map f)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 501, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u_1} {σ : Type u} [_inst_1 : comm_semiring.{v} α] [_inst_2 : comm_semiring.{u_1} β], (α → β) → @mv_polynomial.{u v} σ α _inst_1 → @mv_polynomial.{u u_1} σ β _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`map f p` maps a polynomial `p` across a ring hom `f`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@add_monoid.to_has_zero.{u_1} β
             (@add_comm_monoid.to_add_monoid.{u_1} β
                (@semiring.to_add_comm_monoid.{u_1} β
                   (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))))
       (@finsupp.add_comm_monoid.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
            (@add_monoid.to_has_zero.{v} α
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
            (@add_monoid.to_has_zero.{u_1} β
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
            f
            (@is_add_monoid_hom.map_zero.{v u_1} α β
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
               f
               (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
                  (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
                  (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
                  f
                  _inst_3))
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finset.sum.{u (max u v)} (@finsupp.{u 0} σ nat nat.has_zero)
          (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
          (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
             (@add_monoid.to_has_zero.{v} α
                (@add_comm_monoid.to_add_monoid.{v} α
                   (@semiring.to_add_comm_monoid.{v} α
                      (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
             p)
          (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
             @finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               a
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@add_monoid.to_has_zero.{u_1} β
             (@add_comm_monoid.to_add_monoid.{u_1} β
                (@semiring.to_add_comm_monoid.{u_1} β
                   (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))))
       (@finsupp.add_comm_monoid.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
            (@add_monoid.to_has_zero.{v} α
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
            (@add_monoid.to_has_zero.{u_1} β
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
            f
            (@is_add_monoid_hom.map_zero.{v u_1} α β
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
               f
               (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
                  (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
                  (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
                  f
                  _inst_3))
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
       ?m_1
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@mul_zero_class.to_has_zero.{v} α
             (@semiring.to_mul_zero_class.{v} α
                (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
            (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
            f
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))

σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ add_comm_monoid.{(max u u_1)} (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))

σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @is_add_monoid_hom.{(max u v) (max u u_1)} (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
    (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
    (@add_comm_monoid.to_add_monoid.{(max u v)}
       (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
       (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
    (@add_comm_monoid.to_add_monoid.{(max u u_1)}
       (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
       ?m_1)
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    { refine finset.sum_congr rfl (assume n _, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='finset.sum_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type (max u u_1)} {s₁ s₂ : finset.{u} α} {f g : α → β} [_inst_1 : add_comm_monoid.{(max u u_1)} β], @eq.{u+1} (finset.{u} α) s₁ s₂ → (∀ (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x s₂ → @eq.{(max u u_1)+1} β (f x) (g x)) → @eq.{(max u u_1)+1} β (@finset.sum.{u (max u u_1)} α β _inst_1 s₁ f) (@finset.sum.{u (max u u_1)} α β _inst_1 s₂ g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@add_monoid.to_has_zero.{u_1} β
             (@add_comm_monoid.to_add_monoid.{u_1} β
                (@semiring.to_add_comm_monoid.{u_1} β
                   (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))))
       (@finsupp.add_comm_monoid.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
            (@add_monoid.to_has_zero.{v} α
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
            (@add_monoid.to_has_zero.{u_1} β
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
            f
            (@is_add_monoid_hom.map_zero.{v u_1} α β
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
               f
               (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
                  (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
                  (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
                  f
                  _inst_3))
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
       ?m_1
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@mul_zero_class.to_has_zero.{v} α
             (@semiring.to_mul_zero_class.{v} α
                (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
            (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
            f
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))

σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ add_comm_monoid.{(max u u_1)} (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))

σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @is_add_monoid_hom.{(max u v) (max u u_1)} (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
    (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
    (@add_comm_monoid.to_add_monoid.{(max u v)}
       (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
       (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
    (@add_comm_monoid.to_add_monoid.{(max u u_1)}
       (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
       ?m_1)
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @eq.{(max (u+1) (u_1+1))}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@add_monoid.to_has_zero.{u_1} β
             (@add_comm_monoid.to_add_monoid.{u_1} β
                (@semiring.to_add_comm_monoid.{u_1} β
                   (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))))
       (@finsupp.add_comm_monoid.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
            (@add_monoid.to_has_zero.{v} α
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
            (@add_monoid.to_has_zero.{u_1} β
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
            f
            (@is_add_monoid_hom.map_zero.{v u_1} α β
               (@add_comm_monoid.to_add_monoid.{v} α
                  (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
               (@add_comm_monoid.to_add_monoid.{u_1} β
                  (@semiring.to_add_comm_monoid.{u_1} β
                     (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
               f
               (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
                  (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
                  (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
                  f
                  _inst_3))
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))
    (@finset.sum.{u (max u u_1)} (@finsupp.{u 0} σ nat nat.has_zero)
       (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
       ?m_1
       (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@mul_zero_class.to_has_zero.{v} α
             (@semiring.to_mul_zero_class.{v} α
                (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
          p)
       (λ (x : @finsupp.{u 0} σ nat nat.has_zero),
          @mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
            (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
            f
            (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
               (@add_monoid.to_has_zero.{v} α
                  (@add_comm_monoid.to_add_monoid.{v} α
                     (@semiring.to_add_comm_monoid.{v} α
                        (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
               x
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                  (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                     (@add_monoid.to_has_zero.{v} α
                        (@add_comm_monoid.to_add_monoid.{v} α
                           (@semiring.to_add_comm_monoid.{v} α
                              (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
                  p
                  x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f,
n : @finsupp.{u 0} σ nat nat.has_zero,
_x :
  @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    n
    (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α
             (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
       p)
⊢ @eq.{(max u u_1)+1}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
       (@add_monoid.to_has_zero.{v} α
          (@add_comm_monoid.to_add_monoid.{v} α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
       (@add_monoid.to_has_zero.{u_1} β
          (@add_comm_monoid.to_add_monoid.{u_1} β
             (@semiring.to_add_comm_monoid.{u_1} β
                (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
       f
       (@is_add_monoid_hom.map_zero.{v u_1} α β
          (@add_comm_monoid.to_add_monoid.{v} α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          (@add_comm_monoid.to_add_monoid.{u_1} β
             (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
          f
          (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
             (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
             (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
             f
             _inst_3))
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66      rw [finsupp.map_range_single, ← monomial, ← monomial, map_monomial] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finsupp.map_range_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mv_polynomial.monomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mv_polynomial.monomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.map_monomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 505, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β₁ : Type v} {β₂ : Type u_1} [_inst_1 : has_zero.{v} β₁] [_inst_2 : has_zero.{u_1} β₂] {f : β₁ → β₂} {hf : @eq.{u_1+1} β₂ (f (@has_zero.zero.{v} β₁ _inst_1)) (@has_zero.zero.{u_1} β₂ _inst_2)} {a : α} {b : β₁}, @eq.{(max (u+1) (u_1+1))} (@finsupp.{u u_1} α β₂ _inst_2) (@finsupp.map_range.{u v u_1} α β₁ β₂ _inst_1 _inst_2 f hf (@finsupp.single.{u v} α β₁ _inst_1 a b)) (@finsupp.single.{u u_1} α β₂ _inst_2 a (f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α], @finsupp.{?l_2 0} σ nat nat.has_zero → α → @mv_polynomial.{?l_2 ?l_1} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α], @finsupp.{?l_2 0} σ nat nat.has_zero → α → @mv_polynomial.{?l_2 ?l_1} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type u_1} {σ : Type u} [_inst_1 : comm_semiring.{v} α] [_inst_2 : comm_semiring.{u_1} β] (f : α → β) [_inst_3 : @is_semiring_hom.{v u_1} α β (@comm_semiring.to_semiring.{v} α _inst_1) (@comm_semiring.to_semiring.{u_1} β _inst_2) f] (s : @finsupp.{u 0} σ nat nat.has_zero) (a : α), @eq.{(max (u+1) (u_1+1))} (@mv_polynomial.{u u_1} σ β _inst_2) (@mv_polynomial.map.{v u_1 u} α β σ _inst_1 _inst_2 f (@mv_polynomial.monomial.{v u} α σ _inst_1 s a)) (@mv_polynomial.monomial.{u_1 u} β σ _inst_2 s (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`monomial s a` is the monomial `a * X^s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`monomial s a` is the monomial `a * X^s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f,
n : @finsupp.{u 0} σ nat nat.has_zero,
_x :
  @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    n
    (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α
             (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
       p)
⊢ @eq.{(max u u_1)+1}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
       (@add_monoid.to_has_zero.{v} α
          (@add_comm_monoid.to_add_monoid.{v} α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
       (@add_monoid.to_has_zero.{u_1} β
          (@add_comm_monoid.to_add_monoid.{u_1} β
             (@semiring.to_add_comm_monoid.{u_1} β
                (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
       f
       (@is_add_monoid_hom.map_zero.{v u_1} α β
          (@add_comm_monoid.to_add_monoid.{v} α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          (@add_comm_monoid.to_add_monoid.{u_1} β
             (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
          f
          (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
             (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
             (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
             f
             _inst_3))
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f,
n : @finsupp.{u 0} σ nat nat.has_zero,
_x :
  @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    n
    (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α
             (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
       p)
⊢ @eq.{(max u u_1)+1}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.single.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@add_monoid.to_has_zero.{u_1} β
          (@add_comm_monoid.to_add_monoid.{u_1} β
             (@semiring.to_add_comm_monoid.{u_1} β
                (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
       n
       (f
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f,
n : @finsupp.{u 0} σ nat nat.has_zero,
_x :
  @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    n
    (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α
             (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
       p)
⊢ @eq.{(max u u_1)+1}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@mv_polynomial.monomial.{u_1 u} β σ (@comm_ring.to_comm_semiring.{u_1} β _inst_2) n
       (f
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f,
n : @finsupp.{u 0} σ nat nat.has_zero,
_x :
  @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    n
    (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α
             (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
       p)
⊢ @eq.{(max u u_1)+1}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@mv_polynomial.monomial.{u_1 u} β σ (@comm_ring.to_comm_semiring.{u_1} β _inst_2) n
       (f
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@mv_polynomial.monomial.{v u} α σ (@comm_ring.to_comm_semiring.{v} α _inst_1) n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f,
n : @finsupp.{u 0} σ nat nat.has_zero,
_x :
  @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (finset.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    (@finset.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
    n
    (@finsupp.support.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
       (@mul_zero_class.to_has_zero.{v} α
          (@semiring.to_mul_zero_class.{v} α
             (@comm_semiring.to_semiring.{v} α (@comm_ring.to_comm_semiring.{v} α _inst_1))))
       p)
⊢ @eq.{(max u u_1)+1}
    (@finsupp.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
       (@mul_zero_class.to_has_zero.{u_1} β
          (@semiring.to_mul_zero_class.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@finsupp.map_range.{u v u_1} (@finsupp.{u 0} σ nat nat.has_zero) α β
       (@add_monoid.to_has_zero.{v} α
          (@add_comm_monoid.to_add_monoid.{v} α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
       (@add_monoid.to_has_zero.{u_1} β
          (@add_comm_monoid.to_add_monoid.{u_1} β
             (@semiring.to_add_comm_monoid.{u_1} β
                (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
       f
       (@is_add_monoid_hom.map_zero.{v u_1} α β
          (@add_comm_monoid.to_add_monoid.{v} α
             (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))
          (@add_comm_monoid.to_add_monoid.{u_1} β
             (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))))
          f
          (@is_semiring_hom.is_add_monoid_hom.{v u_1} α β
             (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
             (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
             f
             _inst_3))
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f
       (@finsupp.single.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@add_monoid.to_has_zero.{v} α
             (@add_comm_monoid.to_add_monoid.{v} α
                (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
          n
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
             (@finsupp.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             (@finsupp.has_coe_to_fun.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
                (@add_monoid.to_has_zero.{v} α
                   (@add_comm_monoid.to_add_monoid.{v} α
                      (@semiring.to_add_comm_monoid.{v} α
                         (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))))))
             p
             n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @is_add_monoid_hom.{(max u v) (max u u_1)} (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
    (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
    (@add_comm_monoid.to_add_monoid.{(max u v)}
       (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
       (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
    (@add_comm_monoid.to_add_monoid.{(max u u_1)}
       (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
       (@finsupp.add_comm_monoid.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    apply_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
β : Type u_1,
_inst_1 : comm_ring.{v} α,
_inst_2 : comm_ring.{u_1} β,
p : @mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1),
f : α → β,
_inst_3 :
  @is_semiring_hom.{v u_1} α β (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1))
    (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2))
    f
⊢ @is_add_monoid_hom.{(max u v) (max u u_1)} (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
    (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
    (@add_comm_monoid.to_add_monoid.{(max u v)}
       (@mv_polynomial.{u v} σ α (@comm_ring.to_comm_semiring.{v} α _inst_1))
       (@finsupp.add_comm_monoid.{u v} (@finsupp.{u 0} σ nat nat.has_zero) α
          (@semiring.to_add_comm_monoid.{v} α (@ring.to_semiring.{v} α (@comm_ring.to_ring.{v} α _inst_1)))))
    (@add_comm_monoid.to_add_monoid.{(max u u_1)}
       (@mv_polynomial.{u u_1} σ β (@comm_ring.to_comm_semiring.{u_1} β _inst_2))
       (@finsupp.add_comm_monoid.{u u_1} (@finsupp.{u 0} σ nat nat.has_zero) β
          (@semiring.to_add_comm_monoid.{u_1} β (@ring.to_semiring.{u_1} β (@comm_ring.to_ring.{u_1} β _inst_2)))))
    (@mv_polynomial.map.{v u_1 u} α β σ (@comm_ring.to_comm_semiring.{v} α _inst_1)
       (@comm_ring.to_comm_semiring.{u_1} β _inst_2)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  variables (σ α)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  lemma is_basis_monomials [discrete_field α] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    is_basis α ((λs, (monomial s 1 : mv_polynomial σ α))) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mv_polynomial.monomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {ι : Type u_1} (R : Type u_3) {M : Type u_5}, (ι → M) → Π [_inst_1 : ring.{u_3} R] [_inst_2 : add_comm_group.{u_5} M] [_inst_4 : @module.{u_3 u_5} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α], @finsupp.{u_1 0} σ nat nat.has_zero → α → @mv_polynomial.{u_1 u} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A family of vectors is a basis if it is linearly independent and all vectors are in the span.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`monomial s a` is the monomial `a * X^s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  suffices is_basis α (λ (sa : Σ _, unit), (monomial sa.1 1 : mv_polynomial σ α)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mv_polynomial.monomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {ι : Type u} (R : Type v) {M : Type (max u v)}, (ι → M) → Π [_inst_1 : ring.{v} R] [_inst_2 : add_comm_group.{(max u v)} M] [_inst_4 : @module.{v (max u v)} R M _inst_1 _inst_2], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u}, (α → Type) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type v} {σ : Type u} [_inst_1 : comm_semiring.{v} α], @finsupp.{u 0} σ nat nat.has_zero → α → @mv_polynomial.{u v} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type}, @sigma.{u 0} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → Π (α : Type v) [_inst_1 : comm_semiring.{v} α], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A family of vectors is a basis if it is linearly independent and all vectors are in the span.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`monomial s a` is the monomial `a * X^s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @is_basis.{u v (max u v)} (@finsupp.{u 0} σ nat nat.has_zero) α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         s
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    apply is_basis.comp this (λ (s : σ →₀ ℕ), ⟨s, punit.star⟩),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_basis.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='punit.star'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 722, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι ι&#x27; : Type u} {R : Type v} {M : Type (max u v)} {v : ι → M} [_inst_1 : ring.{v} R] [_inst_2 : add_comm_group.{(max u v)} M] [_inst_4 : @module.{v (max u v)} R M _inst_1 _inst_2], @is_basis.{u v (max u v)} ι R M v _inst_1 _inst_2 _inst_4 → ∀ (f : ι&#x27; → ι), @function.bijective.{u+1 u+1} ι&#x27; ι f → @is_basis.{u v (max u v)} ι&#x27; R M (@function.comp.{u+1 u+1 (max u v)+1} ι&#x27; ι M v f) _inst_1 _inst_2 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_basis.{u v (max u v)} (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)) α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)), @mv_polynomial.monomial.{v u} α σ (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))) (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa) (@has_one.one.{v} α (@zero_ne_one_class.to_has_one.{v} α (@domain.to_zero_ne_one_class.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Π (β : Type) [_inst_1 : has_zero.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='punit.{1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @is_basis.{u v (max u v)} (@finsupp.{u 0} σ nat nat.has_zero) α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         s
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.bijective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.bijective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.injective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})

σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.surjective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    { intros x y hxy,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.injective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})

σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.surjective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.injective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x y : @finsupp.{u 0} σ nat nat.has_zero,
hxy :
  @eq.{u+1} (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
        @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
          punit.star.{1})
       x)
    ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
        @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
          punit.star.{1})
       y)
⊢ @eq.{u+1} (@finsupp.{u 0} σ nat nat.has_zero) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79      simpa using hxy },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)) ((λ (s : @finsupp.{u 0} σ nat nat.has_zero), @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s punit.star.{1}) x) ((λ (s : @finsupp.{u 0} σ nat nat.has_zero), @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s punit.star.{1}) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x y : @finsupp.{u 0} σ nat nat.has_zero,
hxy :
  @eq.{u+1} (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
        @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
          punit.star.{1})
       x)
    ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
        @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
          punit.star.{1})
       y)
⊢ @eq.{u+1} (@finsupp.{u 0} σ nat nat.has_zero) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.surjective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    { intros x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)
⊢ @function.surjective.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
       @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
         punit.star.{1})'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)
⊢ @Exists.{u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
       @eq.{u+1}
         (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
         ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
             @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
               punit.star.{1})
            a)
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      rcases x with ⟨x₁, x₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)
⊢ @Exists.{u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
       @eq.{u+1}
         (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
         ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
             @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
               punit.star.{1})
            a)
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x₁ : @finsupp.{u 0} σ nat nat.has_zero,
x₂ : unit
⊢ @Exists.{u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
       @eq.{u+1}
         (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
         ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
             @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
               punit.star.{1})
            a)
         (@sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) x₁
            x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      use x₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x₁ : @finsupp.{u 0} σ nat nat.has_zero,
x₂ : unit
⊢ @Exists.{u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (λ (a : @finsupp.{u 0} σ nat nat.has_zero),
       @eq.{u+1}
         (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
         ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
             @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
               punit.star.{1})
            a)
         (@sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) x₁
            x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x₁ : @finsupp.{u 0} σ nat nat.has_zero,
x₂ : unit
⊢ @eq.{u+1} (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
        @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
          punit.star.{1})
       x₁)
    (@sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) x₁
       x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      rw punit_eq punit.star x₂ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='punit_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='punit.star'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/punit.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : punit.{1}), @eq.{1} punit.{1} a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='punit.{1}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
this :
  @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1),
x₁ : @finsupp.{u 0} σ nat nat.has_zero,
x₂ : unit
⊢ @eq.{u+1} (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    ((λ (s : @finsupp.{u 0} σ nat nat.has_zero),
        @sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) s
          punit.star.{1})
       x₁)
    (@sigma.mk.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) x₁
       x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α
⊢ @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    apply finsupp.is_basis_single (λ _ _, (1 : α)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finsupp.is_basis_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp_vector_space.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K V : Type v} {ι : Type u} [_inst_1 : discrete_field.{v} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{v v} K V _inst_1 _inst_2] {φ : ι → Type} (f : Π (ι : ι), φ ι → V), (∀ (i : ι), @is_basis.{0 v v} (φ i) K V (f i) (@domain.to_ring.{v} K (@division_ring.to_domain.{v} K (@field.to_division_ring.{v} K (@discrete_field.to_field.{v} K _inst_1)))) _inst_2 _inst_3) → @is_basis.{u v (max u v)} (@sigma.{u 0} ι (λ (i : ι), φ i)) K (@finsupp.{u v} ι V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2)))) (λ (ix : @sigma.{u 0} ι (λ (i : ι), φ i)), @finsupp.single.{u v} ι V (@add_monoid.to_has_zero.{v} V (@add_group.to_add_monoid.{v} V (@add_comm_group.to_add_group.{v} V _inst_2))) (@sigma.fst.{u 0} ι (λ (i : ι), φ i) ix) (f (@sigma.fst.{u 0} ι (λ (i : ι), φ i) ix) (@sigma.snd.{u 0} ι (λ (i : ι), φ i) ix))) (@domain.to_ring.{v} K (@division_ring.to_domain.{v} K (@field.to_division_ring.{v} K (@discrete_field.to_field.{v} K _inst_1)))) (@finsupp.add_comm_group.{u v} ι V _inst_2) (@finsupp.vector_space.{u v v} ι V K _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α
⊢ @is_basis.{u v (max u v)}
    (@sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit))
    α
    (@mv_polynomial.{u v} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{v} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (λ (sa : @sigma.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit)),
       @mv_polynomial.monomial.{v u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{v} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
               (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))
         (@sigma.fst.{u 0} (@finsupp.{u 0} σ nat nat.has_zero) (λ (_x : @finsupp.{u 0} σ nat nat.has_zero), unit) sa)
         (@has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))))
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{(max u v)}
       (@mv_polynomial.{u v} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{v} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α
                (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
       (@mv_polynomial.ring.{v u} α σ
          (@nonzero_comm_ring.to_comm_ring.{v} α
             (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1)))))
    (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α
⊢ ∀ (i : @finsupp.{u 0} σ nat nat.has_zero),
    @is_basis.{0 v v} unit α α
      ((λ (_x : @finsupp.{u 0} σ nat nat.has_zero) (_x : unit),
          @has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))))
         i)
      (@domain.to_ring.{v} α
         (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
      (@ring.to_add_comm_group.{v} α
         (@domain.to_ring.{v} α
            (@division_ring.to_domain.{v} α
               (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))
      (@discrete_field.to_vector_space.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    intro _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α
⊢ ∀ (i : @finsupp.{u 0} σ nat nat.has_zero),
    @is_basis.{0 v v} unit α α
      ((λ (_x : @finsupp.{u 0} σ nat nat.has_zero) (_x : unit),
          @has_one.one.{v} α
            (@zero_ne_one_class.to_has_one.{v} α
               (@domain.to_zero_ne_one_class.{v} α
                  (@division_ring.to_domain.{v} α
                     (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))))
         i)
      (@domain.to_ring.{v} α
         (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
      (@ring.to_add_comm_group.{v} α
         (@domain.to_ring.{v} α
            (@division_ring.to_domain.{v} α
               (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))
      (@discrete_field.to_vector_space.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
i : @finsupp.{u 0} σ nat nat.has_zero
⊢ @is_basis.{0 v v} unit α α
    ((λ (_x : @finsupp.{u 0} σ nat nat.has_zero) (_x : unit),
        @has_one.one.{v} α
          (@zero_ne_one_class.to_has_one.{v} α
             (@domain.to_zero_ne_one_class.{v} α
                (@division_ring.to_domain.{v} α
                   (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))))
       i)
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{v} α
       (@domain.to_ring.{v} α
          (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))
    (@discrete_field.to_vector_space.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    apply is_basis_singleton_one,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_basis_singleton_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basis.lean&#x27;, &#x27;line&#x27;: 849, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type} (R : Type v) [_inst_6 : unique.{1} ι] [_inst_7 : ring.{v} R], @is_basis.{0 v v} ι R R (λ (_x : ι), @has_one.one.{v} R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R _inst_7))) _inst_7 (@ring.to_add_comm_group.{v} R _inst_7) (@ring.to_module.{v} R _inst_7)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
α : Type v,
_inst_1 : discrete_field.{v} α,
i : @finsupp.{u 0} σ nat nat.has_zero
⊢ @is_basis.{0 v v} unit α α
    ((λ (_x : @finsupp.{u 0} σ nat nat.has_zero) (_x : unit),
        @has_one.one.{v} α
          (@zero_ne_one_class.to_has_one.{v} α
             (@domain.to_zero_ne_one_class.{v} α
                (@division_ring.to_domain.{v} α
                   (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))))
       i)
    (@domain.to_ring.{v} α
       (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1))))
    (@ring.to_add_comm_group.{v} α
       (@domain.to_ring.{v} α
          (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))))
    (@discrete_field.to_vector_space.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  end mv_polynomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  namespace mv_polynomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  variables (σ : Type u) (α : Type u) [discrete_field α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  open_locale classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  lemma dim_mv_polynomial : vector_space.dim α (mv_polynomial σ α) = cardinal.mk (σ →₀ ℕ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Π (β : Type) [_inst_1 : has_zero.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  by rw [← cardinal.lift_inj, ← (is_basis_monomials σ α).mk_eq_dim]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cardinal.lift_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mv_polynomial.is_basis_monomials'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : cardinal.{u}}, iff (@eq.{u+2} cardinal.{u} (cardinal.lift.{u u} a) (cardinal.lift.{u u} b)) (@eq.{u+2} cardinal.{u} a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (σ α : Type u) [_inst_1 : discrete_field.{u} α], @is_basis.{u u u} (@finsupp.{u 0} σ nat nat.has_zero) α (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1))))) (λ (s : @finsupp.{u 0} σ nat nat.has_zero), @mv_polynomial.monomial.{u u} α σ (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))) s (@has_one.one.{u} α (@zero_ne_one_class.to_has_one.{u} α (@domain.to_zero_ne_one_class.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1))))))) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (@ring.to_add_comm_group.{u} (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1))))) (@mv_polynomial.ring.{u u} α σ (@nonzero_comm_ring.to_comm_ring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1))))) (@mv_polynomial.vector_space.{u u} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='σ α : Type u,
_inst_1 : discrete_field.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
       _inst_1
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_1))
    (cardinal.mk.{u} (@finsupp.{u 0} σ nat nat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : discrete_field.{u} α
⊢ @eq.{(max u ?l_1)+2} cardinal.{(max u ?l_1)}
    (cardinal.lift.{u ?l_1}
       (@vector_space.dim.{u u} α
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
          _inst_1
          (@ring.to_add_comm_group.{u}
             (@mv_polynomial.{u u} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                      (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
             (@mv_polynomial.ring.{u u} α σ
                (@nonzero_comm_ring.to_comm_ring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
          (@mv_polynomial.vector_space.{u u} σ α _inst_1)))
    (cardinal.lift.{u ?l_1} (cardinal.mk.{u} (@finsupp.{u 0} σ nat nat.has_zero)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : discrete_field.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
       _inst_1
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_1))
    (cardinal.mk.{u} (@finsupp.{u 0} σ nat nat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : discrete_field.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
       _inst_1
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_1))
    (cardinal.mk.{u} (@finsupp.{u 0} σ nat nat.has_zero))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  end mv_polynomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  namespace mv_polynomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  variables {α : Type*} {σ : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  variables [discrete_field α] [fintype α] [fintype σ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='discrete_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  def indicator (a : σ → α) : mv_polynomial σ α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  finset.univ.prod (λn, 1 - (X n - C (a n))^(fintype.card α - 1))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial.C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pow.pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : fintype.{u_2} α], finset.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type (max u_2 u_1)} [_inst_1 : comm_monoid.{(max u_2 u_1)} β], finset.{u_2} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type (max u_2 u_1)} [c : has_sub.{(max u_2 u_1)} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α], σ → @mv_polynomial.{u_1 u} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_2 u_1)} [c : has_sub.{(max u_2 u_1)} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α], α → @mv_polynomial.{u_1 u} σ α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_2 u_1)} {β : Type} [c : has_pow.{(max u_2 u_1) 0} α β], α → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`X n` is the degree `1` monomial `1*n`'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`C a` is the constant polynomial with value `a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  lemma eval_indicator_apply_eq_one (a : σ → α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    eval a (indicator a) = 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α], (σ → α) → @mv_polynomial.{u_1 u} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], (σ → α) → @mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  have 0 &lt; fintype.card α - 1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α
⊢ @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero)
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    rw [← finite_field.card_units, fintype.card_pos_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finite_field.card_units'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card_pos_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/field_theory/finite.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : decidable_eq.{u_1+1} α], @eq.{1} nat (@fintype.card.{u_1} (@units.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α _inst_1))))) (@finite_field.fintype.{u_1} α _inst_1 _inst_2 (λ (a b : α), _inst_3 a b))) (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : fintype.{u_1} α], iff (@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) (@fintype.card.{u_1} α _inst_1)) (nonempty.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α
⊢ @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero)
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α
⊢ @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero)
    (@fintype.card.{u_1}
       (@units.{u_1} α
          (@ring.to_monoid.{u_1} α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@finite_field.fintype.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1) _inst_2
          (λ (a b : α), @discrete_field.has_decidable_eq.{u_1} α _inst_1 a b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α
⊢ nonempty.{u_1+1}
    (@units.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118    exact ⟨1⟩</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α
⊢ nonempty.{u_1+1}
    (@units.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  by simp only [indicator, (finset.univ.prod_hom (eval a)).symm, eval_sub,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mv_polynomial.eval_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 889, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : discrete_field.{?l_1} α] [_inst_2 : fintype.{?l_1} α] [_inst_3 : fintype.{?l_2} σ], (σ → α) → @mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : fintype.{?l_1} α], finset.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_ring.{?l_1} α] (p : @mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) {q : @mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)} (f : σ → α), @eq.{?l_1+1} α (@mv_polynomial.eval.{?l_1 ?l_2} α σ (@comm_ring.to_comm_semiring.{?l_1} α _inst_1) f (@has_sub.sub.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@add_group_has_sub.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@add_comm_group.to_add_group.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@ring.to_add_comm_group.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@mv_polynomial.ring.{?l_1 ?l_2} α σ _inst_1)))) p q)) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α (@ring.to_add_comm_group.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1)))) (@mv_polynomial.eval.{?l_1 ?l_2} α σ (@comm_ring.to_comm_semiring.{?l_1} α _inst_1) f p) (@mv_polynomial.eval.{?l_1 ?l_2} α σ (@comm_ring.to_comm_semiring.{?l_1} α _inst_1) f q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α,
this :
  @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero)
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 a))
    (@has_one.one.{u_1} α
       (@zero_ne_one_class.to_has_one.{u_1} α
          (@domain.to_zero_ne_one_class.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121      is_ring_hom.map_one (eval a), is_semiring_hom.map_pow (eval a), eval_X, eval_C,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_ring_hom.map_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_semiring_hom.map_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mv_polynomial.eval_X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 476, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} {β : Type u_1} [_inst_1 : ring.{(max u_2 u_1)} α] [_inst_2 : ring.{u_1} β] (f : α → β) [c : @is_ring_hom.{(max u_2 u_1) u_1} α β _inst_1 _inst_2 f], @eq.{u_1+1} β (f (@has_one.one.{(max u_2 u_1)} α (@monoid.to_has_one.{(max u_2 u_1)} α (@ring.to_monoid.{(max u_2 u_1)} α _inst_1)))) (@has_one.one.{u_1} β (@monoid.to_has_one.{u_1} β (@ring.to_monoid.{u_1} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} {β : Type u_1} [_inst_1 : semiring.{(max u_2 u_1)} α] [_inst_2 : semiring.{u_1} β] (f : α → β) [_inst_3 : @is_semiring_hom.{(max u_2 u_1) u_1} α β _inst_1 _inst_2 f] (x : α) (n : nat), @eq.{u_1+1} β (f (@has_pow.pow.{(max u_2 u_1) 0} α nat (@monoid.has_pow.{(max u_2 u_1)} α (@semiring.to_monoid.{(max u_2 u_1)} α _inst_1)) x n)) (@has_pow.pow.{u_1 0} β nat (@monoid.has_pow.{u_1} β (@semiring.to_monoid.{u_1} β _inst_2)) (f x) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α] {f : σ → α} (n : σ), @eq.{?l_1+1} α (@mv_polynomial.eval.{?l_1 ?l_2} α σ _inst_1 f (@mv_polynomial.X.{?l_1 ?l_2} α σ _inst_1 n)) (f n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α] {f : σ → α} (a : α), @eq.{?l_1+1} α (@mv_polynomial.eval.{?l_1 ?l_2} α σ _inst_1 f (@mv_polynomial.C.{?l_1 ?l_2} α σ _inst_1 a)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α,
this :
  @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero)
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 a))
    (@has_one.one.{u_1} α
       (@zero_ne_one_class.to_has_one.{u_1} α
          (@domain.to_zero_ne_one_class.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122      sub_self, zero_pow this, sub_zero, finset.prod_const_one]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='sub_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.prod_const_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 353, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_group.{?l_1} α] (a : α), @eq.{?l_1+1} α (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α _inst_1) a a) (@has_zero.zero.{?l_1} α (@add_monoid.to_has_zero.{?l_1} α (@add_group.to_add_monoid.{?l_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semiring.{?l_1} α] {n : nat}, @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n → @eq.{?l_1+1} α (@has_pow.pow.{?l_1 0} α nat (@monoid.has_pow.{?l_1} α (@semiring.to_monoid.{?l_1} α _inst_1)) (@has_zero.zero.{?l_1} α (@mul_zero_class.to_has_zero.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α _inst_1))) n) (@has_zero.zero.{?l_1} α (@mul_zero_class.to_has_zero.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_group.{?l_1} α] (a : α), @eq.{?l_1+1} α (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α _inst_1) a (@has_zero.zero.{?l_1} α (@add_monoid.to_has_zero.{?l_1} α (@add_group.to_add_monoid.{?l_1} α _inst_1)))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : finset.{?l_1} α} [_inst_1 : comm_monoid.{?l_2} β], @eq.{?l_2+1} β (@finset.prod.{?l_1 ?l_2} α β _inst_1 s (λ (x : α), @has_one.one.{?l_2} β (@monoid.to_has_one.{?l_2} β (@comm_monoid.to_monoid.{?l_2} β _inst_1)))) (@has_one.one.{?l_2} β (@monoid.to_has_one.{?l_2} β (@comm_monoid.to_monoid.{?l_2} β _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α,
this :
  @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero)
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 a))
    (@has_one.one.{u_1} α
       (@zero_ne_one_class.to_has_one.{u_1} α
          (@domain.to_zero_ne_one_class.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : σ → α,
this :
  @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero)
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 a))
    (@has_one.one.{u_1} α
       (@zero_ne_one_class.to_has_one.{u_1} α
          (@domain.to_zero_ne_one_class.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  lemma eval_indicator_apply_eq_zero (a b : σ → α) (h : a ≠ b) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_2 u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    eval a (indicator b) = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α], (σ → α) → @mv_polynomial.{u_1 u} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], (σ → α) → @mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  have ∃i, a i ≠ b i, by rwa [(≠), function.funext_iff, not_forall] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='function.funext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 453, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : α → Type u_1} {f₁ f₂ : Π (x : α), β x}, iff (@eq.{(max (u_2+1) (u_1+1))} (Π (x : α), β x) f₁ f₂) (∀ (a : α), @eq.{u_1+1} (β a) (f₁ a) (f₂ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {p : α → Prop} [_inst_1 : decidable (@Exists.{u_2+1} α (λ (x : α), not (p x)))] [_inst_2 : Π (x : α), decidable (p x)], iff (not (∀ (x : α), p x)) (@Exists.{u_2+1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b
⊢ @Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : not (@eq.{(max (u_2+1) (u_1+1))} (σ → α) a b)
⊢ @Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : not (∀ (a_1 : σ), @eq.{u_1+1} α (a a_1) (b a_1))
⊢ @Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @Exists.{u_2+1} σ (λ (x : σ), not (@eq.{u_1+1} α (a x) (b x)))
⊢ @Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b
⊢ @Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
this : @Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    rcases this with ⟨i, hi⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
this : @Exists.{u_2+1} σ (λ (i : σ), @ne.{u_1+1} α (a i) (b i))
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    simp only [indicator, (finset.univ.prod_hom (eval a)).symm, eval_sub,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mv_polynomial.eval_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 889, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : discrete_field.{?l_1} α] [_inst_2 : fintype.{?l_1} α] [_inst_3 : fintype.{?l_2} σ], (σ → α) → @mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : fintype.{?l_1} α], finset.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_ring.{?l_1} α] (p : @mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) {q : @mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)} (f : σ → α), @eq.{?l_1+1} α (@mv_polynomial.eval.{?l_1 ?l_2} α σ (@comm_ring.to_comm_semiring.{?l_1} α _inst_1) f (@has_sub.sub.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@add_group_has_sub.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@add_comm_group.to_add_group.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@ring.to_add_comm_group.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) (@mv_polynomial.ring.{?l_1 ?l_2} α σ _inst_1)))) p q)) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α (@ring.to_add_comm_group.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1)))) (@mv_polynomial.eval.{?l_1 ?l_2} α σ (@comm_ring.to_comm_semiring.{?l_1} α _inst_1) f p) (@mv_polynomial.eval.{?l_1 ?l_2} α σ (@comm_ring.to_comm_semiring.{?l_1} α _inst_1) f q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130      is_ring_hom.map_one (eval a), is_semiring_hom.map_pow (eval a), eval_X, eval_C,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_ring_hom.map_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_semiring_hom.map_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mv_polynomial.eval_X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ring.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 478, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 476, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} {β : Type u_1} [_inst_1 : ring.{(max u_2 u_1)} α] [_inst_2 : ring.{u_1} β] (f : α → β) [c : @is_ring_hom.{(max u_2 u_1) u_1} α β _inst_1 _inst_2 f], @eq.{u_1+1} β (f (@has_one.one.{(max u_2 u_1)} α (@monoid.to_has_one.{(max u_2 u_1)} α (@ring.to_monoid.{(max u_2 u_1)} α _inst_1)))) (@has_one.one.{u_1} β (@monoid.to_has_one.{u_1} β (@ring.to_monoid.{u_1} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} {β : Type u_1} [_inst_1 : semiring.{(max u_2 u_1)} α] [_inst_2 : semiring.{u_1} β] (f : α → β) [_inst_3 : @is_semiring_hom.{(max u_2 u_1) u_1} α β _inst_1 _inst_2 f] (x : α) (n : nat), @eq.{u_1+1} β (f (@has_pow.pow.{(max u_2 u_1) 0} α nat (@monoid.has_pow.{(max u_2 u_1)} α (@semiring.to_monoid.{(max u_2 u_1)} α _inst_1)) x n)) (@has_pow.pow.{u_1 0} β nat (@monoid.has_pow.{u_1} β (@semiring.to_monoid.{u_1} β _inst_2)) (f x) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α] {f : σ → α} (n : σ), @eq.{?l_1+1} α (@mv_polynomial.eval.{?l_1 ?l_2} α σ _inst_1 f (@mv_polynomial.X.{?l_1 ?l_2} α σ _inst_1 n)) (f n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : comm_semiring.{?l_1} α] {f : σ → α} (a : α), @eq.{?l_1+1} α (@mv_polynomial.eval.{?l_1 ?l_2} α σ _inst_1 f (@mv_polynomial.C.{?l_1 ?l_2} α σ _inst_1 a)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131      sub_self, finset.prod_eq_zero_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='sub_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.prod_eq_zero_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 688, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_group.{?l_1} α] (a : α), @eq.{?l_1+1} α (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α _inst_1) a a) (@has_zero.zero.{?l_1} α (@add_monoid.to_has_zero.{?l_1} α (@add_group.to_add_monoid.{?l_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : finset.{?l_1} α} {f : α → β} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : integral_domain.{?l_2} β], iff (@eq.{?l_2+1} β (@finset.prod.{?l_1 ?l_2} α β (@comm_semiring.to_comm_monoid.{?l_2} β (@nonzero_comm_semiring.to_comm_semiring.{?l_2} β (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_2} β (@integral_domain.to_nonzero_comm_ring.{?l_2} β _inst_2)))) s f) (@has_zero.zero.{?l_2} β (@no_zero_divisors.to_has_zero.{?l_2} β (@domain.to_no_zero_divisors.{?l_2} β (@integral_domain.to_domain.{?l_2} β _inst_2))))) (@Exists.{?l_1+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s) (λ (H : @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s), @eq.{?l_2+1} β (f a) (@has_zero.zero.{?l_2} β (@no_zero_divisors.to_has_zero.{?l_2} β (@domain.to_no_zero_divisors.{?l_2} β (@integral_domain.to_domain.{?l_2} β _inst_2)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       a
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @Exists.{u_2+1} σ
    (λ (a_1 : σ),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) a_1 (@finset.univ.{u_2} σ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) a_1 (@finset.univ.{u_2} σ _inst_3)),
            @eq.{u_1+1} α
              (@has_sub.sub.{u_1} α
                 (@add_group_has_sub.{u_1} α
                    (@add_comm_group.to_add_group.{u_1} α
                       (@ring.to_add_comm_group.{u_1} α
                          (@comm_ring.to_ring.{u_1} α
                             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                 (@has_one.one.{u_1} α
                    (@monoid.to_has_one.{u_1} α
                       (@ring.to_monoid.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                 (@has_pow.pow.{u_1 0} α nat
                    (@monoid.has_pow.{u_1} α
                       (@semiring.to_monoid.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@domain.to_ring.{u_1} α
                                (@division_ring.to_domain.{u_1} α
                                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                    (@has_sub.sub.{u_1} α
                       (@add_group_has_sub.{u_1} α
                          (@add_comm_group.to_add_group.{u_1} α
                             (@ring.to_add_comm_group.{u_1} α
                                (@comm_ring.to_ring.{u_1} α
                                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                       (a a_1)
                       (b a_1))
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                       (@has_one.one.{0} nat nat.has_one))))
              (@has_zero.zero.{u_1} α
                 (@no_zero_divisors.to_has_zero.{u_1} α
                    (@domain.to_no_zero_divisors.{u_1} α
                       (@division_ring.to_domain.{u_1} α
                          (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    refine ⟨i, finset.mem_univ _, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : fintype.{u_2} α] (x : α), @has_mem.mem.{u_2 u_2} α (finset.{u_2} α) (@finset.has_mem.{u_2} α) x (@finset.univ.{u_2} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @Exists.{u_2+1} σ
    (λ (a_1 : σ),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) a_1 (@finset.univ.{u_2} σ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) a_1 (@finset.univ.{u_2} σ _inst_3)),
            @eq.{u_1+1} α
              (@has_sub.sub.{u_1} α
                 (@add_group_has_sub.{u_1} α
                    (@add_comm_group.to_add_group.{u_1} α
                       (@ring.to_add_comm_group.{u_1} α
                          (@comm_ring.to_ring.{u_1} α
                             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                 (@has_one.one.{u_1} α
                    (@monoid.to_has_one.{u_1} α
                       (@ring.to_monoid.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                 (@has_pow.pow.{u_1 0} α nat
                    (@monoid.has_pow.{u_1} α
                       (@semiring.to_monoid.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@domain.to_ring.{u_1} α
                                (@division_ring.to_domain.{u_1} α
                                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                    (@has_sub.sub.{u_1} α
                       (@add_group_has_sub.{u_1} α
                          (@add_comm_group.to_add_group.{u_1} α
                             (@ring.to_add_comm_group.{u_1} α
                                (@comm_ring.to_ring.{u_1} α
                                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                       (a a_1)
                       (b a_1))
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                       (@has_one.one.{0} nat nat.has_one))))
              (@has_zero.zero.{u_1} α
                 (@no_zero_divisors.to_has_zero.{u_1} α
                    (@domain.to_no_zero_divisors.{u_1} α
                       (@division_ring.to_domain.{u_1} α
                          (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @eq.{u_1+1} α
    (@has_sub.sub.{u_1} α
       (@add_group_has_sub.{u_1} α
          (@add_comm_group.to_add_group.{u_1} α
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (@has_one.one.{u_1} α
          (@monoid.to_has_one.{u_1} α
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
       (@has_pow.pow.{u_1 0} α nat
          (@monoid.has_pow.{u_1} α
             (@semiring.to_monoid.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
          (@has_sub.sub.{u_1} α
             (@add_group_has_sub.{u_1} α
                (@add_comm_group.to_add_group.{u_1} α
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α
                               (@discrete_field.local_ring.{u_1} α _inst_1)))))))
             (a i)
             (b i))
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    rw [finite_field.pow_card_sub_one_eq_one, sub_self],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finite_field.pow_card_sub_one_eq_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/field_theory/finite.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] (a : α), @ne.{u_1+1} α a (@has_zero.zero.{u_1} α (@no_zero_divisors.to_has_zero.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))) → @eq.{u_1+1} α (@has_pow.pow.{u_1 0} α nat (@monoid.has_pow.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))) a (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{u_1} α (@zero_ne_one_class.to_has_one.{u_1} α (@domain.to_zero_ne_one_class.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_group.{u_1} α] (a : α), @eq.{u_1+1} α (@has_sub.sub.{u_1} α (@add_group_has_sub.{u_1} α _inst_1) a a) (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α (@add_group.to_add_monoid.{u_1} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @eq.{u_1+1} α
    (@has_sub.sub.{u_1} α
       (@add_group_has_sub.{u_1} α
          (@add_comm_group.to_add_group.{u_1} α
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (@has_one.one.{u_1} α
          (@monoid.to_has_one.{u_1} α
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
       (@has_pow.pow.{u_1 0} α nat
          (@monoid.has_pow.{u_1} α
             (@semiring.to_monoid.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
          (@has_sub.sub.{u_1} α
             (@add_group_has_sub.{u_1} α
                (@add_comm_group.to_add_group.{u_1} α
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α
                               (@discrete_field.local_ring.{u_1} α _inst_1)))))))
             (a i)
             (b i))
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @eq.{u_1+1} α
    (@has_sub.sub.{u_1} α
       (@add_group_has_sub.{u_1} α
          (@add_comm_group.to_add_group.{u_1} α
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (@has_one.one.{u_1} α
          (@monoid.to_has_one.{u_1} α
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
       (@has_one.one.{u_1} α
          (@zero_ne_one_class.to_has_one.{u_1} α
             (@domain.to_zero_ne_one_class.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @ne.{u_1+1} α
    (@has_sub.sub.{u_1} α
       (@add_group_has_sub.{u_1} α
          (@add_comm_group.to_add_group.{u_1} α
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (a i)
       (b i))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @ne.{u_1+1} α
    (@has_sub.sub.{u_1} α
       (@add_group_has_sub.{u_1} α
          (@add_comm_group.to_add_group.{u_1} α
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (a i)
       (b i))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    rwa [(≠), sub_eq_zero],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='sub_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : add_group.{u_1} α] {a b : α}, iff (@eq.{u_1+1} α (@has_sub.sub.{u_1} α (@add_group_has_sub.{u_1} α _inst_1) a b) (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α (@add_group.to_add_monoid.{u_1} α _inst_1)))) (@eq.{u_1+1} α a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ @ne.{u_1+1} α
    (@has_sub.sub.{u_1} α
       (@add_group_has_sub.{u_1} α
          (@add_comm_group.to_add_group.{u_1} α
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (a i)
       (b i))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ not
    (@eq.{u_1+1} α
       (@has_sub.sub.{u_1} α
          (@add_group_has_sub.{u_1} α
             (@add_comm_group.to_add_group.{u_1} α
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
          (a i)
          (b i))
       (@has_zero.zero.{u_1} α
          (@no_zero_divisors.to_has_zero.{u_1} α
             (@domain.to_no_zero_divisors.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a b : σ → α,
h : @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b,
i : σ,
hi : @ne.{u_1+1} α (a i) (b i)
⊢ not (@eq.{u_1+1} α (a i) (b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  lemma degrees_indicator (c : σ → α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    degrees (indicator c) ≤ finset.univ.sum (λs:σ, add_monoid.smul (fintype.card α - 1) {s}) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.degrees'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_monoid.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 598, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α], @mv_polynomial.{u_1 u} σ α _inst_1 → multiset.{u_1} σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], (σ → α) → @mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : fintype.{u_2} α], finset.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2} [_inst_1 : add_comm_monoid.{u_2} β], finset.{u_2} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : add_monoid.{u} α], nat → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u_2} [_inst_1 : has_emptyc.{u_2} γ] [_inst_2 : has_insert.{u_2 u_2} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The maximal degrees of each variable in a multi-variable polynomial, expressed as a multiset.

(For example, `degrees (x^2 * y + y^3)` would be `{x, x, y, y, y}`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c))
    (@finset.sum.{u_2 u_2} σ (multiset.{u_2} σ)
       (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))
       (@finset.univ.{u_2} σ _inst_3)
       (λ (s : σ),
          @add_monoid.smul.{u_2} (multiset.{u_2} σ)
            (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
               (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ)
               s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    rw [indicator],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : discrete_field.{?l_1} α] [_inst_2 : fintype.{?l_1} α] [_inst_3 : fintype.{?l_2} σ], (σ → α) → @mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c))
    (@finset.sum.{u_2 u_2} σ (multiset.{u_2} σ)
       (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))
       (@finset.univ.{u_2} σ _inst_3)
       (λ (s : σ),
          @add_monoid.smul.{u_2} (multiset.{u_2} σ)
            (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
               (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ)
               s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@finset.prod.{u_2 (max u_2 u_1)} σ
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@comm_semiring.to_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.comm_semiring.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{u_2} σ _inst_3)
          (λ (n : σ),
             @has_sub.sub.{(max u_2 u_1)}
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@add_group_has_sub.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@add_comm_group.to_add_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@ring.to_add_comm_group.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@mv_polynomial.ring.{u_1 u_2} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))))
               (@has_one.one.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.has_one.{u_1 u_2} α σ
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
               (@has_pow.pow.{(max u_2 u_1) 0}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  nat
                  (@monoid.has_pow.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@ring.to_monoid.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@mv_polynomial.ring.{u_1 u_2} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))))
                  (@has_sub.sub.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@add_group_has_sub.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@add_comm_group.to_add_group.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@ring.to_add_comm_group.{(max u_2 u_1)}
                              (@mv_polynomial.{u_2 u_1} σ α
                                 (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                    (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                       (@local_ring.to_nonzero_comm_ring.{u_1} α
                                          (@discrete_field.local_ring.{u_1} α _inst_1)))))
                              (@mv_polynomial.ring.{u_1 u_2} α σ
                                 (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                     (@mv_polynomial.X.{u_1 u_2} α σ
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))
                        n)
                     (@mv_polynomial.C.{u_1 u_2} α σ
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))
                        (c n)))
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                     (@has_one.one.{0} nat nat.has_one))))))
    (@finset.sum.{u_2 u_2} σ (multiset.{u_2} σ)
       (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))
       (@finset.univ.{u_2} σ _inst_3)
       (λ (s : σ),
          @add_monoid.smul.{u_2} (multiset.{u_2} σ)
            (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
               (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ)
               s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    refine le_trans (degrees_prod _ _) (finset.sum_le_sum $ assume s hs, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.degrees_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finset.sum_le_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 655, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 698, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) b c → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α] {ι : Type u_2} (s : finset.{u_2} ι) (f : ι → @mv_polynomial.{u_2 u_1} σ α _inst_1), @has_le.le.{u_2} (multiset.{u_2} σ) (@preorder.to_has_le.{u_2} (multiset.{u_2} σ) (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ))) (@mv_polynomial.degrees.{u_1 u_2} α σ _inst_1 (@finset.prod.{u_2 (max u_2 u_1)} ι (@mv_polynomial.{u_2 u_1} σ α _inst_1) (@comm_semiring.to_comm_monoid.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α _inst_1) (@mv_polynomial.comm_semiring.{u_1 u_2} α σ _inst_1)) s f)) (@finset.sum.{u_2 u_2} ι (multiset.{u_2} σ) (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ) (@multiset.ordered_cancel_comm_monoid.{u_2} σ))) s (λ (i : ι), @mv_polynomial.degrees.{u_1 u_2} α σ _inst_1 (f i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u_2} {s : finset.{u_2} α} {f g : α → β} [_inst_1 : decidable_eq.{u_2+1} α] [_inst_2 : ordered_comm_monoid.{u_2} β], (∀ (x : α), @has_mem.mem.{u_2 u_2} α (finset.{u_2} α) (@finset.has_mem.{u_2} α) x s → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@ordered_comm_monoid.to_partial_order.{u_2} β _inst_2))) (f x) (g x)) → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@ordered_comm_monoid.to_partial_order.{u_2} β _inst_2))) (@finset.sum.{u_2 u_2} α β (@ordered_comm_monoid.to_add_comm_monoid.{u_2} β _inst_2) s f) (@finset.sum.{u_2 u_2} α β (@ordered_comm_monoid.to_add_comm_monoid.{u_2} β _inst_2) s g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@finset.prod.{u_2 (max u_2 u_1)} σ
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@comm_semiring.to_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.comm_semiring.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{u_2} σ _inst_3)
          (λ (n : σ),
             @has_sub.sub.{(max u_2 u_1)}
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@add_group_has_sub.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@add_comm_group.to_add_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@ring.to_add_comm_group.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@mv_polynomial.ring.{u_1 u_2} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))))
               (@has_one.one.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.has_one.{u_1 u_2} α σ
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
               (@has_pow.pow.{(max u_2 u_1) 0}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  nat
                  (@monoid.has_pow.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@ring.to_monoid.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@mv_polynomial.ring.{u_1 u_2} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))))
                  (@has_sub.sub.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@add_group_has_sub.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@add_comm_group.to_add_group.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@ring.to_add_comm_group.{(max u_2 u_1)}
                              (@mv_polynomial.{u_2 u_1} σ α
                                 (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                    (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                       (@local_ring.to_nonzero_comm_ring.{u_1} α
                                          (@discrete_field.local_ring.{u_1} α _inst_1)))))
                              (@mv_polynomial.ring.{u_1 u_2} α σ
                                 (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                     (@mv_polynomial.X.{u_1 u_2} α σ
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))
                        n)
                     (@mv_polynomial.C.{u_1 u_2} α σ
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))
                        (c n)))
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                     (@has_one.one.{0} nat nat.has_one))))))
    (@finset.sum.{u_2 u_2} σ (multiset.{u_2} σ)
       (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))
       (@finset.univ.{u_2} σ _inst_3)
       (λ (s : σ),
          @add_monoid.smul.{u_2} (multiset.{u_2} σ)
            (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
               (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ)
               s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_partial_order.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@has_sub.sub.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@add_group_has_sub.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@add_comm_group.to_add_group.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_add_comm_group.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
          (@has_one.one.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.has_one.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@has_pow.pow.{(max u_2 u_1) 0}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             nat
             (@monoid.has_pow.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@has_sub.sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_group_has_sub.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@mv_polynomial.X.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   s)
                (@mv_polynomial.C.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   (c s)))
             (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    refine le_trans (degrees_sub _ _) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.degrees_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 842, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) b c → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_ring.{u_1} α] (p q : @mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)), @has_le.le.{u_2} (multiset.{u_2} σ) (@preorder.to_has_le.{u_2} (multiset.{u_2} σ) (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ))) (@mv_polynomial.degrees.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1) (@has_sub.sub.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@add_group_has_sub.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@add_comm_group.to_add_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@mv_polynomial.ring.{u_1 u_2} α σ _inst_1)))) p q)) (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ) (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ) (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ) (@multiset.lattice.semilattice_sup_bot.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))))) (@mv_polynomial.degrees.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1) p) (@mv_polynomial.degrees.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1) q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_partial_order.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@has_sub.sub.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@add_group_has_sub.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@add_comm_group.to_add_group.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_add_comm_group.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
          (@has_one.one.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.has_one.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@has_pow.pow.{(max u_2 u_1) 0}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             nat
             (@monoid.has_pow.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@has_sub.sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_group_has_sub.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@mv_polynomial.X.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   s)
                (@mv_polynomial.C.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   (c s)))
             (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@has_one.one.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.has_one.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@has_pow.pow.{(max u_2 u_1) 0}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             nat
             (@monoid.has_pow.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@has_sub.sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_group_has_sub.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@mv_polynomial.X.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   s)
                (@mv_polynomial.C.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   (c s)))
             (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    rw [degrees_one, ← bot_eq_zero, bot_sup_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.degrees_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='bot_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.bot_sup_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 624, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 357, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], @eq.{u_2+1} (multiset.{u_2} σ) (@mv_polynomial.degrees.{u_1 u_2} α σ _inst_1 (@has_one.one.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α _inst_1) (@mv_polynomial.has_one.{u_1 u_2} α σ _inst_1))) (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : canonically_ordered_monoid.{u_2} α], @eq.{u_2+1} α (@lattice.has_bot.bot.{u_2} α (@lattice.order_bot.to_has_bot.{u_2} α (@canonically_ordered_monoid.to_order_bot.{u_2} α _inst_1))) (@has_zero.zero.{u_2} α (@add_monoid.to_has_zero.{u_2} α (@add_comm_monoid.to_add_monoid.{u_2} α (@ordered_comm_monoid.to_add_comm_monoid.{u_2} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{u_2} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : lattice.semilattice_sup_bot.{u_2} α] {a : α}, @eq.{u_2+1} α (@lattice.has_sup.sup.{u_2} α (@lattice.semilattice_sup.to_has_sup.{u_2} α (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} α _inst_1)) (@lattice.has_bot.bot.{u_2} α (@lattice.order_bot.to_has_bot.{u_2} α (@lattice.semilattice_sup_bot.to_order_bot.{u_2} α _inst_1))) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@has_one.one.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.has_one.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@has_pow.pow.{(max u_2 u_1) 0}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             nat
             (@monoid.has_pow.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@has_sub.sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_group_has_sub.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@mv_polynomial.X.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   s)
                (@mv_polynomial.C.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   (c s)))
             (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@has_pow.pow.{(max u_2 u_1) 0}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             nat
             (@monoid.has_pow.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@has_sub.sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_group_has_sub.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@mv_polynomial.X.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   s)
                (@mv_polynomial.C.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   (c s)))
             (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@lattice.has_bot.bot.{u_2} (multiset.{u_2} σ)
          (@lattice.order_bot.to_has_bot.{u_2} (multiset.{u_2} σ)
             (@canonically_ordered_monoid.to_order_bot.{u_2} (multiset.{u_2} σ)
                (@multiset.canonically_ordered_monoid.{u_2} σ))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@has_pow.pow.{(max u_2 u_1) 0}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             nat
             (@monoid.has_pow.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@has_sub.sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_group_has_sub.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@mv_polynomial.X.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   s)
                (@mv_polynomial.C.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                   (c s)))
             (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@has_pow.pow.{(max u_2 u_1) 0}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          nat
          (@monoid.has_pow.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_monoid.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@has_sub.sub.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@add_group_has_sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_comm_group.to_add_group.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@ring.to_add_comm_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@mv_polynomial.ring.{u_1 u_2} α σ
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α
                               (@discrete_field.local_ring.{u_1} α _inst_1)))))))
             (@mv_polynomial.X.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                s)
             (@mv_polynomial.C.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                (c s)))
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    refine le_trans (degrees_pow _ _) (add_monoid.smul_le_smul_of_le_right _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.degrees_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='add_monoid.smul_le_smul_of_le_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 665, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 532, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) b c → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α] (p : @mv_polynomial.{u_2 u_1} σ α _inst_1) (n : nat), @has_le.le.{u_2} (multiset.{u_2} σ) (@preorder.to_has_le.{u_2} (multiset.{u_2} σ) (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ))) (@mv_polynomial.degrees.{u_1 u_2} α σ _inst_1 (@has_pow.pow.{(max u_2 u_1) 0} (@mv_polynomial.{u_2 u_1} σ α _inst_1) nat (@monoid.has_pow.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α _inst_1) (@semiring.to_monoid.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α _inst_1) (@comm_semiring.to_semiring.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α _inst_1) (@mv_polynomial.comm_semiring.{u_1 u_2} α σ _inst_1)))) p n)) (@add_monoid.smul.{u_2} (multiset.{u_2} σ) (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ) (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ) (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))) n (@mv_polynomial.degrees.{u_1 u_2} α σ _inst_1 p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : ordered_comm_monoid.{u_2} α] {a b : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α (@partial_order.to_preorder.{u_2} α (@ordered_comm_monoid.to_partial_order.{u_2} α _inst_1))) a b → ∀ (i : nat), @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α (@partial_order.to_preorder.{u_2} α (@ordered_comm_monoid.to_partial_order.{u_2} α _inst_1))) (@add_monoid.smul.{u_2} α (@add_comm_monoid.to_add_monoid.{u_2} α (@ordered_comm_monoid.to_add_comm_monoid.{u_2} α _inst_1)) i a) (@add_monoid.smul.{u_2} α (@add_comm_monoid.to_add_monoid.{u_2} α (@ordered_comm_monoid.to_add_comm_monoid.{u_2} α _inst_1)) i b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@has_pow.pow.{(max u_2 u_1) 0}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          nat
          (@monoid.has_pow.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_monoid.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@has_sub.sub.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@add_group_has_sub.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@add_comm_group.to_add_group.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@ring.to_add_comm_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@mv_polynomial.ring.{u_1 u_2} α σ
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α
                               (@discrete_field.local_ring.{u_1} α _inst_1)))))))
             (@mv_polynomial.X.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                s)
             (@mv_polynomial.C.{u_1 u_2} α σ
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
                (c s)))
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))))
    (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
       (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_partial_order.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@has_sub.sub.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@add_group_has_sub.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@add_comm_group.to_add_group.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_add_comm_group.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
          (@mv_polynomial.X.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             s)
          (@mv_polynomial.C.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             (c s))))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    refine le_trans (degrees_sub _ _) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.degrees_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 842, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) b c → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_ring.{u_1} α] (p q : @mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)), @has_le.le.{u_2} (multiset.{u_2} σ) (@preorder.to_has_le.{u_2} (multiset.{u_2} σ) (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ))) (@mv_polynomial.degrees.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1) (@has_sub.sub.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@add_group_has_sub.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@add_comm_group.to_add_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@mv_polynomial.ring.{u_1 u_2} α σ _inst_1)))) p q)) (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ) (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ) (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ) (@multiset.lattice.semilattice_sup_bot.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))))) (@mv_polynomial.degrees.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1) p) (@mv_polynomial.degrees.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1) q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_partial_order.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@has_sub.sub.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@add_group_has_sub.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@add_comm_group.to_add_group.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_add_comm_group.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@mv_polynomial.ring.{u_1 u_2} α σ
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
          (@mv_polynomial.X.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             s)
          (@mv_polynomial.C.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             (c s))))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@mv_polynomial.X.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             s))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@mv_polynomial.C.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             (c s))))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    rw [degrees_C, ← bot_eq_zero, sup_bot_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.degrees_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='bot_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.sup_bot_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 615, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 357, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 177, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α] (a : α), @eq.{u_2+1} (multiset.{u_2} σ) (@mv_polynomial.degrees.{u_1 u_2} α σ _inst_1 (@mv_polynomial.C.{u_1 u_2} α σ _inst_1 a)) (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : canonically_ordered_monoid.{u_2} α], @eq.{u_2+1} α (@lattice.has_bot.bot.{u_2} α (@lattice.order_bot.to_has_bot.{u_2} α (@canonically_ordered_monoid.to_order_bot.{u_2} α _inst_1))) (@has_zero.zero.{u_2} α (@add_monoid.to_has_zero.{u_2} α (@add_comm_monoid.to_add_monoid.{u_2} α (@ordered_comm_monoid.to_add_comm_monoid.{u_2} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{u_2} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : lattice.semilattice_sup_bot.{u_2} α] {a : α}, @eq.{u_2+1} α (@lattice.has_sup.sup.{u_2} α (@lattice.semilattice_sup.to_has_sup.{u_2} α (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} α _inst_1)) a (@lattice.has_bot.bot.{u_2} α (@lattice.order_bot.to_has_bot.{u_2} α (@lattice.semilattice_sup_bot.to_order_bot.{u_2} α _inst_1)))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@mv_polynomial.X.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             s))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@mv_polynomial.C.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             (c s))))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@mv_polynomial.X.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             s))
       (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@lattice.has_sup.sup.{u_2} (multiset.{u_2} σ)
       (@lattice.semilattice_sup.to_has_sup.{u_2} (multiset.{u_2} σ)
          (@lattice.semilattice_sup_bot.to_semilattice_sup.{u_2} (multiset.{u_2} σ)
             (@multiset.lattice.semilattice_sup_bot.{u_2} σ
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)))))
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@comm_ring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@mv_polynomial.X.{u_1 u_2} α σ
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             s))
       (@lattice.has_bot.bot.{u_2} (multiset.{u_2} σ)
          (@lattice.order_bot.to_has_bot.{u_2} (multiset.{u_2} σ)
             (@canonically_ordered_monoid.to_order_bot.{u_2} (multiset.{u_2} σ)
                (@multiset.canonically_ordered_monoid.{u_2} σ)))))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@mv_polynomial.X.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          s))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    exact degrees_X _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mv_polynomial.degrees_X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 618, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α] (n : σ), @has_le.le.{u_2} (multiset.{u_2} σ) (@preorder.to_has_le.{u_2} (multiset.{u_2} σ) (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ))) (@mv_polynomial.degrees.{u_1 u_2} α σ _inst_1 (@mv_polynomial.X.{u_1 u_2} α σ _inst_1 n)) (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
s : σ,
hs : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) s (@finset.univ.{u_2} σ _inst_3)
⊢ @has_le.le.{u_2} (multiset.{u_2} σ)
    (@preorder.to_has_le.{u_2} (multiset.{u_2} σ)
       (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ)))
    (@mv_polynomial.degrees.{u_1 u_2} α σ
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       (@mv_polynomial.X.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          s))
    (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  set_option class.instance_max_depth 50</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  lemma indicator_mem_restrict_degree (c : σ → α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    indicator c ∈ restrict_degree σ α (fintype.card α - 1) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], (σ → α) → @mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type (max u_2 u_1)} [c : has_mem.{(max u_2 u_1) (max u_2 u_1)} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (σ : Type u) (α : Type v), nat → Π [_inst_1 : discrete_field.{v} α], @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)}
    (@mv_polynomial.{u_2 u_1} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
    (@submodule.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c)
    (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    rw [mem_restrict_degree_iff_sup, indicator],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.mem_restrict_degree_iff_sup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {σ : Type u_2} {α : Type u_1} [_inst_1 : discrete_field.{u_1} α] (p : @mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (n : nat), iff (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@submodule.{u_1 (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.ring.{u_1 u_2} α σ (@nonzero_comm_ring.to_comm_ring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)) (@submodule.has_mem.{u_1 (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.ring.{u_1 u_2} α σ (@nonzero_comm_ring.to_comm_ring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)) p (@mv_polynomial.restrict_degree.{u_2 u_1} σ α n _inst_1)) (∀ (i : σ), @has_le.le.{0} nat nat.has_le (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) i (@mv_polynomial.degrees.{u_1 u_2} α σ (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))) p)) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : discrete_field.{?l_1} α] [_inst_2 : fintype.{?l_1} α] [_inst_3 : fintype.{?l_2} σ], (σ → α) → @mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)}
    (@mv_polynomial.{u_2 u_1} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
    (@submodule.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c)
    (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ ∀ (i : σ),
    @has_le.le.{0} nat nat.has_le
      (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) i
         (@mv_polynomial.degrees.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c)))
      (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ ∀ (i : σ),
    @has_le.le.{0} nat nat.has_le
      (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) i
         (@mv_polynomial.degrees.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            (@finset.prod.{u_2 (max u_2 u_1)} σ
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@comm_semiring.to_comm_monoid.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.comm_semiring.{u_1 u_2} α σ
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
               (@finset.univ.{u_2} σ _inst_3)
               (λ (n : σ),
                  @has_sub.sub.{(max u_2 u_1)}
                    (@mv_polynomial.{u_2 u_1} σ α
                       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                             (@local_ring.to_nonzero_comm_ring.{u_1} α
                                (@discrete_field.local_ring.{u_1} α _inst_1)))))
                    (@add_group_has_sub.{(max u_2 u_1)}
                       (@mv_polynomial.{u_2 u_1} σ α
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))
                       (@add_comm_group.to_add_group.{(max u_2 u_1)}
                          (@mv_polynomial.{u_2 u_1} σ α
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))
                          (@ring.to_add_comm_group.{(max u_2 u_1)}
                             (@mv_polynomial.{u_2 u_1} σ α
                                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))
                             (@mv_polynomial.ring.{u_1 u_2} α σ
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                    (@has_one.one.{(max u_2 u_1)}
                       (@mv_polynomial.{u_2 u_1} σ α
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))
                       (@mv_polynomial.has_one.{u_1 u_2} α σ
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1))))))
                    (@has_pow.pow.{(max u_2 u_1) 0}
                       (@mv_polynomial.{u_2 u_1} σ α
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))
                       nat
                       (@monoid.has_pow.{(max u_2 u_1)}
                          (@mv_polynomial.{u_2 u_1} σ α
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))
                          (@ring.to_monoid.{(max u_2 u_1)}
                             (@mv_polynomial.{u_2 u_1} σ α
                                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))
                             (@mv_polynomial.ring.{u_1 u_2} α σ
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1))))))
                       (@has_sub.sub.{(max u_2 u_1)}
                          (@mv_polynomial.{u_2 u_1} σ α
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))
                          (@add_group_has_sub.{(max u_2 u_1)}
                             (@mv_polynomial.{u_2 u_1} σ α
                                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))
                             (@add_comm_group.to_add_group.{(max u_2 u_1)}
                                (@mv_polynomial.{u_2 u_1} σ α
                                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                         (@local_ring.to_nonzero_comm_ring.{u_1} α
                                            (@discrete_field.local_ring.{u_1} α _inst_1)))))
                                (@ring.to_add_comm_group.{(max u_2 u_1)}
                                   (@mv_polynomial.{u_2 u_1} σ α
                                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                            (@local_ring.to_nonzero_comm_ring.{u_1} α
                                               (@discrete_field.local_ring.{u_1} α _inst_1)))))
                                   (@mv_polynomial.ring.{u_1 u_2} α σ
                                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                         (@local_ring.to_nonzero_comm_ring.{u_1} α
                                            (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                          (@mv_polynomial.X.{u_1 u_2} α σ
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1))))
                             n)
                          (@mv_polynomial.C.{u_1 u_2} α σ
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1))))
                             (c n)))
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                          (@has_one.one.{0} nat nat.has_one)))))))
      (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    assume n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α
⊢ ∀ (i : σ),
    @has_le.le.{0} nat nat.has_le
      (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) i
         (@mv_polynomial.degrees.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            (@finset.prod.{u_2 (max u_2 u_1)} σ
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@comm_semiring.to_comm_monoid.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.comm_semiring.{u_1 u_2} α σ
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
               (@finset.univ.{u_2} σ _inst_3)
               (λ (n : σ),
                  @has_sub.sub.{(max u_2 u_1)}
                    (@mv_polynomial.{u_2 u_1} σ α
                       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                             (@local_ring.to_nonzero_comm_ring.{u_1} α
                                (@discrete_field.local_ring.{u_1} α _inst_1)))))
                    (@add_group_has_sub.{(max u_2 u_1)}
                       (@mv_polynomial.{u_2 u_1} σ α
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))
                       (@add_comm_group.to_add_group.{(max u_2 u_1)}
                          (@mv_polynomial.{u_2 u_1} σ α
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))
                          (@ring.to_add_comm_group.{(max u_2 u_1)}
                             (@mv_polynomial.{u_2 u_1} σ α
                                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))
                             (@mv_polynomial.ring.{u_1 u_2} α σ
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                    (@has_one.one.{(max u_2 u_1)}
                       (@mv_polynomial.{u_2 u_1} σ α
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))
                       (@mv_polynomial.has_one.{u_1 u_2} α σ
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1))))))
                    (@has_pow.pow.{(max u_2 u_1) 0}
                       (@mv_polynomial.{u_2 u_1} σ α
                          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                (@local_ring.to_nonzero_comm_ring.{u_1} α
                                   (@discrete_field.local_ring.{u_1} α _inst_1)))))
                       nat
                       (@monoid.has_pow.{(max u_2 u_1)}
                          (@mv_polynomial.{u_2 u_1} σ α
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))
                          (@ring.to_monoid.{(max u_2 u_1)}
                             (@mv_polynomial.{u_2 u_1} σ α
                                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))
                             (@mv_polynomial.ring.{u_1 u_2} α σ
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1))))))
                       (@has_sub.sub.{(max u_2 u_1)}
                          (@mv_polynomial.{u_2 u_1} σ α
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1)))))
                          (@add_group_has_sub.{(max u_2 u_1)}
                             (@mv_polynomial.{u_2 u_1} σ α
                                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                      (@local_ring.to_nonzero_comm_ring.{u_1} α
                                         (@discrete_field.local_ring.{u_1} α _inst_1)))))
                             (@add_comm_group.to_add_group.{(max u_2 u_1)}
                                (@mv_polynomial.{u_2 u_1} σ α
                                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                         (@local_ring.to_nonzero_comm_ring.{u_1} α
                                            (@discrete_field.local_ring.{u_1} α _inst_1)))))
                                (@ring.to_add_comm_group.{(max u_2 u_1)}
                                   (@mv_polynomial.{u_2 u_1} σ α
                                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                            (@local_ring.to_nonzero_comm_ring.{u_1} α
                                               (@discrete_field.local_ring.{u_1} α _inst_1)))))
                                   (@mv_polynomial.ring.{u_1 u_2} α σ
                                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                         (@local_ring.to_nonzero_comm_ring.{u_1} α
                                            (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                          (@mv_polynomial.X.{u_1 u_2} α σ
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1))))
                             n)
                          (@mv_polynomial.C.{u_1 u_2} α σ
                             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                   (@local_ring.to_nonzero_comm_ring.{u_1} α
                                      (@discrete_field.local_ring.{u_1} α _inst_1))))
                             (c n)))
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                          (@has_one.one.{0} nat nat.has_one)))))))
      (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @has_le.le.{0} nat nat.has_le
    (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@finset.prod.{u_2 (max u_2 u_1)} σ
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@comm_semiring.to_comm_monoid.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.comm_semiring.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@finset.univ.{u_2} σ _inst_3)
             (λ (n : σ),
                @has_sub.sub.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@add_group_has_sub.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@add_comm_group.to_add_group.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@ring.to_add_comm_group.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@mv_polynomial.ring.{u_1 u_2} α σ
                              (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                  (@has_one.one.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.has_one.{u_1 u_2} α σ
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))))
                  (@has_pow.pow.{(max u_2 u_1) 0}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     nat
                     (@monoid.has_pow.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@ring.to_monoid.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@mv_polynomial.ring.{u_1 u_2} α σ
                              (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1))))))
                     (@has_sub.sub.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@add_group_has_sub.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@add_comm_group.to_add_group.{(max u_2 u_1)}
                              (@mv_polynomial.{u_2 u_1} σ α
                                 (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                    (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                       (@local_ring.to_nonzero_comm_ring.{u_1} α
                                          (@discrete_field.local_ring.{u_1} α _inst_1)))))
                              (@ring.to_add_comm_group.{(max u_2 u_1)}
                                 (@mv_polynomial.{u_2 u_1} σ α
                                    (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                          (@local_ring.to_nonzero_comm_ring.{u_1} α
                                             (@discrete_field.local_ring.{u_1} α _inst_1)))))
                                 (@mv_polynomial.ring.{u_1 u_2} α σ
                                    (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                       (@local_ring.to_nonzero_comm_ring.{u_1} α
                                          (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                        (@mv_polynomial.X.{u_1 u_2} α σ
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1))))
                           n)
                        (@mv_polynomial.C.{u_1 u_2} α σ
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1))))
                           (c n)))
                     (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                        (@has_one.one.{0} nat nat.has_one)))))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    refine le_trans (multiset.count_le_of_le _ $ degrees_indicator _) (le_of_eq _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.count_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mv_polynomial.degrees_indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='le_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1861, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 137, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : decidable_eq.{u_2+1} α] (a : α) {s t : multiset.{u_2} α}, @has_le.le.{u_2} (multiset.{u_2} α) (@preorder.to_has_le.{u_2} (multiset.{u_2} α) (@partial_order.to_preorder.{u_2} (multiset.{u_2} α) (@multiset.partial_order.{u_2} α))) s t → @has_le.le.{0} nat nat.has_le (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a s) (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ] (c : σ → α), @has_le.le.{u_2} (multiset.{u_2} σ) (@preorder.to_has_le.{u_2} (multiset.{u_2} σ) (@partial_order.to_preorder.{u_2} (multiset.{u_2} σ) (@multiset.partial_order.{u_2} σ))) (@mv_polynomial.degrees.{u_1 u_2} α σ (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))) (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c)) (@finset.sum.{u_2 u_2} σ (multiset.{u_2} σ) (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ) (@multiset.ordered_cancel_comm_monoid.{u_2} σ))) (@finset.univ.{u_2} σ _inst_3) (λ (s : σ), @add_monoid.smul.{u_2} (multiset.{u_2} σ) (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ) (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ) (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ) (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))) (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)) (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ) (@multiset.has_insert.{u_2} σ) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @eq.{1} α a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @has_le.le.{0} nat nat.has_le
    (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
       (@mv_polynomial.degrees.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          (@finset.prod.{u_2 (max u_2 u_1)} σ
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@comm_semiring.to_comm_monoid.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.comm_semiring.{u_1 u_2} α σ
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
             (@finset.univ.{u_2} σ _inst_3)
             (λ (n : σ),
                @has_sub.sub.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@add_group_has_sub.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@add_comm_group.to_add_group.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@ring.to_add_comm_group.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@mv_polynomial.ring.{u_1 u_2} α σ
                              (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                  (@has_one.one.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.has_one.{u_1 u_2} α σ
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1))))))
                  (@has_pow.pow.{(max u_2 u_1) 0}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     nat
                     (@monoid.has_pow.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@ring.to_monoid.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@mv_polynomial.ring.{u_1 u_2} α σ
                              (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1))))))
                     (@has_sub.sub.{(max u_2 u_1)}
                        (@mv_polynomial.{u_2 u_1} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1)))))
                        (@add_group_has_sub.{(max u_2 u_1)}
                           (@mv_polynomial.{u_2 u_1} σ α
                              (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                 (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                    (@local_ring.to_nonzero_comm_ring.{u_1} α
                                       (@discrete_field.local_ring.{u_1} α _inst_1)))))
                           (@add_comm_group.to_add_group.{(max u_2 u_1)}
                              (@mv_polynomial.{u_2 u_1} σ α
                                 (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                    (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                       (@local_ring.to_nonzero_comm_ring.{u_1} α
                                          (@discrete_field.local_ring.{u_1} α _inst_1)))))
                              (@ring.to_add_comm_group.{(max u_2 u_1)}
                                 (@mv_polynomial.{u_2 u_1} σ α
                                    (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                                       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                          (@local_ring.to_nonzero_comm_ring.{u_1} α
                                             (@discrete_field.local_ring.{u_1} α _inst_1)))))
                                 (@mv_polynomial.ring.{u_1 u_2} α σ
                                    (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                       (@local_ring.to_nonzero_comm_ring.{u_1} α
                                          (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                        (@mv_polynomial.X.{u_1 u_2} α σ
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1))))
                           n)
                        (@mv_polynomial.C.{u_1 u_2} α σ
                           (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                 (@local_ring.to_nonzero_comm_ring.{u_1} α
                                    (@discrete_field.local_ring.{u_1} α _inst_1))))
                           (c n)))
                     (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2)
                        (@has_one.one.{0} nat nat.has_one)))))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
       (@finset.sum.{u_2 u_2} σ (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))
          (@finset.univ.{u_2} σ _inst_3)
          (λ (s : σ),
             @add_monoid.smul.{u_2} (multiset.{u_2} σ)
               (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                        (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
               (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ)
                  (@multiset.has_insert.{u_2} σ)
                  s))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    rw [← finset.univ.sum_hom (multiset.count n)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.count'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1849, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : fintype.{u_2} α], finset.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : decidable_eq.{u_2+1} α], α → multiset.{u_2} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`count a s` is the multiplicity of `a` in `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
       (@finset.sum.{u_2 u_2} σ (multiset.{u_2} σ)
          (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                (@multiset.ordered_cancel_comm_monoid.{u_2} σ)))
          (@finset.univ.{u_2} σ _inst_3)
          (λ (s : σ),
             @add_monoid.smul.{u_2} (multiset.{u_2} σ)
               (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                        (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
               (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ)
                  (@multiset.has_insert.{u_2} σ)
                  s))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@finset.sum.{u_2 0} σ nat nat.add_comm_monoid (@finset.univ.{u_2} σ _inst_3)
       (λ (x : σ),
          @multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
            (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
               (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                        (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
               (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ)
                  (@multiset.has_insert.{u_2} σ)
                  x))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158    simp only [is_add_monoid_hom.map_smul (multiset.count n), multiset.singleton_eq_singleton,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='is_add_monoid_hom.map_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.count'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='multiset.singleton_eq_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1849, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 362, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type} [_inst_1 : add_monoid.{u_2} α] [_inst_2 : add_monoid.{0} β] (f : α → β) [_inst_3 : @is_add_monoid_hom.{u_2 0} α β _inst_1 _inst_2 f] (a : α) (n : nat), @eq.{1} β (f (@add_monoid.smul.{u_2} α _inst_1 n a)) (@add_monoid.smul.{0} β _inst_2 n (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : decidable_eq.{u_2+1} α], α → multiset.{u_2} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (a : α), @eq.{?l_1+1} (multiset.{?l_1} α) (@singleton.{?l_1 ?l_1} α (multiset.{?l_1} α) (@multiset.has_emptyc.{?l_1} α) (@multiset.has_insert.{?l_1} α) a) (@multiset.cons.{?l_1} α a (@has_zero.zero.{?l_1} (multiset.{?l_1} α) (@multiset.has_zero.{?l_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`count a s` is the multiplicity of `a` in `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@finset.sum.{u_2 0} σ nat nat.add_comm_monoid (@finset.univ.{u_2} σ _inst_3)
       (λ (x : σ),
          @multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
            (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
               (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                        (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
               (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ)
                  (@multiset.has_insert.{u_2} σ)
                  x))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159      add_monoid.smul_eq_mul, nat.cast_id],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='add_monoid.smul_eq_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.cast_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 419, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/cast.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semiring.{?l_1} α] (n : nat) (a : α), @eq.{?l_1+1} α (@add_monoid.smul.{?l_1} α (@add_comm_monoid.to_add_monoid.{?l_1} α (@semiring.to_add_comm_monoid.{?l_1} α _inst_1)) n a) (@has_mul.mul.{?l_1} α (@mul_zero_class.to_has_mul.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α _inst_1)) (@coe.{1 ?l_1+1} nat α (@coe_to_lift.{1 ?l_1+1} nat α (@coe_base.{1 ?l_1+1} nat α (@nat.cast_coe.{?l_1} α (@mul_zero_class.to_has_zero.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α _inst_1)) (@monoid.to_has_one.{?l_1} α (@semiring.to_monoid.{?l_1} α _inst_1)) (@distrib.to_has_add.{?l_1} α (@semiring.to_distrib.{?l_1} α _inst_1))))) n) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @eq.{1} nat (@coe.{1 1} nat nat (@coe_to_lift.{1 1} nat nat (@coe_base.{1 1} nat nat (@nat.cast_coe.{0} nat nat.has_zero nat.has_one nat.has_add))) n) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@finset.sum.{u_2 0} σ nat nat.add_comm_monoid (@finset.univ.{u_2} σ _inst_3)
       (λ (x : σ),
          @multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
            (@add_monoid.smul.{u_2} (multiset.{u_2} σ)
               (@add_comm_monoid.to_add_monoid.{u_2} (multiset.{u_2} σ)
                  (@ordered_comm_monoid.to_add_comm_monoid.{u_2} (multiset.{u_2} σ)
                     (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{u_2} (multiset.{u_2} σ)
                        (@multiset.ordered_cancel_comm_monoid.{u_2} σ))))
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
               (@singleton.{u_2 u_2} σ (multiset.{u_2} σ) (@multiset.has_emptyc.{u_2} σ)
                  (@multiset.has_insert.{u_2} σ)
                  x))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@finset.sum.{u_2 0} σ nat nat.add_comm_monoid (@finset.univ.{u_2} σ _inst_3)
       (λ (x : σ),
          @has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
               (@multiset.cons.{u_2} σ x (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@finset.sum.{u_2 0} σ nat nat.add_comm_monoid (@finset.univ.{u_2} σ _inst_3)
       (λ (x : σ),
          @has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
               (@multiset.cons.{u_2} σ x (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@finset.sum.{u_2 0} σ nat nat.add_comm_monoid (@finset.univ.{u_2} σ _inst_3)
       (λ (x : σ),
          @has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
               (@multiset.cons.{u_2} σ x (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))))))
    ?m_1

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat ?m_1
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161    refine finset.sum_eq_single n _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='finset.sum_eq_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type} [_inst_1 : add_comm_monoid.{0} β] {s : finset.{u_2} α} {f : α → β} (a : α), (∀ (b : α), @has_mem.mem.{u_2 u_2} α (finset.{u_2} α) (@finset.has_mem.{u_2} α) b s → @ne.{u_2+1} α b a → @eq.{1} β (f b) (@has_zero.zero.{0} β (@add_monoid.to_has_zero.{0} β (@add_comm_monoid.to_add_monoid.{0} β _inst_1)))) → (not (@has_mem.mem.{u_2 u_2} α (finset.{u_2} α) (@finset.has_mem.{u_2} α) a s) → @eq.{1} β (f a) (@has_zero.zero.{0} β (@add_monoid.to_has_zero.{0} β (@add_comm_monoid.to_add_monoid.{0} β _inst_1)))) → @eq.{1} β (@finset.sum.{u_2 0} α β _inst_1 s f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@finset.sum.{u_2 0} σ nat nat.add_comm_monoid (@finset.univ.{u_2} σ _inst_3)
       (λ (x : σ),
          @has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
            (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
            (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
               (@multiset.cons.{u_2} σ x (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))))))
    ?m_1

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat ?m_1
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ ∀ (b : σ),
    @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) b (@finset.univ.{u_2} σ _inst_3) →
    @ne.{u_2+1} σ b n →
    @eq.{1} nat
      (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
         (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
         (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
            (@multiset.cons.{u_2} σ b (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
      (@has_zero.zero.{0} nat
         (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ not (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) n (@finset.univ.{u_2} σ _inst_3)) →
  @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    { assume b hb ne, rw [multiset.count_cons_of_ne ne.symm, multiset.count_zero, mul_zero] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='multiset.count_cons_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.count_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1858, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1853, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : decidable_eq.{u_2+1} α] {a b : α}, @ne.{u_2+1} α a b → ∀ (s : multiset.{u_2} α), @eq.{1} nat (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a (@multiset.cons.{u_2} α b s)) (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{u_2+1} σ b n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : decidable_eq.{u_2+1} α] (a : α), @eq.{1} nat (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a (@has_zero.zero.{u_2} (multiset.{u_2} α) (@multiset.has_zero.{u_2} α))) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : mul_zero_class.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α _inst_1) a (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α _inst_1))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ ∀ (b : σ),
    @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) b (@finset.univ.{u_2} σ _inst_3) →
    @ne.{u_2+1} σ b n →
    @eq.{1} nat
      (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
         (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
         (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
            (@multiset.cons.{u_2} σ b (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
      (@has_zero.zero.{0} nat
         (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ not (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) n (@finset.univ.{u_2} σ _inst_3)) →
  @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ ∀ (b : σ),
    @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) b (@finset.univ.{u_2} σ _inst_3) →
    @ne.{u_2+1} σ b n →
    @eq.{1} nat
      (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
         (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
         (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
            (@multiset.cons.{u_2} σ b (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
      (@has_zero.zero.{0} nat
         (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n b : σ,
hb : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) b (@finset.univ.{u_2} σ _inst_3),
ne : @_root_.ne.{u_2+1} σ b n
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ b (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n b : σ,
hb : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) b (@finset.univ.{u_2} σ _inst_3),
ne : @_root_.ne.{u_2+1} σ b n
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) a b) n
          (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n b : σ,
hb : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) b (@finset.univ.{u_2} σ _inst_3),
ne : @_root_.ne.{u_2+1} σ b n
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@has_zero.zero.{0} nat nat.has_zero))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n b : σ,
hb : @has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) b (@finset.univ.{u_2} σ _inst_3),
ne : @_root_.ne.{u_2+1} σ b n
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ b (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ not (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) n (@finset.univ.{u_2} σ _inst_3)) →
  @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163    { assume h, exact (h $ finset.mem_univ _).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) n (@finset.univ.{u_2} σ _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : fintype.{u_2} α] (x : α), @has_mem.mem.{u_2 u_2} α (finset.{u_2} α) (@finset.has_mem.{u_2} α) x (@finset.univ.{u_2} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ not (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) n (@finset.univ.{u_2} σ _inst_3)) →
  @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ not (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) n (@finset.univ.{u_2} σ _inst_3)) →
  @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ,
h : not (@has_mem.mem.{u_2 u_2} σ (finset.{u_2} σ) (@finset.has_mem.{u_2} σ) n (@finset.univ.{u_2} σ _inst_3))
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_zero.zero.{0} nat
       (@add_monoid.to_has_zero.{0} nat (@add_comm_monoid.to_add_monoid.{0} nat nat.add_comm_monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164    { rw [multiset.count_cons_self, multiset.count_zero, mul_one] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='multiset.count_cons_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='multiset.count_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1855, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/multiset.lean&#x27;, &#x27;line&#x27;: 1853, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : decidable_eq.{u_2+1} α] (a : α) (s : multiset.{u_2} α), @eq.{1} nat (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a (@multiset.cons.{u_2} α a s)) (nat.succ (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : decidable_eq.{u_2+1} α] (a : α), @eq.{1} nat (@multiset.count.{u_2} α (λ (a b : α), _inst_1 a b) a (@has_zero.zero.{u_2} (multiset.{u_2} α) (@multiset.has_zero.{u_2} α))) (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) a (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (nat.succ
          (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
             (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (nat.succ (@has_zero.zero.{0} nat nat.has_zero)))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
c : σ → α,
n : σ
⊢ @eq.{1} nat
    (@has_mul.mul.{0} nat (@mul_zero_class.to_has_mul.{0} nat (@semiring.to_mul_zero_class.{0} nat nat.semiring))
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       (@multiset.count.{u_2} σ (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) n
          (@multiset.cons.{u_2} σ n (@has_zero.zero.{u_2} (multiset.{u_2} σ) (@multiset.has_zero.{u_2} σ)))))
    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  variables (α σ)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  def evalₗ : mv_polynomial σ α →ₗ[α] (σ → α) → α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) (β γ : Type (max u_2 u_1)) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{(max u_2 u_1)} β] [_inst_3 : add_comm_group.{(max u_2 u_1)} γ] [_inst_4 : @module.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2] [_inst_5 : @module.{u_1 (max u_2 u_1)} α γ _inst_1 _inst_3], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) (β γ : Type (max u_2 u_1)) [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{(max u_2 u_1)} β] [_inst_3 : add_comm_group.{(max u_2 u_1)} γ] [_inst_4 : @module.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2] [_inst_5 : @module.{u_1 (max u_2 u_1)} α γ _inst_1 _inst_3], Type (max u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  ⟨ λp e, p.eval e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    assume p q, funext $ assume e, eval_add,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 471, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {σ : Type u_1} [_inst_1 : comm_semiring.{u} α] {p q : @mv_polynomial.{u_1 u} σ α _inst_1} {f : σ → α}, @eq.{u+1} α (@mv_polynomial.eval.{u u_1} α σ _inst_1 f (@has_add.add.{(max u_1 u)} (@mv_polynomial.{u_1 u} σ α _inst_1) (@mv_polynomial.has_add.{u u_1} α σ _inst_1) p q)) (@has_add.add.{u} α (@distrib.to_has_add.{u} α (@semiring.to_distrib.{u} α (@comm_semiring.to_semiring.{u} α _inst_1))) (@mv_polynomial.eval.{u u_1} α σ _inst_1 f p) (@mv_polynomial.eval.{u u_1} α σ _inst_1 f q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    assume a p, funext $ assume e, by rw [smul_eq_C_mul, eval_mul, eval_C]; refl ⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mv_polynomial.smul_eq_C_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.eval_C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 826, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 480, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 476, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v} (β x) (f₁ x) (f₂ x)) → @eq.{(imax u v)} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_ring.{u_1} α] (p : @mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (a : α), @eq.{(max u_2 u_1)+1} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@has_scalar.smul.{u_1 (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@mv_polynomial.has_scalar.{u_1 u_2} α σ _inst_1) a p) (@has_mul.mul.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@mv_polynomial.has_mul.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1)) (@mv_polynomial.C.{u_1 u_2} α σ (@comm_ring.to_comm_semiring.{u_1} α _inst_1) a) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α] {p q : @mv_polynomial.{u_2 u_1} σ α _inst_1} {f : σ → α}, @eq.{u_1+1} α (@mv_polynomial.eval.{u_1 u_2} α σ _inst_1 f (@has_mul.mul.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α _inst_1) (@mv_polynomial.has_mul.{u_1 u_2} α σ _inst_1) p q)) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@comm_semiring.to_semiring.{u_1} α _inst_1))) (@mv_polynomial.eval.{u_1 u_2} α σ _inst_1 f p) (@mv_polynomial.eval.{u_1 u_2} α σ _inst_1 f q))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α] {f : σ → α} (a : α), @eq.{u_1+1} α (@mv_polynomial.eval.{u_1 u_2} α σ _inst_1 f (@mv_polynomial.C.{u_1 u_2} α σ _inst_1 a)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : α,
p :
  @mv_polynomial.{u_2 u_1} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
          (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))),
e : σ → α
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       e
       (@has_scalar.smul.{u_1 (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (@add_group.to_add_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1))))))
                   (@module.to_semimodule.{u_1 (max u_2 u_1)} α
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)))))
          a
          p))
    (@has_scalar.smul.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@ring.to_monoid.{u_1} α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (@add_group.to_add_monoid.{(max u_2 u_1)} ((σ → α) → α)
                (@add_comm_group.to_add_group.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))))
             (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                (@ring.to_semiring.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                (@module.to_semimodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                   (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))))
       a
       (λ (e : σ → α),
          @mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            e
            p)
       e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : α,
p :
  @mv_polynomial.{u_2 u_1} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
          (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))),
e : σ → α
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       e
       (@has_mul.mul.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@comm_ring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.has_mul.{u_1 u_2} α σ
             (@comm_ring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.C.{u_1 u_2} α σ
             (@comm_ring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             a)
          p))
    (@has_scalar.smul.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@ring.to_monoid.{u_1} α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (@add_group.to_add_monoid.{(max u_2 u_1)} ((σ → α) → α)
                (@add_comm_group.to_add_group.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))))
             (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                (@ring.to_semiring.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                (@module.to_semimodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                   (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))))
       a
       (λ (e : σ → α),
          @mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            e
            p)
       e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : α,
p :
  @mv_polynomial.{u_2 u_1} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
          (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))),
e : σ → α
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          e
          (@mv_polynomial.C.{u_1 u_2} α σ
             (@comm_ring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
             a))
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          e
          p))
    (@has_scalar.smul.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@ring.to_monoid.{u_1} α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (@add_group.to_add_monoid.{(max u_2 u_1)} ((σ → α) → α)
                (@add_comm_group.to_add_group.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))))
             (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                (@ring.to_semiring.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                (@module.to_semimodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                   (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))))
       a
       (λ (e : σ → α),
          @mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            e
            p)
       e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : α,
p :
  @mv_polynomial.{u_2 u_1} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
          (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))),
e : σ → α
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))))
       a
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          e
          p))
    (@has_scalar.smul.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@ring.to_monoid.{u_1} α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (@add_group.to_add_monoid.{(max u_2 u_1)} ((σ → α) → α)
                (@add_comm_group.to_add_group.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))))
             (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                (@ring.to_semiring.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                (@module.to_semimodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                   (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))))
       a
       (λ (e : σ → α),
          @mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            e
            p)
       e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
a : α,
p :
  @mv_polynomial.{u_2 u_1} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
          (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))),
e : σ → α
⊢ @eq.{u_1+1} α
    (@mv_polynomial.eval.{u_1 u_2} α σ
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
       e
       (@has_scalar.smul.{u_1 (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@ring.to_monoid.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (@add_group.to_add_monoid.{(max u_2 u_1)}
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_group.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))))
                (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α
                   (@mv_polynomial.{u_2 u_1} σ α
                      (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                         (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                            (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                   (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)}
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1))))))
                   (@module.to_semimodule.{u_1 (max u_2 u_1)} α
                      (@mv_polynomial.{u_2 u_1} σ α
                         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                      (@ring.to_add_comm_group.{(max u_2 u_1)}
                         (@mv_polynomial.{u_2 u_1} σ α
                            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                                  (@local_ring.to_nonzero_comm_ring.{u_1} α
                                     (@discrete_field.local_ring.{u_1} α _inst_1)))))
                         (@mv_polynomial.ring.{u_1 u_2} α σ
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@local_ring.to_nonzero_comm_ring.{u_1} α
                                  (@discrete_field.local_ring.{u_1} α _inst_1)))))
                      (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)))))
          a
          p))
    (@has_scalar.smul.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@ring.to_monoid.{u_1} α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@ring.to_monoid.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (@add_group.to_add_monoid.{(max u_2 u_1)} ((σ → α) → α)
                (@add_comm_group.to_add_group.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))))
             (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                (@ring.to_semiring.{u_1} α
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)} ((σ → α) → α)
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
                (@module.to_semimodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
                   (@domain.to_ring.{u_1} α
                      (@division_ring.to_domain.{u_1} α
                         (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                   (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                   (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                      (λ (i : σ → α),
                         @ring.to_add_comm_group.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))))
       a
       (λ (e : σ → α),
          @mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            e
            p)
       e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  lemma evalₗ_apply (p : mv_polynomial σ α) (e : σ → α) : evalₗ α σ p e = p.eval e :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mv_polynomial.evalₗ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 169, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1) (σ : Type u_2) [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) ((σ → α) → α) (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.ring.{u_1 u_2} α σ (@nonzero_comm_ring.to_comm_ring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))) (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1) (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : comm_semiring.{u_1} α], (σ → α) → @mv_polynomial.{u_2 u_1} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  lemma map_restrict_dom_evalₗ : (restrict_degree σ α (fintype.card α - 1)).map (evalₗ α σ) = ⊤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='submodule.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mv_polynomial.evalₗ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 454, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 169, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (σ : Type u) (α : Type v), nat → Π [_inst_1 : discrete_field.{v} α], @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {R : Type u_1} {M M₂ : Type (max u_2 u_1)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{(max u_2 u_1)} M] [_inst_3 : add_comm_group.{(max u_2 u_1)} M₂] [_inst_5 : @module.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2] [_inst_6 : @module.{u_1 (max u_2 u_1)} R M₂ _inst_1 _inst_3], @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5 → @submodule.{u_1 (max u_2 u_1)} R M₂ _inst_1 _inst_3 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (σ : Type u_2) [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) ((σ → α) → α) (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.ring.{u_1 u_2} α σ (@nonzero_comm_ring.to_comm_ring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))) (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1) (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_2 u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max u_2 u_1)) [c : lattice.has_top.{(max u_2 u_1)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The pushforward of a submodule `p ⊆ M` by `f : M → M₂`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ
⊢ @eq.{(max u_2 u_1)+1}
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
          _inst_1))
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@submodule.lattice.has_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183    refine top_unique (submodule.le_def&#x27;.2 $ assume e _, mem_map.2 _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='lattice.top_unique'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='submodule.le_def&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='submodule.mem_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 465, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} [_inst_1 : lattice.order_top.{(max u_2 u_1)} α] {a : α}, @has_le.le.{(max u_2 u_1)} α (@preorder.to_has_le.{(max u_2 u_1)} α (@partial_order.to_preorder.{(max u_2 u_1)} α (@lattice.order_top.to_partial_order.{(max u_2 u_1)} α _inst_1))) (@lattice.has_top.top.{(max u_2 u_1)} α (@lattice.order_top.to_has_top.{(max u_2 u_1)} α _inst_1)) a → @eq.{(max u_2 u_1)+1} α a (@lattice.has_top.top.{(max u_2 u_1)} α (@lattice.order_top.to_has_top.{(max u_2 u_1)} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {R : Type u_1} {M : Type (max u_2 u_1)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{(max u_2 u_1)} M] [_inst_5 : @module.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2] {p p&#x27; : @submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5}, iff (@has_le.le.{(max u_2 u_1)} (@submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) (@preorder.to_has_le.{(max u_2 u_1)} (@submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) (@partial_order.to_preorder.{(max u_2 u_1)} (@submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) (@submodule.partial_order.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5))) p p&#x27;) (∀ (x : M), @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} M (@submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) x p → @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} M (@submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) x p&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type u_1} {M M₂ : Type (max u_2 u_1)} [_inst_1 : ring.{u_1} R] [_inst_2 : add_comm_group.{(max u_2 u_1)} M] [_inst_3 : add_comm_group.{(max u_2 u_1)} M₂] [_inst_5 : @module.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2] [_inst_6 : @module.{u_1 (max u_2 u_1)} R M₂ _inst_1 _inst_3] {f : @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6} {p : @submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5} {x : M₂}, iff (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} M₂ (@submodule.{u_1 (max u_2 u_1)} R M₂ _inst_1 _inst_3 _inst_6) (@submodule.has_mem.{u_1 (max u_2 u_1)} R M₂ _inst_1 _inst_3 _inst_6) x (@submodule.map.{u_1 (max u_2 u_1) (max u_2 u_1)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f p)) (@Exists.{(max u_2 u_1)+1} M (λ (y : M), and (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} M (@submodule.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u_1 (max u_2 u_1)} R M _inst_1 _inst_2 _inst_5) y p) (@eq.{(max u_2 u_1)+1} M₂ (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1} (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f y) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ
⊢ @eq.{(max u_2 u_1)+1}
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
          _inst_1))
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@submodule.lattice.has_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @Exists.{(max u_2 u_1)+1}
    (@mv_polynomial.{u_2 u_1} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
    (λ
     (y :
       @mv_polynomial.{u_2 u_1} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))),
       and
         (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)}
            (@mv_polynomial.{u_2 u_1} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
            (@submodule.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
               (@ring.to_add_comm_group.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.ring.{u_1 u_2} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
            (@submodule.has_mem.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
               (@ring.to_add_comm_group.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.ring.{u_1 u_2} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
            y
            (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
               _inst_1))
         (@eq.{(max u_2 u_1)+1} ((σ → α) → α)
            (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
               (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
               y)
            e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    refine ⟨finset.univ.sum (λn:σ → α, e n • indicator n), _, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 110, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_2 u_1)} [_inst_1 : fintype.{(max u_2 u_1)} α], finset.{(max u_2 u_1)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(σ → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {γ : Type (max u_2 u_1)} [c : has_scalar.{u_1 (max u_2 u_1)} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], (σ → α) → @mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @Exists.{(max u_2 u_1)+1}
    (@mv_polynomial.{u_2 u_1} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
    (λ
     (y :
       @mv_polynomial.{u_2 u_1} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))),
       and
         (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)}
            (@mv_polynomial.{u_2 u_1} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
            (@submodule.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
               (@ring.to_add_comm_group.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.ring.{u_1 u_2} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
            (@submodule.has_mem.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
               (@ring.to_add_comm_group.{(max u_2 u_1)}
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@mv_polynomial.ring.{u_1 u_2} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
            y
            (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
               _inst_1))
         (@eq.{(max u_2 u_1)+1} ((σ → α) → α)
            (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
               (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
               y)
            e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)}
    (@mv_polynomial.{u_2 u_1} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
    (@submodule.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@ring.to_semiring.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (n : σ → α),
          @has_scalar.smul.{u_1 (max u_2 u_1)} α
            (@mv_polynomial.{u_2 u_1} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
            (@mv_polynomial.has_scalar.{u_1 u_2} α σ
               (@nonzero_comm_ring.to_comm_ring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            (e n)
            (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       _inst_1)

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @eq.{(max u_2 u_1)+1} ((σ → α) → α)
    (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
       (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_semiring.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{(max u_2 u_1)} (σ → α)
             (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
                (λ (a : σ), _inst_2)))
          (λ (n : σ → α),
             @has_scalar.smul.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.has_scalar.{u_1 u_2} α σ
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               (e n)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n))))
    e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    { exact sum_mem _ (assume c _, smul_mem _ _ (indicator_mem_restrict_degree _)) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='submodule.sum_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='submodule.smul_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.indicator_mem_restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 296, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type (max u_2 u_1)} [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{(max u_2 u_1)} β] [_inst_4 : @module.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2] (p : @submodule.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) {ι : Type (max u_2 u_1)} [_inst_6 : decidable_eq.{(max u_2 u_1)+1} ι] {t : finset.{(max u_2 u_1)} ι} {f : ι → β}, (∀ (c : ι), @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ι (finset.{(max u_2 u_1)} ι) (@finset.has_mem.{(max u_2 u_1)} ι) c t → @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} β (@submodule.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) (@submodule.has_mem.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) (f c) p) → @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} β (@submodule.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) (@submodule.has_mem.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} ι β (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)} β _inst_2) t f) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type (max u_2 u_1)} [_inst_1 : ring.{u_1} α] [_inst_2 : add_comm_group.{(max u_2 u_1)} β] [_inst_4 : @module.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2] (p : @submodule.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) {x : β} (r : α), @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} β (@submodule.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) (@submodule.has_mem.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) x p → @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} β (@submodule.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) (@submodule.has_mem.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4) (@has_scalar.smul.{u_1 (max u_2 u_1)} α β (@mul_action.to_has_scalar.{u_1 (max u_2 u_1)} α β (@ring.to_monoid.{u_1} α _inst_1) (@distrib_mul_action.to_mul_action.{u_1 (max u_2 u_1)} α β (@ring.to_monoid.{u_1} α _inst_1) (@add_group.to_add_monoid.{(max u_2 u_1)} β (@add_comm_group.to_add_group.{(max u_2 u_1)} β _inst_2)) (@semimodule.to_distrib_mul_action.{u_1 (max u_2 u_1)} α β (@ring.to_semiring.{u_1} α _inst_1) (@add_comm_group.to_add_comm_monoid.{(max u_2 u_1)} β _inst_2) (@module.to_semimodule.{u_1 (max u_2 u_1)} α β _inst_1 _inst_2 _inst_4)))) r x) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ] (c : σ → α), @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@submodule.{u_1 (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.ring.{u_1 u_2} α σ (@nonzero_comm_ring.to_comm_ring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)) (@submodule.has_mem.{u_1 (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.ring.{u_1 u_2} α σ (@nonzero_comm_ring.to_comm_ring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)) (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c) (@mv_polynomial.restrict_degree.{u_2 u_1} σ α (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one)) _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)}
    (@mv_polynomial.{u_2 u_1} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
    (@submodule.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@ring.to_semiring.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (n : σ → α),
          @has_scalar.smul.{u_1 (max u_2 u_1)} α
            (@mv_polynomial.{u_2 u_1} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
            (@mv_polynomial.has_scalar.{u_1 u_2} α σ
               (@nonzero_comm_ring.to_comm_ring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            (e n)
            (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       _inst_1)

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @eq.{(max u_2 u_1)+1} ((σ → α) → α)
    (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
       (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_semiring.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{(max u_2 u_1)} (σ → α)
             (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
                (λ (a : σ), _inst_2)))
          (λ (n : σ → α),
             @has_scalar.smul.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.has_scalar.{u_1 u_2} α σ
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               (e n)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n))))
    e'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)}
    (@mv_polynomial.{u_2 u_1} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
    (@submodule.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@ring.to_add_comm_group.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@mv_polynomial.ring.{u_1 u_2} α σ
             (@nonzero_comm_ring.to_comm_ring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1))
    (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
       (@mv_polynomial.{u_2 u_1} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
       (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@ring.to_semiring.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (n : σ → α),
          @has_scalar.smul.{u_1 (max u_2 u_1)} α
            (@mv_polynomial.{u_2 u_1} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
            (@mv_polynomial.has_scalar.{u_1 u_2} α σ
               (@nonzero_comm_ring.to_comm_ring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            (e n)
            (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@mv_polynomial.restrict_degree.{u_2 u_1} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u_1} α _inst_2) (@has_one.one.{0} nat nat.has_one))
       _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @eq.{(max u_2 u_1)+1} ((σ → α) → α)
    (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
       (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_semiring.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{(max u_2 u_1)} (σ → α)
             (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
                (λ (a : σ), _inst_2)))
          (λ (n : σ → α),
             @has_scalar.smul.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.has_scalar.{u_1 u_2} α σ
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               (e n)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n))))
    e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186    { ext n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))))
⊢ @eq.{(max u_2 u_1)+1} ((σ → α) → α)
    (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
       (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_semiring.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{(max u_2 u_1)} (σ → α)
             (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
                (λ (a : σ), _inst_2)))
          (λ (n : σ → α),
             @has_scalar.smul.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.has_scalar.{u_1 u_2} α σ
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               (e n)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n))))
    e'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
       (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_semiring.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{(max u_2 u_1)} (σ → α)
             (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
                (λ (a : σ), _inst_2)))
          (λ (n : σ → α),
             @has_scalar.smul.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.has_scalar.{u_1 u_2} α σ
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               (e n)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
       n)
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187      simp only [linear_map.map_sum, @pi.finset_sum_apply (σ → α) (λ_, α) _ _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='linear_map.map_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pi.finset_sum_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pi_instances.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} {rα : ring.{?l_1} α} {gβ : add_comm_group.{?l_2} β} {gγ : add_comm_group.{?l_3} γ} {mβ : @module.{?l_1 ?l_2} α β rα gβ} {mγ : @module.{?l_1 ?l_3} α γ rα gγ} (f : @linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) {ι : Type ?l_4} {t : finset.{?l_4} ι} {g : ι → β}, @eq.{?l_3+1} γ (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f (@finset.sum.{?l_4 ?l_2} ι β (@add_comm_group.to_add_comm_monoid.{?l_2} β gβ) t g)) (@finset.sum.{?l_4 ?l_3} ι γ (@add_comm_group.to_add_comm_monoid.{?l_3} γ gγ) t (λ (i : ι), @coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f (g i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} {β : α → Type u_1} {γ : Type ?l_1} [_inst_1 : Π (a : α), add_comm_monoid.{u_1} (β a)] (a : α) (s : finset.{?l_1} γ) (g : γ → Π (a : α), β a), @eq.{u_1+1} (β a) (@finset.sum.{?l_1 (max u_2 u_1)} γ (Π (a : α), β a) (@pi.add_comm_monoid.{(max u_2 u_1) u_1} α (λ (a : α), β a) (λ (i : α), _inst_1 i)) s g a) (@finset.sum.{?l_1 u_1} γ (β a) (_inst_1 a) s (λ (c : γ), g c a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
       (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_semiring.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{(max u_2 u_1)} (σ → α)
             (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
                (λ (a : σ), _inst_2)))
          (λ (n : σ → α),
             @has_scalar.smul.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.has_scalar.{u_1 u_2} α σ
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               (e n)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
       n)
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188        pi.smul_apply, linear_map.map_smul],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='pi.smul_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.map_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pi_instances.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 179, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {I : Type ?l_1} {f : I → Type ?l_2} (x : Π (i : I), f i) (i : I) {α : Type ?l_3} [_inst_1 : Π (i : I), has_scalar.{?l_3 ?l_2} α (f i)] (s : α), @eq.{?l_2+1} (f i) (@has_scalar.smul.{?l_3 (max ?l_1 ?l_2)} α (Π (i : I), f i) (@pi.has_scalar.{?l_1 ?l_2 ?l_3} I (λ (i : I), f i) α (λ (i : I), _inst_1 i)) s x i) (@has_scalar.smul.{?l_3 ?l_2} α (f i) (_inst_1 i) s (x i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} {rα : ring.{?l_1} α} {gβ : add_comm_group.{?l_2} β} {gγ : add_comm_group.{?l_3} γ} {mβ : @module.{?l_1 ?l_2} α β rα gβ} {mγ : @module.{?l_1 ?l_3} α γ rα gγ} (f : @linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (c : α) (x : β), @eq.{?l_3+1} γ (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α rα) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α rα) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β gβ)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α rα) (@add_comm_group.to_add_comm_monoid.{?l_2} β gβ) (@module.to_semimodule.{?l_1 ?l_2} α β rα gβ mβ)))) c x)) (@has_scalar.smul.{?l_1 ?l_3} α γ (@mul_action.to_has_scalar.{?l_1 ?l_3} α γ (@ring.to_monoid.{?l_1} α rα) (@distrib_mul_action.to_mul_action.{?l_1 ?l_3} α γ (@ring.to_monoid.{?l_1} α rα) (@add_group.to_add_monoid.{?l_3} γ (@add_comm_group.to_add_group.{?l_3} γ gγ)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_3} α γ (@ring.to_semiring.{?l_1} α rα) (@add_comm_group.to_add_comm_monoid.{?l_3} γ gγ) (@module.to_semimodule.{?l_1 ?l_3} α γ rα gγ mγ)))) c (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (@linear_map.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) (@linear_map.has_coe_to_fun.{?l_1 ?l_2 ?l_3} α β γ rα gβ gγ mβ mγ) f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
       (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@ring.to_add_comm_group.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@mv_polynomial.ring.{u_1 u_2} α σ
                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
       (@finset.sum.{(max u_2 u_1) (max u_2 u_1)} (σ → α)
          (@mv_polynomial.{u_2 u_1} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                   (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
          (@semiring.to_add_comm_monoid.{(max u_2 u_1)}
             (@mv_polynomial.{u_2 u_1} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
             (@ring.to_semiring.{(max u_2 u_1)}
                (@mv_polynomial.{u_2 u_1} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                (@mv_polynomial.ring.{u_1 u_2} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))))
          (@finset.univ.{(max u_2 u_1)} (σ → α)
             (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
                (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
                (λ (a : σ), _inst_2)))
          (λ (n : σ → α),
             @has_scalar.smul.{u_1 (max u_2 u_1)} α
               (@mv_polynomial.{u_2 u_1} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                        (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
               (@mv_polynomial.has_scalar.{u_1 u_2} α σ
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               (e n)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
       n)
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@finset.sum.{(max u_2 u_1) u_1} (σ → α) ((λ (_x : σ → α), α) n)
       ((λ (a : σ → α),
           @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
             (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                   (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                      (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
          n)
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (c : σ → α),
          @has_scalar.smul.{u_1 u_1} α α
            (@mul_action.to_has_scalar.{u_1 u_1} α
               ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
               (@semiring.to_monoid.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
               ((λ (i : σ → α),
                   @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                     (@semiring.to_monoid.{u_1} α
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                     ((λ (i : σ → α),
                         @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i))
                        i)
                     ((λ (i : σ → α),
                         @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                           (@ring.to_semiring.{u_1} α
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i)
                           ((λ (i : σ → α),
                               @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                                 (@domain.to_ring.{u_1} α
                                    (@division_ring.to_domain.{u_1} α
                                       (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i)
                                 ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                              i))
                        i))
                  n))
            (e c)
            (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
               (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c)
               n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189      simp only [evalₗ_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='mv_polynomial.evalₗ_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 177, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {σ : Type ?l_2} [_inst_1 : discrete_field.{?l_1} α] [_inst_2 : fintype.{?l_1} α] [_inst_3 : fintype.{?l_2} σ] (p : @mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))) (e : σ → α), @eq.{?l_1+1} α (@coe_fn.{(max ?l_2 ?l_1)+1 (max ?l_2 ?l_1)+1} (@linear_map.{?l_1 (max ?l_2 ?l_1) (max ?l_2 ?l_1)} α (@mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))) ((σ → α) → α) (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1)))) (@ring.to_add_comm_group.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))) (@mv_polynomial.ring.{?l_1 ?l_2} α σ (@nonzero_comm_ring.to_comm_ring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))) (@pi.add_comm_group.{(max ?l_2 ?l_1) ?l_1} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{?l_1} α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1)))))) (@mv_polynomial.vector_space.{?l_2 ?l_1} σ α _inst_1) (@pi.module.{(max ?l_2 ?l_1) ?l_1 ?l_1} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{?l_1} α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{?l_1} α _inst_1))) (@linear_map.has_coe_to_fun.{?l_1 (max ?l_2 ?l_1) (max ?l_2 ?l_1)} α (@mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))) ((σ → α) → α) (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1)))) (@ring.to_add_comm_group.{(max ?l_2 ?l_1)} (@mv_polynomial.{?l_2 ?l_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))) (@mv_polynomial.ring.{?l_1 ?l_2} α σ (@nonzero_comm_ring.to_comm_ring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1))))) (@pi.add_comm_group.{(max ?l_2 ?l_1) ?l_1} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{?l_1} α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1)))))) (@mv_polynomial.vector_space.{?l_2 ?l_1} σ α _inst_1) (@pi.module.{(max ?l_2 ?l_1) ?l_1 ?l_1} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{?l_1} α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{?l_1} α _inst_1))) (@mv_polynomial.evalₗ.{?l_1 ?l_2} α σ _inst_1 _inst_2 _inst_3) p e) (@mv_polynomial.eval.{?l_1 ?l_2} α σ (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@local_ring.to_nonzero_comm_ring.{?l_1} α (@discrete_field.local_ring.{?l_1} α _inst_1)))) e p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@finset.sum.{(max u_2 u_1) u_1} (σ → α) ((λ (_x : σ → α), α) n)
       ((λ (a : σ → α),
           @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
             (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                   (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                      (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
          n)
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (c : σ → α),
          @has_scalar.smul.{u_1 u_1} α α
            (@mul_action.to_has_scalar.{u_1 u_1} α
               ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
               (@semiring.to_monoid.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
               ((λ (i : σ → α),
                   @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                     (@semiring.to_monoid.{u_1} α
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                     ((λ (i : σ → α),
                         @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i))
                        i)
                     ((λ (i : σ → α),
                         @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                           (@ring.to_semiring.{u_1} α
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i)
                           ((λ (i : σ → α),
                               @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                                 (@domain.to_ring.{u_1} α
                                    (@division_ring.to_domain.{u_1} α
                                       (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i)
                                 ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                              i))
                        i))
                  n))
            (e c)
            (@coe_fn.{(max u_2 u_1)+1 (max u_2 u_1)+1}
               (@linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@linear_map.has_coe_to_fun.{u_1 (max u_2 u_1) (max u_2 u_1)} α
                  (@mv_polynomial.{u_2 u_1} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  ((σ → α) → α)
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                  (@ring.to_add_comm_group.{(max u_2 u_1)}
                     (@mv_polynomial.{u_2 u_1} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                              (@local_ring.to_nonzero_comm_ring.{u_1} α
                                 (@discrete_field.local_ring.{u_1} α _inst_1)))))
                     (@mv_polynomial.ring.{u_1 u_2} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))))
                  (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1)
                  (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                     (λ (i : σ → α),
                        @ring.to_add_comm_group.{u_1} α
                          (@domain.to_ring.{u_1} α
                             (@division_ring.to_domain.{u_1} α
                                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                     (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
               (@mv_polynomial.evalₗ.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3)
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c)
               n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@finset.sum.{(max u_2 u_1) u_1} (σ → α) ((λ (_x : σ → α), α) n)
       ((λ (a : σ → α),
           @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
             (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                   (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                      (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
          n)
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (c : σ → α),
          @has_scalar.smul.{u_1 u_1} α α
            (@mul_action.to_has_scalar.{u_1 u_1} α
               ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
               (@semiring.to_monoid.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
               ((λ (i : σ → α),
                   @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                     (@semiring.to_monoid.{u_1} α
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                     ((λ (i : σ → α),
                         @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i))
                        i)
                     ((λ (i : σ → α),
                         @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                           (@ring.to_semiring.{u_1} α
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i)
                           ((λ (i : σ → α),
                               @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                                 (@domain.to_ring.{u_1} α
                                    (@division_ring.to_domain.{u_1} α
                                       (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i)
                                 ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                              i))
                        i))
                  n))
            (e c)
            (@mv_polynomial.eval.{u_1 u_2} α σ
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               n
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c))))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190      transitivity,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1277, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.

`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='transitivity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@finset.sum.{(max u_2 u_1) u_1} (σ → α) ((λ (_x : σ → α), α) n)
       ((λ (a : σ → α),
           @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
             (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                   (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                      (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
          n)
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (c : σ → α),
          @has_scalar.smul.{u_1 u_1} α α
            (@mul_action.to_has_scalar.{u_1 u_1} α
               ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
               (@semiring.to_monoid.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
               ((λ (i : σ → α),
                   @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                     (@semiring.to_monoid.{u_1} α
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                     ((λ (i : σ → α),
                         @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i))
                        i)
                     ((λ (i : σ → α),
                         @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                           (@ring.to_semiring.{u_1} α
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i)
                           ((λ (i : σ → α),
                               @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                                 (@domain.to_ring.{u_1} α
                                    (@division_ring.to_domain.{u_1} α
                                       (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i)
                                 ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                              i))
                        i))
                  n))
            (e c)
            (@mv_polynomial.eval.{u_1 u_2} α σ
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               n
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c))))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@finset.sum.{(max u_2 u_1) u_1} (σ → α) ((λ (_x : σ → α), α) n)
       ((λ (a : σ → α),
           @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
             (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                   (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                      (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
          n)
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (c : σ → α),
          @has_scalar.smul.{u_1 u_1} α α
            (@mul_action.to_has_scalar.{u_1 u_1} α
               ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
               (@semiring.to_monoid.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
               ((λ (i : σ → α),
                   @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                     (@semiring.to_monoid.{u_1} α
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                     ((λ (i : σ → α),
                         @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i))
                        i)
                     ((λ (i : σ → α),
                         @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                           (@ring.to_semiring.{u_1} α
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i)
                           ((λ (i : σ → α),
                               @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                                 (@domain.to_ring.{u_1} α
                                    (@division_ring.to_domain.{u_1} α
                                       (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i)
                                 ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                              i))
                        i))
                  n))
            (e c)
            (@mv_polynomial.eval.{u_1 u_2} α σ
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               n
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c))))
    ?m_1

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α ?m_1 (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191      refine finset.sum_eq_single n _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='finset.sum_eq_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} {β : Type u_1} [_inst_1 : add_comm_monoid.{u_1} β] {s : finset.{(max u_2 u_1)} α} {f : α → β} (a : α), (∀ (b : α), @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} α (finset.{(max u_2 u_1)} α) (@finset.has_mem.{(max u_2 u_1)} α) b s → @ne.{(max u_2 u_1)+1} α b a → @eq.{u_1+1} β (f b) (@has_zero.zero.{u_1} β (@add_monoid.to_has_zero.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1)))) → (not (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} α (finset.{(max u_2 u_1)} α) (@finset.has_mem.{(max u_2 u_1)} α) a s) → @eq.{u_1+1} β (f a) (@has_zero.zero.{u_1} β (@add_monoid.to_has_zero.{u_1} β (@add_comm_monoid.to_add_monoid.{u_1} β _inst_1)))) → @eq.{u_1+1} β (@finset.sum.{(max u_2 u_1) u_1} α β _inst_1 s f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@finset.sum.{(max u_2 u_1) u_1} (σ → α) ((λ (_x : σ → α), α) n)
       ((λ (a : σ → α),
           @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
             (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                   (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                      (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
          n)
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))
       (λ (c : σ → α),
          @has_scalar.smul.{u_1 u_1} α α
            (@mul_action.to_has_scalar.{u_1 u_1} α
               ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
               (@semiring.to_monoid.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
               ((λ (i : σ → α),
                   @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                     (@semiring.to_monoid.{u_1} α
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                     ((λ (i : σ → α),
                         @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i))
                        i)
                     ((λ (i : σ → α),
                         @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                           (@ring.to_semiring.{u_1} α
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                           ((λ (i : σ → α),
                               @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i))
                              i)
                           ((λ (i : σ → α),
                               @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                                 (@domain.to_ring.{u_1} α
                                    (@division_ring.to_domain.{u_1} α
                                       (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                                 ((λ (i : σ → α),
                                     @ring.to_add_comm_group.{u_1} α
                                       (@domain.to_ring.{u_1} α
                                          (@division_ring.to_domain.{u_1} α
                                             (@field.to_division_ring.{u_1} α
                                                (@discrete_field.to_field.{u_1} α _inst_1)))))
                                    i)
                                 ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                              i))
                        i))
                  n))
            (e c)
            (@mv_polynomial.eval.{u_1 u_2} α σ
               (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                     (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
               n
               (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 c))))
    ?m_1

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α ?m_1 (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ ∀ (b : σ → α),
    @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
      (@finset.has_mem.{(max u_2 u_1)} (σ → α))
      b
      (@finset.univ.{(max u_2 u_1)} (σ → α)
         (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
            (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
            (λ (a : σ), _inst_2))) →
    @ne.{(max u_2 u_1)+1} (σ → α) b n →
    @eq.{u_1+1} α
      (@has_scalar.smul.{u_1 u_1} α α
         (@mul_action.to_has_scalar.{u_1 u_1} α
            ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
            (@semiring.to_monoid.{u_1} α
               (@ring.to_semiring.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
            ((λ (i : σ → α),
                @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                  (@semiring.to_monoid.{u_1} α
                     (@ring.to_semiring.{u_1} α
                        (@domain.to_ring.{u_1} α
                           (@division_ring.to_domain.{u_1} α
                              (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  ((λ (i : σ → α),
                      @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                        ((λ (i : σ → α),
                            @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i))
                           i))
                     i)
                  ((λ (i : σ → α),
                      @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                        ((λ (i : σ → α),
                            @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i))
                           i)
                        ((λ (i : σ → α),
                            @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i)
                              ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                           i))
                     i))
               n))
         (e b)
         (@mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            n
            (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b)))
      (@has_zero.zero.{u_1} α
         (@add_monoid.to_has_zero.{u_1} α
            (@add_comm_monoid.to_add_monoid.{u_1} α
               ((λ (a : σ → α),
                   @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                     (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                        (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                           (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                              (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                                 (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                  n))))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ not
    (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
       (@finset.has_mem.{(max u_2 u_1)} (σ → α))
       n
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))) →
  @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192      { assume b _ h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ ∀ (b : σ → α),
    @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
      (@finset.has_mem.{(max u_2 u_1)} (σ → α))
      b
      (@finset.univ.{(max u_2 u_1)} (σ → α)
         (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
            (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
            (λ (a : σ), _inst_2))) →
    @ne.{(max u_2 u_1)+1} (σ → α) b n →
    @eq.{u_1+1} α
      (@has_scalar.smul.{u_1 u_1} α α
         (@mul_action.to_has_scalar.{u_1 u_1} α
            ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
            (@semiring.to_monoid.{u_1} α
               (@ring.to_semiring.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
            ((λ (i : σ → α),
                @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                  (@semiring.to_monoid.{u_1} α
                     (@ring.to_semiring.{u_1} α
                        (@domain.to_ring.{u_1} α
                           (@division_ring.to_domain.{u_1} α
                              (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  ((λ (i : σ → α),
                      @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                        ((λ (i : σ → α),
                            @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i))
                           i))
                     i)
                  ((λ (i : σ → α),
                      @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                        ((λ (i : σ → α),
                            @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i))
                           i)
                        ((λ (i : σ → α),
                            @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i)
                              ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                           i))
                     i))
               n))
         (e b)
         (@mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            n
            (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b)))
      (@has_zero.zero.{u_1} α
         (@add_monoid.to_has_zero.{u_1} α
            (@add_comm_monoid.to_add_monoid.{u_1} α
               ((λ (a : σ → α),
                   @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                     (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                        (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                           (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                              (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                                 (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                  n))))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ not
    (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
       (@finset.has_mem.{(max u_2 u_1)} (σ → α))
       n
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))) →
  @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ ∀ (b : σ → α),
    @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
      (@finset.has_mem.{(max u_2 u_1)} (σ → α))
      b
      (@finset.univ.{(max u_2 u_1)} (σ → α)
         (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
            (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
            (λ (a : σ), _inst_2))) →
    @ne.{(max u_2 u_1)+1} (σ → α) b n →
    @eq.{u_1+1} α
      (@has_scalar.smul.{u_1 u_1} α α
         (@mul_action.to_has_scalar.{u_1 u_1} α
            ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
            (@semiring.to_monoid.{u_1} α
               (@ring.to_semiring.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
            ((λ (i : σ → α),
                @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                  (@semiring.to_monoid.{u_1} α
                     (@ring.to_semiring.{u_1} α
                        (@domain.to_ring.{u_1} α
                           (@division_ring.to_domain.{u_1} α
                              (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                  ((λ (i : σ → α),
                      @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                        ((λ (i : σ → α),
                            @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i))
                           i))
                     i)
                  ((λ (i : σ → α),
                      @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                        (@ring.to_semiring.{u_1} α
                           (@domain.to_ring.{u_1} α
                              (@division_ring.to_domain.{u_1} α
                                 (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                        ((λ (i : σ → α),
                            @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i))
                           i)
                        ((λ (i : σ → α),
                            @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                              (@domain.to_ring.{u_1} α
                                 (@division_ring.to_domain.{u_1} α
                                    (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                              ((λ (i : σ → α),
                                  @ring.to_add_comm_group.{u_1} α
                                    (@domain.to_ring.{u_1} α
                                       (@division_ring.to_domain.{u_1} α
                                          (@field.to_division_ring.{u_1} α
                                             (@discrete_field.to_field.{u_1} α _inst_1)))))
                                 i)
                              ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                           i))
                     i))
               n))
         (e b)
         (@mv_polynomial.eval.{u_1 u_2} α σ
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
            n
            (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b)))
      (@has_zero.zero.{u_1} α
         (@add_monoid.to_has_zero.{u_1} α
            (@add_comm_monoid.to_add_monoid.{u_1} α
               ((λ (a : σ → α),
                   @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                     (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                        (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                           (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                              (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                                 (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                  n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n b : σ → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
    (@finset.has_mem.{(max u_2 u_1)} (σ → α))
    b
    (@finset.univ.{(max u_2 u_1)} (σ → α)
       (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
          (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
          (λ (a : σ), _inst_2))),
h : @ne.{(max u_2 u_1)+1} (σ → α) b n
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e b)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193        rw [eval_indicator_apply_eq_zero _ _ h.symm, smul_zero] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mv_polynomial.eval_indicator_apply_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 199, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ] (a b : σ → α), @ne.{(max (u_2+1) (u_1+1))} (σ → α) a b → @eq.{u_1+1} α (@mv_polynomial.eval.{u_1 u_2} α σ (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))) a (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b)) (@has_zero.zero.{u_1} α (@no_zero_divisors.to_has_zero.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{(max u_2 u_1)+1} (σ → α) b n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : monoid.{u_1} α] [_inst_2 : add_monoid.{u_1} β] [_inst_3 : @distrib_mul_action.{u_1 u_1} α β _inst_1 _inst_2] (a : α), @eq.{u_1+1} β (@has_scalar.smul.{u_1 u_1} α β (@mul_action.to_has_scalar.{u_1 u_1} α β _inst_1 (@distrib_mul_action.to_mul_action.{u_1 u_1} α β _inst_1 _inst_2 _inst_3)) a (@has_zero.zero.{u_1} β (@add_monoid.to_has_zero.{u_1} β _inst_2))) (@has_zero.zero.{u_1} β (@add_monoid.to_has_zero.{u_1} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n b : σ → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
    (@finset.has_mem.{(max u_2 u_1)} (σ → α))
    b
    (@finset.univ.{(max u_2 u_1)} (σ → α)
       (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
          (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
          (λ (a : σ), _inst_2))),
h : @ne.{(max u_2 u_1)+1} (σ → α) b n
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e b)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n b : σ → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
    (@finset.has_mem.{(max u_2 u_1)} (σ → α))
    b
    (@finset.univ.{(max u_2 u_1)} (σ → α)
       (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
          (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
          (λ (a : σ), _inst_2))),
h : @ne.{(max u_2 u_1)+1} (σ → α) b n
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e b)
       (@has_zero.zero.{u_1} α
          (@no_zero_divisors.to_has_zero.{u_1} α
             (@domain.to_no_zero_divisors.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n b : σ → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
    (@finset.has_mem.{(max u_2 u_1)} (σ → α))
    b
    (@finset.univ.{(max u_2 u_1)} (σ → α)
       (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
          (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
          (λ (a : σ), _inst_2))),
h : @ne.{(max u_2 u_1)+1} (σ → α) b n
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e b)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 b)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ not
    (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
       (@finset.has_mem.{(max u_2 u_1)} (σ → α))
       n
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))) →
  @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194      { assume h, exact (h $ finset.mem_univ n).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α)) (@finset.has_mem.{(max u_2 u_1)} (σ → α)) n (@finset.univ.{(max u_2 u_1)} (σ → α) (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3 (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b)) (λ (a : σ), _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} [_inst_1 : fintype.{(max u_2 u_1)} α] (x : α), @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} α (finset.{(max u_2 u_1)} α) (@finset.has_mem.{(max u_2 u_1)} α) x (@finset.univ.{(max u_2 u_1)} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ not
    (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
       (@finset.has_mem.{(max u_2 u_1)} (σ → α))
       n
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))) →
  @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))

α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ not
    (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
       (@finset.has_mem.{(max u_2 u_1)} (σ → α))
       n
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2)))) →
  @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α,
h :
  not
    (@has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} (σ → α) (finset.{(max u_2 u_1)} (σ → α))
       (@finset.has_mem.{(max u_2 u_1)} (σ → α))
       n
       (@finset.univ.{(max u_2 u_1)} (σ → α)
          (@pi.fintype.{u_2 u_1} σ (λ (a : σ), α) _inst_3
             (λ (a b : σ), classical.prop_decidable (@eq.{u_2+1} σ a b))
             (λ (a : σ), _inst_2))))
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (@has_zero.zero.{u_1} α
       (@add_monoid.to_has_zero.{u_1} α
          (@add_comm_monoid.to_add_monoid.{u_1} α
             ((λ (a : σ → α),
                 @semiring.to_add_comm_monoid.{u_1} ((λ (_x : σ → α), α) a)
                   (@ring.to_semiring.{u_1} ((λ (_x : σ → α), α) a)
                      (@domain.to_ring.{u_1} ((λ (_x : σ → α), α) a)
                         (@division_ring.to_domain.{u_1} ((λ (_x : σ → α), α) a)
                            (@field.to_division_ring.{u_1} ((λ (_x : σ → α), α) a)
                               (@discrete_field.to_field.{u_1} ((λ (_x : σ → α), α) a) _inst_1))))))
                n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195      { rw [eval_indicator_apply_eq_one, smul_eq_mul, mul_one] } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mv_polynomial.eval_indicator_apply_eq_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_eq_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {σ : Type u_2} [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ] (a : σ → α), @eq.{u_1+1} α (@mv_polynomial.eval.{u_1 u_2} α σ (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1)))) a (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 a)) (@has_one.one.{u_1} α (@zero_ne_one_class.to_has_one.{u_1} α (@domain.to_zero_ne_one_class.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : semiring.{u_1} α] {a a&#x27; : α}, @eq.{u_1+1} α (@has_scalar.smul.{u_1 u_1} α α (@mul_action.to_has_scalar.{u_1 u_1} α α (@semiring.to_monoid.{u_1} α _inst_1) (@distrib_mul_action.to_mul_action.{u_1 u_1} α α (@semiring.to_monoid.{u_1} α _inst_1) (@add_comm_monoid.to_add_monoid.{u_1} α (@semiring.to_add_comm_monoid.{u_1} α _inst_1)) (@semimodule.to_distrib_mul_action.{u_1 u_1} α α _inst_1 (@semiring.to_add_comm_monoid.{u_1} α _inst_1) (@semiring.to_semimodule.{u_1} α _inst_1)))) a a&#x27;) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α _inst_1)) a a&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] (a : α), @eq.{u_1+1} α (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) a (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@has_one.one.{u_1} α
          (@zero_ne_one_class.to_has_one.{u_1} α
             (@domain.to_zero_ne_one_class.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
       (e n)
       (@has_one.one.{u_1} α
          (@zero_ne_one_class.to_has_one.{u_1} α
             (@domain.to_zero_ne_one_class.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
σ : Type u_2,
_inst_1 : discrete_field.{u_1} α,
_inst_2 : fintype.{u_1} α,
_inst_3 : fintype.{u_2} σ,
e : (σ → α) → α,
_x :
  @has_mem.mem.{(max u_2 u_1) (max u_2 u_1)} ((σ → α) → α)
    (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    (@submodule.has_mem.{u_1 (max u_2 u_1)} α ((σ → α) → α)
       (@domain.to_ring.{u_1} α
          (@division_ring.to_domain.{u_1} α
             (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
       (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
       (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u_1} α
               (@domain.to_ring.{u_1} α
                  (@division_ring.to_domain.{u_1} α
                     (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
    e
    (@lattice.has_top.top.{(max u_2 u_1)}
       (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
          (@domain.to_ring.{u_1} α
             (@division_ring.to_domain.{u_1} α
                (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
          (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u_1} α
                  (@domain.to_ring.{u_1} α
                     (@division_ring.to_domain.{u_1} α
                        (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
       (@lattice.order_top.to_has_top.{(max u_2 u_1)}
          (@submodule.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1)))
          (@submodule.lattice.order_top.{u_1 (max u_2 u_1)} α ((σ → α) → α)
             (@domain.to_ring.{u_1} α
                (@division_ring.to_domain.{u_1} α
                   (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
             (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α)
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
             (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                (λ (i : σ → α),
                   @ring.to_add_comm_group.{u_1} α
                     (@domain.to_ring.{u_1} α
                        (@division_ring.to_domain.{u_1} α
                           (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))))),
n : σ → α
⊢ @eq.{u_1+1} α
    (@has_scalar.smul.{u_1 u_1} α α
       (@mul_action.to_has_scalar.{u_1 u_1} α
          ((λ (i : σ → α), (λ (i : σ → α), (λ (a : σ → α), α) i) i) n)
          (@semiring.to_monoid.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@domain.to_ring.{u_1} α
                   (@division_ring.to_domain.{u_1} α
                      (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
          ((λ (i : σ → α),
              @distrib_mul_action.to_mul_action.{u_1 u_1} α ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                (@semiring.to_monoid.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@domain.to_ring.{u_1} α
                         (@division_ring.to_domain.{u_1} α
                            (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))))
                ((λ (i : σ → α),
                    @add_comm_monoid.to_add_monoid.{u_1} ((λ (i : σ → α), (λ (a : σ → α), α) i) i)
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i))
                   i)
                ((λ (i : σ → α),
                    @semimodule.to_distrib_mul_action.{u_1 u_1} α ((λ (a : σ → α), α) i)
                      (@ring.to_semiring.{u_1} α
                         (@domain.to_ring.{u_1} α
                            (@division_ring.to_domain.{u_1} α
                               (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))
                      ((λ (i : σ → α),
                          @add_comm_group.to_add_comm_monoid.{u_1} ((λ (a : σ → α), α) i)
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i))
                         i)
                      ((λ (i : σ → α),
                          @module.to_semimodule.{u_1 u_1} α ((λ (a : σ → α), α) i)
                            (@domain.to_ring.{u_1} α
                               (@division_ring.to_domain.{u_1} α
                                  (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))
                            ((λ (i : σ → α),
                                @ring.to_add_comm_group.{u_1} α
                                  (@domain.to_ring.{u_1} α
                                     (@division_ring.to_domain.{u_1} α
                                        (@field.to_division_ring.{u_1} α
                                           (@discrete_field.to_field.{u_1} α _inst_1)))))
                               i)
                            ((λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1) i))
                         i))
                   i))
             n))
       (e n)
       (@mv_polynomial.eval.{u_1 u_2} α σ
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))
          n
          (@mv_polynomial.indicator.{u_1 u_2} α σ _inst_1 _inst_2 _inst_3 n)))
    (e n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  end mv_polynomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  namespace mv_polynomial</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  variables (σ : Type u) (α : Type u) [fintype σ] [discrete_field α] [fintype α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='fintype.{u} σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='discrete_field.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='fintype.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  @[derive [add_comm_group, vector_space α, inhabited]]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : discrete_field.{u} α] [_inst_2 : add_comm_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='automatically derive typeclass instances'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  def R : Type u := restrict_degree σ α (fintype.card α - 1)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π (σ : Type u) (α : Type v), nat → Π [_inst_1 : discrete_field.{v} α], @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  noncomputable instance decidable_restrict_degree (m : ℕ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207    decidable_pred (λn, n ∈ {n : σ →₀ ℕ | ∀i, n i ≤ m }) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, (α → Prop) → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Π (β : Type) [_inst_1 : has_zero.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  by simp only [set.mem_set_of_eq]; apply_instance</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='σ : Type u,
_inst_1 : fintype.{u} σ,
m : nat
⊢ @decidable_pred.{u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (λ (n : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@set.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         n
         (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
            (λ (n : @finsupp.{u 0} σ nat nat.has_zero),
               ∀ (i : σ),
                 @has_le.le.{0} nat nat.has_le
                   (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                      (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                      n
                      i)
                   m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ : Type u,
_inst_1 : fintype.{u} σ,
m : nat
⊢ @decidable_pred.{u+1} (@finsupp.{u 0} σ nat nat.has_zero)
    (λ (n : @finsupp.{u 0} σ nat nat.has_zero),
       @has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         (@set.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
         n
         (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
            (λ (n : @finsupp.{u 0} σ nat nat.has_zero),
               ∀ (i : σ),
                 @has_le.le.{0} nat nat.has_le
                   (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                      (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                      n
                      i)
                   m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  set_option class.instance_max_depth 60</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  lemma dim_R : vector_space.dim α (R σ α) = fintype.card (σ → α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π (K : Type u) (V : Type v) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{v} V] [_inst_3 : @vector_space.{u v} K V _inst_1 _inst_2], cardinal.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (u+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  calc vector_space.dim α (R σ α) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (K V : Type u) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{u} V] [_inst_3 : @vector_space.{u u} K V _inst_1 _inst_2], cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213    vector_space.dim α (↥{s : σ →₀ ℕ | ∀ (n : σ), s n ≤ fintype.card α - 1} →₀ α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector_space.dim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe_sort'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (K V : Type u) [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{u} V] [_inst_3 : @vector_space.{u u} K V _inst_1 _inst_2], cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Type u} [_inst_1 : has_coe_to_sort.{(max (u+1) 1) (max 1 (u+1))+1} a], a → @has_coe_to_sort.S.{(max (u+1) 1) (max 1 (u+1))+1} a _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Π (β : Type) [_inst_1 : has_zero.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Π (β : Type u) [_inst_1 : has_zero.{u} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214      linear_equiv.dim_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='linear_equiv.dim_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {K V V₂ : Type u} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{u} V] [_inst_3 : @vector_space.{u u} K V _inst_1 _inst_2] [_inst_4 : add_comm_group.{u} V₂] [_inst_5 : @vector_space.{u u} K V₂ _inst_1 _inst_4], @linear_equiv.{u u u} K V V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_2 _inst_4 _inst_3 _inst_5 → @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} K V _inst_1 _inst_2 _inst_3) (@vector_space.dim.{u u} K V₂ _inst_1 _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215        (finsupp.supported_equiv_finsupp {s : σ →₀ ℕ | ∀n:σ, s n ≤ fintype.card α - 1 })</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finsupp.supported_equiv_finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α M R : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : @module.{u u} R M _inst_1 _inst_2] (s : set.{u} α), @linear_equiv.{u u u} R (@coe_sort.{u+1 (max 1 (u+1))+1} (@submodule.{u u} R (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u u} α M _inst_2) (@finsupp.module.{u u u} α M R _inst_1 _inst_2 _inst_3)) (@coe_sort_trans.{u+1 (max (u+1) 1) (max 1 (u+1))+1} (@submodule.{u u} R (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u u} α M _inst_2) (@finsupp.module.{u u u} α M R _inst_1 _inst_2 _inst_3)) (set.{u} (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2))))) (@coe_base_aux.{u+1 (max (u+1) 1)} (@submodule.{u u} R (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u u} α M _inst_2) (@finsupp.module.{u u u} α M R _inst_1 _inst_2 _inst_3)) (set.{u} (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2))))) (@submodule.has_coe.{u u} R (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u u} α M _inst_2) (@finsupp.module.{u u u} α M R _inst_1 _inst_2 _inst_3))) (@set.has_coe_to_sort.{u} (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))))) (@finsupp.supported.{u u u} α M R _inst_1 _inst_2 _inst_3 s)) (@finsupp.{u u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s) M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@submodule.add_comm_group.{u u} R (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u u} α M _inst_2) (@finsupp.module.{u u u} α M R _inst_1 _inst_2 _inst_3) (@finsupp.supported.{u u u} α M R _inst_1 _inst_2 _inst_3 s)) (@finsupp.add_comm_group.{u u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s) M _inst_2) (@submodule.module.{u u} R (@finsupp.{u u} α M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u u} α M _inst_2) (@finsupp.module.{u u u} α M R _inst_1 _inst_2 _inst_3) (@finsupp.supported.{u u u} α M R _inst_1 _inst_2 _inst_3 s)) (@finsupp.module.{u u u} (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} α) (@set.has_coe_to_sort.{u} α) s) M R _inst_1 _inst_2 _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Π (β : Type) [_inst_1 : has_zero.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    ... = cardinal.mk {s : σ →₀ ℕ | ∀ (n : σ), s n ≤ fintype.card α - 1} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Π (β : Type) [_inst_1 : has_zero.{0} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@finsupp.{u 0} σ nat nat.has_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`finsupp α β`, denoted `α →₀ β`, is the type of functions `f : α → β` such that
 `f x = 0` for all but finitely many `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217      by rw [finsupp.dim_eq, dim_of_field, mul_one]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='finsupp.dim_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dim_of_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp_vector_space.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K V ι : Type u} [_inst_1 : discrete_field.{u} K] [_inst_2 : add_comm_group.{u} V] [_inst_3 : @vector_space.{u u} K V _inst_1 _inst_2], @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} K (@finsupp.{u u} ι V (@add_monoid.to_has_zero.{u} V (@add_group.to_add_monoid.{u} V (@add_comm_group.to_add_group.{u} V _inst_2)))) _inst_1 (@finsupp.add_comm_group.{u u} ι V _inst_2) (@finsupp.vector_space.{u u u} ι V K _inst_1 _inst_2 _inst_3)) (@has_mul.mul.{u+1} cardinal.{u} cardinal.has_mul.{u} (cardinal.mk.{u} ι) (@vector_space.dim.{u u} K V _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (K : Type u) [_inst_6 : discrete_field.{u} K], @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} K K _inst_6 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_6))))) (@discrete_field.to_vector_space.{u} K _inst_6)) (@has_one.one.{u+1} cardinal.{u} cardinal.has_one.{u})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u+1)} [_inst_1 : monoid.{u+1} α] (a : α), @eq.{u+2} α (@has_mul.mul.{u+1} α (@semigroup.to_has_mul.{u+1} α (@monoid.to_semigroup.{u+1} α _inst_1)) a (@has_one.one.{u+1} α (@monoid.to_has_one.{u+1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α
       (@finsupp.{u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          (@no_zero_divisors.to_has_zero.{u} α
             (@domain.to_no_zero_divisors.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       _inst_2
       (@finsupp.add_comm_group.{u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@finsupp.vector_space.{u u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          α
          _inst_2
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (@discrete_field.to_vector_space.{u} α _inst_2)))
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (n : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       s
                       n)
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                       (@has_one.one.{0} nat nat.has_one))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@has_mul.mul.{u+1} cardinal.{u} cardinal.has_mul.{u}
       (cardinal.mk.{u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one))))))
       (@vector_space.dim.{u u} α α _inst_2
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (@discrete_field.to_vector_space.{u} α _inst_2)))
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (n : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       s
                       n)
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                       (@has_one.one.{0} nat nat.has_one))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@has_mul.mul.{u+1} cardinal.{u} cardinal.has_mul.{u}
       (cardinal.mk.{u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one))))))
       (@has_one.one.{u+1} cardinal.{u} cardinal.has_one.{u}))
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (n : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       s
                       n)
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                       (@has_one.one.{0} nat nat.has_one))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α
       (@finsupp.{u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          (@no_zero_divisors.to_has_zero.{u} α
             (@domain.to_no_zero_divisors.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       _inst_2
       (@finsupp.add_comm_group.{u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@finsupp.vector_space.{u u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          α
          _inst_2
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (@discrete_field.to_vector_space.{u} α _inst_2)))
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (n : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       s
                       n)
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                       (@has_one.one.{0} nat nat.has_one))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218    ... = cardinal.mk {s : σ → ℕ | ∀ (n : σ), s n &lt; fintype.card α } :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u → cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α
       (@finsupp.{u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          (@no_zero_divisors.to_has_zero.{u} α
             (@domain.to_no_zero_divisors.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       _inst_2
       (@finsupp.add_comm_group.{u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@finsupp.vector_space.{u u u}
          (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
             (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
                (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                   ∀ (n : σ),
                     @has_le.le.{0} nat nat.has_le
                       (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                          (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                          s
                          n)
                       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                          (@has_one.one.{0} nat nat.has_one)))))
          α
          α
          _inst_2
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (@discrete_field.to_vector_space.{u} α _inst_2)))
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (n : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       s
                       n)
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                       (@has_one.one.{0} nat nat.has_one))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (n : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       s
                       n)
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                       (@has_one.one.{0} nat nat.has_one))))))
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (σ → nat)) (@set.has_coe_to_sort.{u} (σ → nat))
          (@set_of.{u} (σ → nat)
             (λ (s : σ → nat), ∀ (n : σ), @has_lt.lt.{0} nat nat.has_lt (s n) (@fintype.card.{u} α _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220      refine quotient.sound ⟨equiv.subtype_congr finsupp.equiv_fun_on_fintype $ assume f, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='quotient.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.subtype_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finsupp.equiv_fun_on_fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 562, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finsupp.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u+1)} [s : setoid.{u+2} α] {a b : α}, @has_equiv.equiv.{u+2} α (@setoid_has_equiv.{u+2} α s) a b → @eq.{u+2} (@quotient.{u+2} α s) (@quotient.mk.{u+2} α s a) (@quotient.mk.{u+2} α s b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} {p : α → Prop} {q : β → Prop} (e : equiv.{u+1 u+1} α β), (∀ (a : α), iff (p a) (q (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) e a))) → equiv.{(max 1 (u+1)) (max 1 (u+1))} (@subtype.{u+1} α (λ (a : α), p a)) (@subtype.{u+1} β (λ (b : β), q b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type} [_inst_1 : has_zero.{0} β] [_inst_2 : fintype.{u} α], equiv.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} α β _inst_1) (α → β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set.has_coe_to_sort.{u} (@finsupp.{u 0} σ nat nat.has_zero))
          (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
             (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
                ∀ (n : σ),
                  @has_le.le.{0} nat nat.has_le
                    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                       (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                       s
                       n)
                    (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3)
                       (@has_one.one.{0} nat nat.has_one))))))
    (cardinal.mk.{u}
       (@coe_sort.{(max (u+1) 1) (max 1 (u+1))+1} (set.{u} (σ → nat)) (@set.has_coe_to_sort.{u} (σ → nat))
          (@set_of.{u} (σ → nat)
             (λ (s : σ → nat), ∀ (n : σ), @has_lt.lt.{0} nat nat.has_lt (s n) (@fintype.card.{u} α _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
f : @finsupp.{u 0} σ nat nat.has_zero
⊢ iff
    (@has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       (@set.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       f
       (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
          (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
             ∀ (n : σ),
               @has_le.le.{0} nat nat.has_le
                 (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                    (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                    s
                    n)
                 (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one)))))
    (@has_mem.mem.{u u} (σ → nat) (set.{u} (σ → nat)) (@set.has_mem.{u} (σ → nat))
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero) (σ → nat))
          (@equiv.has_coe_to_fun.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero) (σ → nat))
          (@finsupp.equiv_fun_on_fintype.{u 0} σ nat nat.has_zero _inst_1)
          f)
       (@set_of.{u} (σ → nat)
          (λ (s : σ → nat), ∀ (n : σ), @has_lt.lt.{0} nat nat.has_lt (s n) (@fintype.card.{u} α _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221      refine forall_congr (assume n, nat.le_sub_right_iff_add_le _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='forall_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nat.le_sub_right_iff_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 571, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 273, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p q : α → Prop}, (∀ (a : α), iff (p a) (q a)) → iff (∀ (a : α), p a) (∀ (a : α), q a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n k : nat}, @has_le.le.{0} nat nat.has_le n k → iff (@has_le.le.{0} nat nat.has_le m (@has_sub.sub.{0} nat nat.has_sub k n)) (@has_le.le.{0} nat nat.has_le (@has_add.add.{0} nat nat.has_add m n) k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
f : @finsupp.{u 0} σ nat nat.has_zero
⊢ iff
    (@has_mem.mem.{u u} (@finsupp.{u 0} σ nat nat.has_zero) (set.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       (@set.has_mem.{u} (@finsupp.{u 0} σ nat nat.has_zero))
       f
       (@set_of.{u} (@finsupp.{u 0} σ nat nat.has_zero)
          (λ (s : @finsupp.{u 0} σ nat nat.has_zero),
             ∀ (n : σ),
               @has_le.le.{0} nat nat.has_le
                 (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@finsupp.{u 0} σ nat nat.has_zero)
                    (@finsupp.has_coe_to_fun.{u 0} σ nat nat.has_zero)
                    s
                    n)
                 (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one)))))
    (@has_mem.mem.{u u} (σ → nat) (set.{u} (σ → nat)) (@set.has_mem.{u} (σ → nat))
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero) (σ → nat))
          (@equiv.has_coe_to_fun.{u+1 u+1} (@finsupp.{u 0} σ nat nat.has_zero) (σ → nat))
          (@finsupp.equiv_fun_on_fintype.{u 0} σ nat nat.has_zero _inst_1)
          f)
       (@set_of.{u} (σ → nat)
          (λ (s : σ → nat), ∀ (n : σ), @has_lt.lt.{0} nat nat.has_lt (s n) (@fintype.card.{u} α _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
f : @finsupp.{u 0} σ nat nat.has_zero,
n : σ
⊢ @has_le.le.{0} nat nat.has_le (@has_one.one.{0} nat nat.has_one) (@fintype.card.{u} α _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222      exact fintype.card_pos_iff.2 ⟨0⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='fintype.card_pos_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α], iff (@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) (@fintype.card.{u} α _inst_1)) (nonempty.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
f : @finsupp.{u 0} σ nat nat.has_zero,
n : σ
⊢ @has_le.le.{0} nat nat.has_le (@has_one.one.{0} nat nat.has_one) (@fintype.card.{u} α _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
f : @finsupp.{u 0} σ nat nat.has_zero,
n : σ
⊢ @has_le.le.{0} nat nat.has_le (@has_one.one.{0} nat nat.has_one) (@fintype.card.{u} α _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224    ... = cardinal.mk (σ → {n // n &lt; fintype.card α}) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225      quotient.sound ⟨@equiv.subtype_pi_equiv_pi σ (λ_, ℕ) (λs n, n &lt; fintype.card α)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='quotient.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='equiv.subtype_pi_equiv_pi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 655, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (u+1)} [s : setoid.{u+2} α] {a b : α}, @has_equiv.equiv.{u+2} α (@setoid_has_equiv.{u+2} α s) a b → @eq.{u+2} (@quotient.{u+2} α s) (@quotient.mk.{u+2} α s a) (@quotient.mk.{u+2} α s b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : α → Type} {p : Π (a : α), β a → Prop}, equiv.{(max (u+1) 1) (max (u+1) 1)} (@subtype.{(max (u+1) 1)} (Π (a : α), β a) (λ (f : Π (a : α), β a), ∀ (a : α), p a (f a))) (Π (a : α), @subtype.{1} (β a) (λ (b : β a), p a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (_x : σ), nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='(λ (_x : σ), nat) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    ... = cardinal.mk (σ → fin (fintype.card α)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227      quotient.sound ⟨equiv.arrow_congr (equiv.refl σ) (equiv.fin_equiv_subtype _).symm⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='quotient.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.arrow_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='equiv.fin_equiv_subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 541, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (u+1)} [s : setoid.{u+2} α] {a b : α}, @has_equiv.equiv.{u+2} α (@setoid_has_equiv.{u+2} α s) a b → @eq.{u+2} (@quotient.{u+2} α s) (@quotient.mk.{u+2} α s a) (@quotient.mk.{u+2} α s b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α₁ : Type u} {β₁ : Type} {α₂ : Type u} {β₂ : Type}, equiv.{u+1 u+1} α₁ α₂ → equiv.{1 1} β₁ β₂ → equiv.{(max (u+1) 1) (max (u+1) 1)} (α₁ → β₁) (α₂ → β₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u), equiv.{u+1 u+1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (n : nat), equiv.{1 1} (fin n) (@subtype.{1} nat (λ (m : nat), @has_lt.lt.{0} nat nat.has_lt m n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type}, equiv.{1 1} α β → equiv.{1 1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    ... = cardinal.mk (σ → α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cardinal.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → cardinal.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The cardinal number of a type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u} (cardinal.mk.{u} (σ → fin (@fintype.card.{u} α _inst_3))) (cardinal.mk.{u} (σ → α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230      refine (trunc.induction_on (fintype.equiv_fin α) $ assume (e : α ≃ fin (fintype.card α)), _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='trunc.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.equiv_fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/quot.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : trunc.{(max 1 (max (u+1) 1) 1 (u+1))} α → Prop} (q : trunc.{(max 1 (max (u+1) 1) 1 (u+1))} α), (∀ (a : α), β (@trunc.mk.{(max 1 (max (u+1) 1) 1 (u+1))} α a)) → β q'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α] [_inst_2 : decidable_eq.{u+1} α], trunc.{(max 1 (max (u+1) 1) 1 (u+1))} (equiv.{u+1 1} α (fin (@fintype.card.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='There is (computably) a bijection between `α` and `fin n` where
 `n = card α`. Since it is not unique, and depends on which permutation
 of the universe list is used, the bijection is wrapped in `trunc` to
 preserve computability.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u} (cardinal.mk.{u} (σ → fin (@fintype.card.{u} α _inst_3))) (cardinal.mk.{u} (σ → α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
e : equiv.{u+1 1} α (fin (@fintype.card.{u} α _inst_3))
⊢ @eq.{u+2} cardinal.{u} (cardinal.mk.{u} (σ → fin (@fintype.card.{u} α _inst_3))) (cardinal.mk.{u} (σ → α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231      refine quotient.sound ⟨equiv.arrow_congr (equiv.refl σ) e.symm⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='quotient.sound'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.arrow_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/quot.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u+1)} [s : setoid.{u+2} α] {a b : α}, @has_equiv.equiv.{u+2} α (@setoid_has_equiv.{u+2} α s) a b → @eq.{u+2} (@quotient.{u+2} α s) (@quotient.mk.{u+2} α s a) (@quotient.mk.{u+2} α s b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α₁ : Type u} {β₁ : Type} {α₂ β₂ : Type u}, equiv.{u+1 u+1} α₁ α₂ → equiv.{1 u+1} β₁ β₂ → equiv.{(max (u+1) 1) u+1} (α₁ → β₁) (α₂ → β₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u), equiv.{u+1 u+1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.{u+1 1} α (fin (@fintype.card.{u} α _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
e : equiv.{u+1 1} α (fin (@fintype.card.{u} α _inst_3))
⊢ @eq.{u+2} cardinal.{u} (cardinal.mk.{u} (σ → fin (@fintype.card.{u} α _inst_3))) (cardinal.mk.{u} (σ → α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232    end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
e : equiv.{u+1 1} α (fin (@fintype.card.{u} α _inst_3))
⊢ @eq.{u+2} cardinal.{u} (cardinal.mk.{u} (σ → fin (@fintype.card.{u} α _inst_3))) (cardinal.mk.{u} (σ → α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233    ... = fintype.card (σ → α) : cardinal.fintype_card _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='cardinal.fintype_card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 597, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (α : Type u) [_inst_1 : fintype.{u} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (α : Type u) [_inst_1 : fintype.{u} α], @eq.{u+2} cardinal.{u} (cardinal.mk.{u} α) (@coe.{1 u+2} nat cardinal.{u} (@coe_to_lift.{1 u+2} nat cardinal.{u} (@coe_base.{1 u+2} nat cardinal.{u} (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u}))) (@fintype.card.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  def evalᵢ : R σ α →ₗ[α] (σ → α) → α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='mv_polynomial.R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α β γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{u} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u u} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α β γ : Type u) [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{u} β] [_inst_3 : add_comm_group.{u} γ] [_inst_4 : @module.{u u} α β _inst_1 _inst_2] [_inst_5 : @module.{u u} α γ _inst_1 _inst_3], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  ((evalₗ α σ).comp (restrict_degree σ α (fintype.card α - 1)).subtype)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.evalₗ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='submodule.subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 169, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 341, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) (σ : Type u_2) [_inst_1 : discrete_field.{u_1} α] [_inst_2 : fintype.{u_1} α] [_inst_3 : fintype.{u_2} σ], @linear_map.{u_1 (max u_2 u_1) (max u_2 u_1)} α (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) ((σ → α) → α) (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (@ring.to_add_comm_group.{(max u_2 u_1)} (@mv_polynomial.{u_2 u_1} σ α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@mv_polynomial.ring.{u_1 u_2} α σ (@nonzero_comm_ring.to_comm_ring.{u_1} α (@local_ring.to_nonzero_comm_ring.{u_1} α (@discrete_field.local_ring.{u_1} α _inst_1))))) (@pi.add_comm_group.{(max u_2 u_1) u_1} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))))) (@mv_polynomial.vector_space.{u_2 u_1} σ α _inst_1) (@pi.module.{(max u_2 u_1) u_1 u_1} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{u_1} α (@domain.to_ring.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β γ δ : Type u} {rα : ring.{u} α} {gβ : add_comm_group.{u} β} {gγ : add_comm_group.{u} γ} {gδ : add_comm_group.{u} δ} {mβ : @module.{u u} α β rα gβ} {mγ : @module.{u u} α γ rα gγ} {mδ : @module.{u u} α δ rα gδ}, @linear_map.{u u u} α γ δ rα gγ gδ mγ mδ → @linear_map.{u u u} α β γ rα gβ gγ mβ mγ → @linear_map.{u u u} α β δ rα gβ gδ mβ mδ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (σ : Type u) (α : Type v), nat → Π [_inst_1 : discrete_field.{v} α], @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α β : Type u} [_inst_1 : ring.{u} α] [_inst_2 : add_comm_group.{u} β] [_inst_4 : @module.{u u} α β _inst_1 _inst_2] (p : @submodule.{u u} α β _inst_1 _inst_2 _inst_4), @linear_map.{u u u} α (@coe_sort.{u+1 (max 1 (u+1))+1} (@submodule.{u u} α β _inst_1 _inst_2 _inst_4) (@coe_sort_trans.{u+1 (max (u+1) 1) (max 1 (u+1))+1} (@submodule.{u u} α β _inst_1 _inst_2 _inst_4) (set.{u} β) (@coe_base_aux.{u+1 (max (u+1) 1)} (@submodule.{u u} α β _inst_1 _inst_2 _inst_4) (set.{u} β) (@submodule.has_coe.{u u} α β _inst_1 _inst_2 _inst_4)) (@set.has_coe_to_sort.{u} β)) p) β _inst_1 (@submodule.add_comm_group.{u u} α β _inst_1 _inst_2 _inst_4 p) _inst_2 (@submodule.module.{u u} α β _inst_1 _inst_2 _inst_4 p) _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  lemma range_evalᵢ : (evalᵢ σ α).range = ⊤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='mv_polynomial.evalᵢ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 235, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 885, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], @linear_map.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R M M₂ : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_5 : @module.{u u} R M _inst_1 _inst_2] [_inst_6 : @module.{u u} R M₂ _inst_1 _inst_3], @linear_map.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u u} R M₂ _inst_1 _inst_3 _inst_6'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_top.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The range of a linear map `f : M → M₂` is a submodule of `M₂`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@linear_map.range.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))
    (@lattice.has_top.top.{u}
       (@submodule.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@submodule.lattice.has_top.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240    rw [evalᵢ, linear_map.range_comp, range_subtype],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.evalᵢ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='linear_map.range_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='submodule.range_subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 235, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 894, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 1109, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (σ α : Type ?l_1) [_inst_1 : fintype.{?l_1} σ] [_inst_2 : discrete_field.{?l_1} α] [_inst_3 : fintype.{?l_1} α], @linear_map.{?l_1 ?l_1 ?l_1} α (@mv_polynomial.R.{?l_1} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α) (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{?l_1} σ α _inst_1 _inst_2 _inst_3) (@pi.add_comm_group.{?l_1 ?l_1} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{?l_1} α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_2)))))) (@mv_polynomial.R.inst.{?l_1} σ α _inst_1 _inst_2 _inst_3) (@pi.module.{?l_1 ?l_1 ?l_1} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{?l_1} α (@domain.to_ring.{?l_1} α (@division_ring.to_domain.{?l_1} α (@field.to_division_ring.{?l_1} α (@discrete_field.to_field.{?l_1} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{?l_1} α _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R M M₂ M₃ : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_4 : add_comm_group.{u} M₃] [_inst_5 : @module.{u u} R M _inst_1 _inst_2] [_inst_6 : @module.{u u} R M₂ _inst_1 _inst_3] [_inst_7 : @module.{u u} R M₃ _inst_1 _inst_4] (f : @linear_map.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (g : @linear_map.{u u u} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_7), @eq.{u+1} (@submodule.{u u} R M₃ _inst_1 _inst_4 _inst_7) (@linear_map.range.{u u u} R M M₃ _inst_1 _inst_2 _inst_4 _inst_5 _inst_7 (@linear_map.comp.{u u u u} R M M₂ M₃ _inst_1 _inst_2 _inst_3 _inst_4 _inst_5 _inst_6 _inst_7 g f)) (@submodule.map.{u u u} R M₂ M₃ _inst_1 _inst_3 _inst_4 _inst_6 _inst_7 g (@linear_map.range.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R M : Type u} {T : ring.{u} R} [_inst_1 : add_comm_group.{u} M] [_inst_3 : @module.{u u} R M T _inst_1] (p : @submodule.{u u} R M T _inst_1 _inst_3), @eq.{u+1} (@submodule.{u u} R M T _inst_1 _inst_3) (@linear_map.range.{u u u} R (@coe_sort.{u+1 (max 1 (u+1))+1} (@submodule.{u u} R M T _inst_1 _inst_3) (@coe_sort_trans.{u+1 (max (u+1) 1) (max 1 (u+1))+1} (@submodule.{u u} R M T _inst_1 _inst_3) (set.{u} M) (@coe_base_aux.{u+1 (max (u+1) 1)} (@submodule.{u u} R M T _inst_1 _inst_3) (set.{u} M) (@submodule.has_coe.{u u} R M T _inst_1 _inst_3)) (@set.has_coe_to_sort.{u} M)) p) M T (@submodule.add_comm_group.{u u} R M T _inst_1 _inst_3 p) _inst_1 (@submodule.module.{u u} R M T _inst_1 _inst_3 p) _inst_3 (@submodule.subtype.{u u} R M T _inst_1 _inst_3 p)) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@linear_map.range.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))
    (@lattice.has_top.top.{u}
       (@submodule.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@submodule.lattice.has_top.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@linear_map.range.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@linear_map.comp.{u u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@ring.to_add_comm_group.{u}
             (@mv_polynomial.{u u} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                      (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
             (@mv_polynomial.ring.{u u} α σ
                (@nonzero_comm_ring.to_comm_ring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.vector_space.{u u} σ α _inst_2)
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
          (@mv_polynomial.evalₗ.{u u} α σ _inst_2 _inst_3 _inst_1)
          (@submodule.subtype.{u u} α
             (@mv_polynomial.{u u} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                      (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (@ring.to_add_comm_group.{u}
                (@mv_polynomial.{u u} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                         (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                (@mv_polynomial.ring.{u u} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u} α
                      (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
             (@mv_polynomial.vector_space.{u u} σ α _inst_2)
             (@mv_polynomial.restrict_degree.{u u} σ α
                (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                _inst_2))))
    (@lattice.has_top.top.{u}
       (@submodule.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@submodule.lattice.has_top.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@submodule.map.{u u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalₗ.{u u} α σ _inst_2 _inst_3 _inst_1)
       (@linear_map.range.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@ring.to_add_comm_group.{u}
             (@mv_polynomial.{u u} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                      (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
             (@mv_polynomial.ring.{u u} α σ
                (@nonzero_comm_ring.to_comm_ring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.vector_space.{u u} σ α _inst_2)
          (@submodule.subtype.{u u} α
             (@mv_polynomial.{u u} σ α
                (@nonzero_comm_semiring.to_comm_semiring.{u} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                      (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (@ring.to_add_comm_group.{u}
                (@mv_polynomial.{u u} σ α
                   (@nonzero_comm_semiring.to_comm_semiring.{u} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                         (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                (@mv_polynomial.ring.{u u} α σ
                   (@nonzero_comm_ring.to_comm_ring.{u} α
                      (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
             (@mv_polynomial.vector_space.{u u} σ α _inst_2)
             (@mv_polynomial.restrict_degree.{u u} σ α
                (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                _inst_2))))
    (@lattice.has_top.top.{u}
       (@submodule.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@submodule.lattice.has_top.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@submodule.map.{u u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalₗ.{u u} α σ _inst_2 _inst_3 _inst_1)
       (@mv_polynomial.restrict_degree.{u u} σ α
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
          _inst_2))
    (@lattice.has_top.top.{u}
       (@submodule.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@submodule.lattice.has_top.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241    exact map_restrict_dom_evalₗ</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mv_polynomial.map_restrict_dom_evalₗ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 181, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α σ : Type u} [_inst_1 : discrete_field.{u} α] [_inst_2 : fintype.{u} α] [_inst_3 : fintype.{u} σ], @eq.{u+1} (@submodule.{u u} α ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))))) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_1))) (@submodule.map.{u u u} α (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1))))) ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (@ring.to_add_comm_group.{u} (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1))))) (@mv_polynomial.ring.{u u} α σ (@nonzero_comm_ring.to_comm_ring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_1))))) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))))) (@mv_polynomial.vector_space.{u u} σ α _inst_1) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_1)) (@mv_polynomial.evalₗ.{u u} α σ _inst_1 _inst_2 _inst_3) (@mv_polynomial.restrict_degree.{u u} σ α (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_2) (@has_one.one.{0} nat nat.has_one)) _inst_1)) (@lattice.has_top.top.{u} (@submodule.{u u} α ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))))) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_1))) (@submodule.lattice.has_top.{u u} α ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))))) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_1))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@submodule.map.{u u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalₗ.{u u} α σ _inst_2 _inst_3 _inst_1)
       (@mv_polynomial.restrict_degree.{u u} σ α
          (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
          _inst_2))
    (@lattice.has_top.top.{u}
       (@submodule.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@submodule.lattice.has_top.{u u} α ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  lemma ker_evalₗ : (evalᵢ σ α).ker = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='mv_polynomial.evalᵢ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 235, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 924, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], @linear_map.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R M M₂ : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_5 : @module.{u u} R M _inst_1 _inst_2] [_inst_6 : @module.{u u} R M₂ _inst_1 _inst_3], @linear_map.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u u} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : lattice.has_bot.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title=' The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the
set of `x : M` such that `f x = 0`. The kernel is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))
    (@lattice.has_bot.bot.{u}
       (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_bot.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246    refine injective_of_surjective _ _ _ (range_evalᵢ _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='injective_of_surjective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mv_polynomial.range_evalᵢ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/finsupp_vector_space.lean&#x27;, &#x27;line&#x27;: 140, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K V₁ V₂ : Type u} [_inst_1 : discrete_field.{u} K] [_inst_4 : add_comm_group.{u} V₁] [_inst_5 : @vector_space.{u u} K V₁ _inst_1 _inst_4] [_inst_6 : add_comm_group.{u} V₂] [_inst_7 : @vector_space.{u u} K V₂ _inst_1 _inst_6] (f : @linear_map.{u u u} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7), @has_lt.lt.{u+1} cardinal.{u} (@preorder.to_has_lt.{u+1} cardinal.{u} (@partial_order.to_preorder.{u+1} cardinal.{u} (@ordered_comm_monoid.to_partial_order.{u+1} cardinal.{u} (@canonically_ordered_monoid.to_ordered_comm_monoid.{u+1} cardinal.{u} cardinal.canonically_ordered_monoid.{u})))) (@vector_space.dim.{u u} K V₁ _inst_1 _inst_4 _inst_5) cardinal.omega.{u} → @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} K V₂ _inst_1 _inst_6 _inst_7) (@vector_space.dim.{u u} K V₁ _inst_1 _inst_4 _inst_5) → @eq.{u+1} (@submodule.{u u} K V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_6 _inst_7) (@linear_map.range.{u u u} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f) (@lattice.has_top.top.{u} (@submodule.{u u} K V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_6 _inst_7) (@submodule.lattice.has_top.{u u} K V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_6 _inst_7)) → @eq.{u+1} (@submodule.{u u} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (@linear_map.ker.{u u u} K V₁ V₂ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_6 _inst_5 _inst_7 f) (@lattice.has_bot.bot.{u} (@submodule.{u u} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5) (@submodule.lattice.has_bot.{u u} K V₁ (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) _inst_4 _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], @eq.{u+1} (@submodule.{u u} α ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))) (@linear_map.range.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)) (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3)) (@lattice.has_top.top.{u} (@submodule.{u u} α ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))) (@submodule.lattice.has_top.{u u} α ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+1}
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))
    (@lattice.has_bot.bot.{u}
       (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_bot.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @has_lt.lt.{u+1} cardinal.{u}
    (@preorder.to_has_lt.{u+1} cardinal.{u}
       (@partial_order.to_preorder.{u+1} cardinal.{u}
          (@ordered_comm_monoid.to_partial_order.{u+1} cardinal.{u}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{u+1} cardinal.{u}
                cardinal.canonically_ordered_monoid.{u}))))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    cardinal.omega.{u}

σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α ((σ → α) → α) _inst_2
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247    { rw [dim_R], exact cardinal.nat_lt_omega _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mv_polynomial.dim_R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cardinal.nat_lt_omega'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 211, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/set_theory/cardinal.lean&#x27;, &#x27;line&#x27;: 645, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2 (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)) (@coe.{1 u+2} nat cardinal.{u} (@coe_to_lift.{1 u+2} nat cardinal.{u} (@coe_base.{1 u+2} nat cardinal.{u} (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u}))) (@fintype.card.{u} (σ → α) (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1 (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b)) (λ (a : σ), _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @has_lt.lt.{u+1} cardinal.{u} (@preorder.to_has_lt.{u+1} cardinal.{u} (@partial_order.to_preorder.{u+1} cardinal.{u} (@ordered_comm_monoid.to_partial_order.{u+1} cardinal.{u} (@canonically_ordered_monoid.to_ordered_comm_monoid.{u+1} cardinal.{u} cardinal.canonically_ordered_monoid.{u})))) (@coe.{1 u+2} nat cardinal.{u} (@coe_to_lift.{1 u+2} nat cardinal.{u} (@coe_base.{1 u+2} nat cardinal.{u} (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u}))) n) cardinal.omega.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @has_lt.lt.{u+1} cardinal.{u}
    (@preorder.to_has_lt.{u+1} cardinal.{u}
       (@partial_order.to_preorder.{u+1} cardinal.{u}
          (@ordered_comm_monoid.to_partial_order.{u+1} cardinal.{u}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{u+1} cardinal.{u}
                cardinal.canonically_ordered_monoid.{u}))))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    cardinal.omega.{u}

σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α ((σ → α) → α) _inst_2
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @has_lt.lt.{u+1} cardinal.{u}
    (@preorder.to_has_lt.{u+1} cardinal.{u}
       (@partial_order.to_preorder.{u+1} cardinal.{u}
          (@ordered_comm_monoid.to_partial_order.{u+1} cardinal.{u}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{u+1} cardinal.{u}
                cardinal.canonically_ordered_monoid.{u}))))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    cardinal.omega.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @has_lt.lt.{u+1} cardinal.{u}
    (@preorder.to_has_lt.{u+1} cardinal.{u}
       (@partial_order.to_preorder.{u+1} cardinal.{u}
          (@ordered_comm_monoid.to_partial_order.{u+1} cardinal.{u}
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{u+1} cardinal.{u}
                cardinal.canonically_ordered_monoid.{u}))))
    (@coe.{1 u+2} nat cardinal.{u}
       (@coe_to_lift.{1 u+2} nat cardinal.{u}
          (@coe_base.{1 u+2} nat cardinal.{u}
             (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
       (@fintype.card.{u} (σ → α)
          (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1 (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b))
             (λ (a : σ), _inst_3))))
    cardinal.omega.{u}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α ((σ → α) → α) _inst_2
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    { rw [dim_R, dim_fun, dim_of_field, mul_one] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mv_polynomial.dim_R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dim_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dim_of_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 211, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/dimension.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2 (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)) (@coe.{1 u+2} nat cardinal.{u} (@coe_to_lift.{1 u+2} nat cardinal.{u} (@coe_base.{1 u+2} nat cardinal.{u} (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u}))) (@fintype.card.{u} (σ → α) (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1 (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b)) (λ (a : σ), _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {K : Type u} [_inst_1 : discrete_field.{u} K] {V η : Type u} [_inst_9 : fintype.{u} η] [_inst_10 : add_comm_group.{u} V] [_inst_11 : @vector_space.{u u} K V _inst_1 _inst_10], @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} K (η → V) _inst_1 (@pi.add_comm_group.{u u} η (λ (a : η), V) (λ (i : η), _inst_10)) (@pi.module.{u u u} η (λ (a : η), V) K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_1)))) (λ (i : η), _inst_10) (λ (i : η), _inst_11))) (@has_mul.mul.{u+1} cardinal.{u} cardinal.has_mul.{u} (@coe.{1 u+2} nat cardinal.{u} (@coe_to_lift.{1 u+2} nat cardinal.{u} (@coe_base.{1 u+2} nat cardinal.{u} (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u}))) (@fintype.card.{u} η _inst_9)) (@vector_space.dim.{u u} K V _inst_1 _inst_10 _inst_11))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (K : Type u) [_inst_6 : discrete_field.{u} K], @eq.{u+2} cardinal.{u} (@vector_space.dim.{u u} K K _inst_6 (@ring.to_add_comm_group.{u} K (@domain.to_ring.{u} K (@division_ring.to_domain.{u} K (@field.to_division_ring.{u} K (@discrete_field.to_field.{u} K _inst_6))))) (@discrete_field.to_vector_space.{u} K _inst_6)) (@has_one.one.{u+1} cardinal.{u} cardinal.has_one.{u})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (u+1)} [_inst_1 : monoid.{u+1} α] (a : α), @eq.{u+2} α (@has_mul.mul.{u+1} α (@semigroup.to_has_mul.{u+1} α (@monoid.to_semigroup.{u+1} α _inst_1)) a (@has_one.one.{u+1} α (@monoid.to_has_one.{u+1} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α ((σ → α) → α) _inst_2
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α ((σ → α) → α) _inst_2
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@coe.{1 u+2} nat cardinal.{u}
       (@coe_to_lift.{1 u+2} nat cardinal.{u}
          (@coe_base.{1 u+2} nat cardinal.{u}
             (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
       (@fintype.card.{u} (σ → α)
          (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1 (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b))
             (λ (a : σ), _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@has_mul.mul.{u+1} cardinal.{u} cardinal.has_mul.{u}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          (@fintype.card.{u} (σ → α)
             (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1
                (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b))
                (λ (a : σ), _inst_3))))
       (@vector_space.dim.{u u} α α _inst_2
          (@ring.to_add_comm_group.{u} α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (@discrete_field.to_vector_space.{u} α _inst_2)))
    (@coe.{1 u+2} nat cardinal.{u}
       (@coe_to_lift.{1 u+2} nat cardinal.{u}
          (@coe_base.{1 u+2} nat cardinal.{u}
             (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
       (@fintype.card.{u} (σ → α)
          (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1 (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b))
             (λ (a : σ), _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@has_mul.mul.{u+1} cardinal.{u} cardinal.has_mul.{u}
       (@coe.{1 u+2} nat cardinal.{u}
          (@coe_to_lift.{1 u+2} nat cardinal.{u}
             (@coe_base.{1 u+2} nat cardinal.{u}
                (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
          (@fintype.card.{u} (σ → α)
             (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1
                (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b))
                (λ (a : σ), _inst_3))))
       (@has_one.one.{u+1} cardinal.{u} cardinal.has_one.{u}))
    (@coe.{1 u+2} nat cardinal.{u}
       (@coe_to_lift.{1 u+2} nat cardinal.{u}
          (@coe_base.{1 u+2} nat cardinal.{u}
             (@nat.cast_coe.{u+1} cardinal.{u} cardinal.has_zero.{u} cardinal.has_one.{u} cardinal.has_add.{u})))
       (@fintype.card.{u} (σ → α)
          (@pi.fintype.{u u} σ (λ (a : σ), α) _inst_1 (λ (a b : σ), classical.prop_decidable (@eq.{u+1} σ a b))
             (λ (a : σ), _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α
⊢ @eq.{u+2} cardinal.{u}
    (@vector_space.dim.{u u} α ((σ → α) → α) _inst_2
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
    (@vector_space.dim.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) _inst_2
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  lemma eq_zero_of_eval_eq_zero (p : mv_polynomial σ α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='mv_polynomial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1 → Π (α : Type u_2) [_inst_1 : comm_semiring.{u_2} α], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='Multivariate polynomial, where `σ` is the index set of the variables and
 `α` is the coefficient ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    (h : ∀v:σ → α, p.eval v = 0) (hp : p ∈ restrict_degree σ α (fintype.card α - 1)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mv_polynomial.eval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mv_polynomial.restrict_degree'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/mv_polynomial.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α σ : Type u} [_inst_1 : comm_semiring.{u} α], (σ → α) → @mv_polynomial.{u u} σ α _inst_1 → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (σ : Type u) (α : Type v), nat → Π [_inst_1 : discrete_field.{v} α], @submodule.{v (max u v)} α (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@domain.to_ring.{v} α (@division_ring.to_domain.{v} α (@field.to_division_ring.{v} α (@discrete_field.to_field.{v} α _inst_1)))) (@ring.to_add_comm_group.{(max u v)} (@mv_polynomial.{u v} σ α (@nonzero_comm_semiring.to_comm_semiring.{v} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.ring.{v u} α σ (@nonzero_comm_ring.to_comm_ring.{v} α (@local_ring.to_nonzero_comm_ring.{v} α (@discrete_field.local_ring.{v} α _inst_1))))) (@mv_polynomial.vector_space.{u v} σ α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : fintype.{u_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Evaluate a polynomial `p` given a valuation `f` of all the variables'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253    p = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  let p&#x27; : R σ α := ⟨p, hp⟩ in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mv_polynomial.R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))) (@submodule.{u u} α (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@ring.to_add_comm_group.{u} (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))) (@mv_polynomial.ring.{u u} α σ (@nonzero_comm_ring.to_comm_ring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))) (@mv_polynomial.vector_space.{u u} σ α _inst_2)) (@submodule.has_mem.{u u} α (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@ring.to_add_comm_group.{u} (@mv_polynomial.{u u} σ α (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))) (@mv_polynomial.ring.{u u} α σ (@nonzero_comm_ring.to_comm_ring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))) (@mv_polynomial.vector_space.{u u} σ α _inst_2)) p (@mv_polynomial.restrict_degree.{u u} σ α (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one)) _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  have p&#x27; ∈ (evalᵢ σ α).ker := by rw [mem_ker]; ext v; exact h v,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mv_polynomial.evalᵢ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='linear_map.ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='linear_map.mem_ker'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 235, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 924, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 926, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], @linear_map.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {R M M₂ : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_5 : @module.{u u} R M _inst_1 _inst_2] [_inst_6 : @module.{u u} R M₂ _inst_1 _inst_3], @linear_map.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 → @submodule.{u u} R M _inst_1 _inst_2 _inst_5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R M M₂ : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_3 : add_comm_group.{u} M₂] [_inst_5 : @module.{u u} R M _inst_1 _inst_2] [_inst_6 : @module.{u u} R M₂ _inst_1 _inst_3] {f : @linear_map.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6} {y : M}, iff (@has_mem.mem.{u u} M (@submodule.{u u} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u u} R M _inst_1 _inst_2 _inst_5) y (@linear_map.ker.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6 f)) (@eq.{u+1} M₂ (@coe_fn.{u+1 u+1} (@linear_map.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) (@linear_map.has_coe_to_fun.{u u u} R M M₂ _inst_1 _inst_2 _inst_3 _inst_5 _inst_6) f y) (@has_zero.zero.{u} M₂ (@add_monoid.to_has_zero.{u} M₂ (@add_group.to_add_monoid.{u} M₂ (@add_comm_group.to_add_group.{u} M₂ _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (v : σ → α), @eq.{u+1} α (@mv_polynomial.eval.{u u} α σ (@nonzero_comm_semiring.to_comm_semiring.{u} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))) v p) (@has_zero.zero.{u} α (@no_zero_divisors.to_has_zero.{u} α (@domain.to_no_zero_divisors.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='σ → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' The kernel of a linear map `f : M → M₂` is defined to be `comap f ⊥`. This is equivalent to the
set of `x : M` such that `f x = 0`. The kernel is a submodule of `M`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp
⊢ @has_mem.mem.{u u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    p&#x27;
    (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp
⊢ @eq.{u+1} ((σ → α) → α)
    (@coe_fn.{u+1 u+1}
       (@linear_map.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@linear_map.has_coe_to_fun.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
          (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
             (@domain.to_ring.{u} α
                (@division_ring.to_domain.{u} α
                   (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
             (λ (i : σ → α),
                @ring.to_add_comm_group.{u} α
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
             (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3)
       p&#x27;)
    (@has_zero.zero.{u} ((σ → α) → α)
       (@add_monoid.to_has_zero.{u} ((σ → α) → α)
          (@add_group.to_add_monoid.{u} ((σ → α) → α)
             (@add_comm_group.to_add_group.{u} ((σ → α) → α)
                (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
                   (λ (i : σ → α),
                      @ring.to_add_comm_group.{u} α
                        (@domain.to_ring.{u} α
                           (@division_ring.to_domain.{u} α
                              (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp
⊢ @has_mem.mem.{u u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    p&#x27;
    (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  show p&#x27;.1 = (0 : R σ α).1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='p&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @has_mem.mem.{u u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    p&#x27;
    (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258    rw [ker_evalₗ, mem_bot] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='mv_polynomial.ker_evalₗ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='submodule.mem_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 244, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/linear_algebra/basic.lean&#x27;, &#x27;line&#x27;: 357, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (σ α : Type u) [_inst_1 : fintype.{u} σ] [_inst_2 : discrete_field.{u} α] [_inst_3 : fintype.{u} α], @eq.{u+1} (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)) (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3) (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (λ (i : σ → α), @ring.to_add_comm_group.{u} α (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))) (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2)) (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3)) (@lattice.has_bot.bot.{u} (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)) (@submodule.lattice.has_bot.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) (@domain.to_ring.{u} α (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3) (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (R : Type u) {M : Type u} [_inst_1 : ring.{u} R] [_inst_2 : add_comm_group.{u} M] [_inst_5 : @module.{u u} R M _inst_1 _inst_2] {x : M}, iff (@has_mem.mem.{u u} M (@submodule.{u u} R M _inst_1 _inst_2 _inst_5) (@submodule.has_mem.{u u} R M _inst_1 _inst_2 _inst_5) x (@lattice.has_bot.bot.{u} (@submodule.{u u} R M _inst_1 _inst_2 _inst_5) (@submodule.lattice.has_bot.{u u} R M _inst_1 _inst_2 _inst_5))) (@eq.{u+1} M x (@has_zero.zero.{u} M (@add_monoid.to_has_zero.{u} M (@add_group.to_add_monoid.{u} M (@add_comm_group.to_add_group.{u} M _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @has_mem.mem.{u u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    p&#x27;
    (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @has_mem.mem.{u u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    p&#x27;
    (@lattice.has_bot.bot.{u}
       (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
       (@submodule.lattice.has_bot.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
          (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @eq.{u+1} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) p&#x27;
    (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)))))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @has_mem.mem.{u u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
    (@submodule.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    (@submodule.has_mem.{u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3))
    p&#x27;
    (@linear_map.ker.{u u u} α (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) ((σ → α) → α)
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.add_comm_group.{u u} (σ → α) (λ (a : σ → α), α)
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))))
       (@mv_polynomial.R.inst.{u} σ α _inst_1 _inst_2 _inst_3)
       (@pi.module.{u u u} (σ → α) (λ (a : σ → α), α) α
          (@domain.to_ring.{u} α
             (@division_ring.to_domain.{u} α
                (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
          (λ (i : σ → α),
             @ring.to_add_comm_group.{u} α
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))
          (λ (i : σ → α), @discrete_field.to_vector_space.{u} α _inst_2))
       (@mv_polynomial.evalᵢ.{u} σ α _inst_1 _inst_2 _inst_3))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @eq.{u+1} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) p&#x27;
    (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)))))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259    rw [this]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) p&#x27; (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @eq.{u+1} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) p&#x27;
    (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)))))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='σ α : Type u,
_inst_1 : fintype.{u} σ,
_inst_2 : discrete_field.{u} α,
_inst_3 : fintype.{u} α,
p :
  @mv_polynomial.{u u} σ α
    (@nonzero_comm_semiring.to_comm_semiring.{u} α
       (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
          (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))),
h :
  ∀ (v : σ → α),
    @eq.{u+1} α
      (@mv_polynomial.eval.{u u} α σ
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))
         v
         p)
      (@has_zero.zero.{u} α
         (@no_zero_divisors.to_has_zero.{u} α
            (@domain.to_no_zero_divisors.{u} α
               (@division_ring.to_domain.{u} α
                  (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2)))))),
hp :
  @has_mem.mem.{u u}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@submodule.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    (@submodule.has_mem.{u u} α
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@domain.to_ring.{u} α
          (@division_ring.to_domain.{u} α (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
       (@ring.to_add_comm_group.{u}
          (@mv_polynomial.{u u} σ α
             (@nonzero_comm_semiring.to_comm_semiring.{u} α
                (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                   (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
          (@mv_polynomial.ring.{u u} α σ
             (@nonzero_comm_ring.to_comm_ring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (@mv_polynomial.vector_space.{u u} σ α _inst_2))
    p
    (@mv_polynomial.restrict_degree.{u u} σ α
       (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
       _inst_2),
p&#x27; : @mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3 :=
  @subtype.mk.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (λ
     (x :
       @mv_polynomial.{u u} σ α
         (@nonzero_comm_semiring.to_comm_semiring.{u} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
               (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
       @has_mem.mem.{u u}
         (@mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
         (set.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         (@set.has_mem.{u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
         x
         (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
            (@submodule.{u u} α
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@domain.to_ring.{u} α
                  (@division_ring.to_domain.{u} α
                     (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
               (@ring.to_add_comm_group.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.ring.{u u} α σ
                     (@nonzero_comm_ring.to_comm_ring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
               (@mv_polynomial.vector_space.{u u} σ α _inst_2))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@coe_base_aux.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@submodule.has_coe.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
            (@mv_polynomial.restrict_degree.{u u} σ α
               (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
               _inst_2)))
    p
    hp,
this :
  @eq.{u+1} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3) p&#x27;
    (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
       (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3)))))
⊢ @eq.{u+1}
    (@mv_polynomial.{u u} σ α
       (@nonzero_comm_semiring.to_comm_semiring.{u} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
             (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       p&#x27;)
    (@subtype.val.{u+1}
       (@mv_polynomial.{u u} σ α
          (@nonzero_comm_semiring.to_comm_semiring.{u} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
       (λ
        (x :
          @mv_polynomial.{u u} σ α
            (@nonzero_comm_semiring.to_comm_semiring.{u} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                  (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))),
          @has_mem.mem.{u u}
            (@mv_polynomial.{u u} σ α
               (@nonzero_comm_semiring.to_comm_semiring.{u} α
                  (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                     (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
            (set.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            (@set.has_mem.{u}
               (@mv_polynomial.{u u} σ α
                  (@nonzero_comm_semiring.to_comm_semiring.{u} α
                     (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                        (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
            x
            (@has_coe_t_aux.coe.{u+1 (max (u+1) 1)}
               (@submodule.{u u} α
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@domain.to_ring.{u} α
                     (@division_ring.to_domain.{u} α
                        (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                  (@ring.to_add_comm_group.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.ring.{u u} α σ
                        (@nonzero_comm_ring.to_comm_ring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                  (@mv_polynomial.vector_space.{u u} σ α _inst_2))
               (set.{u}
                  (@mv_polynomial.{u u} σ α
                     (@nonzero_comm_semiring.to_comm_semiring.{u} α
                        (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                           (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
               (@coe_base_aux.{u+1 (max (u+1) 1)}
                  (@submodule.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2))
                  (set.{u}
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2))))))
                  (@submodule.has_coe.{u u} α
                     (@mv_polynomial.{u u} σ α
                        (@nonzero_comm_semiring.to_comm_semiring.{u} α
                           (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@domain.to_ring.{u} α
                        (@division_ring.to_domain.{u} α
                           (@field.to_division_ring.{u} α (@discrete_field.to_field.{u} α _inst_2))))
                     (@ring.to_add_comm_group.{u}
                        (@mv_polynomial.{u u} σ α
                           (@nonzero_comm_semiring.to_comm_semiring.{u} α
                              (@nonzero_comm_ring.to_nonzero_comm_semiring.{u} α
                                 (@local_ring.to_nonzero_comm_ring.{u} α
                                    (@discrete_field.local_ring.{u} α _inst_2)))))
                        (@mv_polynomial.ring.{u u} α σ
                           (@nonzero_comm_ring.to_comm_ring.{u} α
                              (@local_ring.to_nonzero_comm_ring.{u} α (@discrete_field.local_ring.{u} α _inst_2)))))
                     (@mv_polynomial.vector_space.{u u} σ α _inst_2)))
               (@mv_polynomial.restrict_degree.{u u} σ α
                  (@has_sub.sub.{0} nat nat.has_sub (@fintype.card.{u} α _inst_3) (@has_one.one.{0} nat nat.has_one))
                  _inst_2)))
       (@has_zero.zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
          (@add_monoid.to_has_zero.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
             (@add_group.to_add_monoid.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                (@add_comm_group.to_add_group.{u} (@mv_polynomial.R.{u} σ α _inst_1 _inst_2 _inst_3)
                   (@mv_polynomial.R.add_comm_group_1.{u} σ α _inst_1 _inst_2 _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  end mv_polynomial</code></pre>
</body>